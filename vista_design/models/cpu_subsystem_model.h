
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The cpu_subsystem_pv will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>



#pragma once

#include "model_builder.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif




#include "axi_protocol.h"
#include "signal_protocol.h"

using namespace ::tlm;

class cpu_subsystem_pv_base;
class cpu_subsystem_pv_base_mb_compatibility : public mb::mb_module {
  friend class cpu_subsystem_pv_base;
 public:
  typedef unsigned int mb_address_type;
 protected:
  cpu_subsystem_pv_base_mb_compatibility(sc_core::sc_module_name& module_name)
    : mb::mb_module(module_name) {}
 
};

class cpu_subsystem_pv_base_parameters {
 public :
  cpu_subsystem_pv_base_parameters(sc_object* object);
  void print_parameters();

 protected:
  sc_object* m_object;

  sc_core::sc_time clock;
  sc_core::sc_time signal_clock;
  sc_core::sc_time axi_clock;
  double nominal_voltage;
  bool verbose_parameters;
  bool dmi_enabled;
  const char* warning_level;
  unsigned int master0_outstanding;
  unsigned int master0_read_data_queue_size;
  unsigned int master0_write_data_queue_size;
  unsigned int master1_outstanding;
  unsigned int master1_read_data_queue_size;
  unsigned int master1_write_data_queue_size;
  unsigned int n_scu_reset_pipeline_length;
  unsigned int n_periph_reset_pipeline_length;
  unsigned int n_irq_0_pipeline_length;
  unsigned int n_fiq_0_pipeline_length;
  unsigned int n_irq_1_pipeline_length;
  unsigned int n_fiq_1_pipeline_length;
  unsigned int n_reset_0_pipeline_length;
  unsigned int n_wd_reset_0_pipeline_length;
  unsigned int n_reset_1_pipeline_length;
  unsigned int n_wd_reset_1_pipeline_length;
  unsigned int irq_0_pipeline_length;
  unsigned int irq_1_pipeline_length;
  unsigned int irq_2_pipeline_length;
  unsigned int irq_3_pipeline_length;
  unsigned int irq_4_pipeline_length;
  unsigned int irq_5_pipeline_length;
  unsigned int irq_6_pipeline_length;
  unsigned int irq_7_pipeline_length;
  unsigned int dcache_size;
  unsigned int icache_size;
  const char* cache_control;
  const char* dcache_control;
  const char* icache_control;
  unsigned long long control_page_address;
  const char* elf_image_file;
  unsigned int gdbstub_port;
  sc_core::sc_time instruction_latency;
  mb::utl::energy instruction_energy;
  sc_core::sc_time lt_synch_quantum;
  bool high_vec;
  unsigned int cluster_id;
  sc_core::sc_time periph_clock;
  unsigned int periph_base;
};

class cpu_subsystem_pv_base : public cpu_subsystem_pv_base_mb_compatibility,
                           public cpu_subsystem_pv_base_parameters
{
 private:
  typedef cpu_subsystem_pv_base_mb_compatibility mb_compatibility_class;
  typedef cpu_subsystem_pv_base_mb_compatibility BASE_TYPE;
 public:
  typedef esl::tlm_types::Address mb_address_type;
 public:
  typedef cpu_subsystem_pv_base self;
  SC_HAS_PROCESS(cpu_subsystem_pv_base);
  cpu_subsystem_pv_base(sc_core::sc_module_name& module_name);
  virtual void reset_model();
  enum port_enum {master0_idx,master1_idx,n_scu_reset_idx,n_periph_reset_idx,n_irq_0_idx,n_fiq_0_idx,n_irq_1_idx,n_fiq_1_idx,n_reset_0_idx,n_wd_reset_0_idx,wd_reset_req_0_idx,n_reset_1_idx,n_wd_reset_1_idx,wd_reset_req_1_idx,irq_0_idx,irq_1_idx,irq_2_idx,irq_3_idx,irq_4_idx,irq_5_idx,irq_6_idx,irq_7_idx };
  
 private:

  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_master0_bw_process;
  mb::tlm20::bw_process<tlm::tlm_base_protocol_types> m_master1_bw_process;

 protected:


  virtual void get_dmi_delay_cb(tlm::tlm_generic_payload& trans, tlm::tlm_dmi& dmiData, unsigned port_index) {
    sc_time t = sc_core::SC_ZERO_TIME;
    
    getPVTBaseModel()->get_write_delay_for_dmi(port_index, trans, t);
    dmiData.set_write_latency(t);
    t = sc_core::SC_ZERO_TIME;
    getPVTBaseModel()->get_read_delay_for_dmi(port_index, trans, t);
    dmiData.set_read_latency(t);
    
  }

  virtual void invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void master0_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }
  virtual void master1_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  }

  

  



  

  
  

 public:

  ////////////////////////////////////////
  // functions for initiator port: master0
  ////////////////////////////////////////
  bool master0_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    master0->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool master0_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master0_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master0_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master0_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master0_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master0_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master0_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master0_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool master0_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master0_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master0_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master0_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master0_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master0_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master0_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master0_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool master0_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master0_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master0_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master0_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master0_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master0_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master0_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master0_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool master0_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master0_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master0_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master0_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master0_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master0_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master0_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master0_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master0[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 

  ////////////////////////////////////////
  // functions for initiator port: master1
  ////////////////////////////////////////
  bool master1_transport(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    sc_core::sc_time t;
    trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);
    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    master1->b_transport(trans, t);
    return trans.get_response_status() == tlm::TLM_OK_RESPONSE;
  }

   
  bool master1_read(mb_address_type address, unsigned char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master1_read(mb_address_type address, unsigned short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master1_read(mb_address_type address, unsigned int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master1_read(mb_address_type address, sc_dt::uint64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master1_read(mb_address_type address, char* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master1_read(mb_address_type address, short* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master1_read(mb_address_type address, int* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  bool master1_read(mb_address_type address, sc_dt::int64* data, unsigned _size, 
                        unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }   
  
  bool master1_write(mb_address_type address,unsigned char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master1_write(mb_address_type address,unsigned short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master1_write(mb_address_type address,unsigned int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master1_write(mb_address_type address,sc_dt::uint64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master1_write(mb_address_type address,char* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master1_write(mb_address_type address,short* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master1_write(mb_address_type address,int* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  } 
  
  bool master1_write(mb_address_type address,sc_dt::int64* data, unsigned _size,
                         unsigned streaming_width = 0) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(streaming_width);

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;

  }  

  bool master1_read(mb_address_type address,unsigned char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master1_read(mb_address_type address,unsigned short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master1_read(mb_address_type address,unsigned int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master1_read(mb_address_type address,sc_dt::uint64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master1_read(mb_address_type address,char& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master1_read(mb_address_type address,short& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master1_read(mb_address_type address,int& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }

  bool master1_read(mb_address_type address,sc_dt::int64& data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_READ_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }  
  
  bool master1_write(mb_address_type address,unsigned char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master1_write(mb_address_type address,unsigned short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master1_write(mb_address_type address,unsigned int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master1_write(mb_address_type address,sc_dt::uint64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master1_write(mb_address_type address,char data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master1_write(mb_address_type address,short data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master1_write(mb_address_type address,int data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  }
  
  bool master1_write(mb_address_type address,sc_dt::int64 data) {

    mb_address_type local_address = address;
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    trans->set_streaming_width(sizeof(data));

    mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*trans);
    if (extension && !extension->getToken()) {
      esl::sc_sim::mb_scene* scene = getPVTBaseModel()->getCurrentScene();
      if (scene)
        extension->setToken(scene->getToken());
    }
    
    bool retv = mb::tlm20::do_b_transport(*master1[0], *trans, tlm::TLM_WRITE_COMMAND, local_address,
                                          (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;

  } 



  ///////////////////////////////////////
  // dbg functions for port: master0
  /////////////////////////////////////// 
  
  
  unsigned master0_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master0_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master0_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master0_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master0_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master0_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master0_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master0_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master0_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master0_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master0[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 

  ///////////////////////////////////////
  // dbg functions for port: master1
  /////////////////////////////////////// 
  
  
  unsigned master1_read_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master1_read_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master1_read_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master1_read_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master1_read_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master1_read_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master1_read_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  unsigned master1_read_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, unsigned char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, unsigned short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, unsigned int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, sc_dt::uint64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, char* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, short* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, int* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, sc_dt::int64* data, unsigned _size) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)data, _size * sizeof(*data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, unsigned char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, unsigned short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, unsigned int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, sc_dt::uint64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, char& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, short& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, int& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }
  
  unsigned master1_read_dbg(mb_address_type address, sc_dt::int64& data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_READ_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, unsigned char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, unsigned short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, unsigned int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, sc_dt::uint64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, char data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, short data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, int data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  }

  unsigned master1_write_dbg(mb_address_type address, sc_dt::int64 data) {
    tlm::tlm_generic_payload* trans = mb::tlm20::get_object_pull().new_payload();
    
    unsigned retv = mb::tlm20::do_transport_dbg(*master1[0], *trans, tlm::TLM_WRITE_COMMAND,
                                                address, (unsigned char*)&data, sizeof(data));

    trans->release();
    return retv;
  } 


  tlm::tlm_generic_payload* payload_on_stack;
  tlm::tlm_generic_payload* payload_for_token;

  ////////////////////////////////////////
  // request DMI for port: master0
  ////////////////////////////////////////
  bool master0_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = master0->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool master0_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = master0->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }
  ////////////////////////////////////////
  // request DMI for port: master1
  ////////////////////////////////////////
  bool master1_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    bool retv = false;

    {
      mb::tlm20::save_payload<tlm::tlm_generic_payload> save(*trans);
      trans->set_command(tlm::TLM_READ_COMMAND);
      trans->set_address(address);
      retv = master1->get_direct_mem_ptr(*trans, dmi_data);
    }
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

  bool master1_get_direct_memory_ptr(tlm::tlm_command command, mb_address_type address, tlm::tlm_dmi& dmi_data) {
    tlm::tlm_generic_payload* trans = payload_on_stack;
    if (!payload_on_stack)
      trans = mb::tlm20::get_object_pull().new_payload();

    trans->set_command(command);
    trans->set_address(address);
    
    bool retv = master1->get_direct_mem_ptr(*trans, dmi_data);
    if (!payload_on_stack)
      trans->release();
    return retv;
  }

 

  
 protected: 
  virtual void n_scu_reset_callback() {
  }
  virtual void cb_signal_n_scu_reset(bool value) {
    n_scu_reset_callback();
  }
  virtual void n_periph_reset_callback() {
  }
  virtual void cb_signal_n_periph_reset(bool value) {
    n_periph_reset_callback();
  }
  virtual void n_irq_0_callback() {
  }
  virtual void cb_signal_n_irq_0(bool value) {
    n_irq_0_callback();
  }
  virtual void n_fiq_0_callback() {
  }
  virtual void cb_signal_n_fiq_0(bool value) {
    n_fiq_0_callback();
  }
  virtual void n_irq_1_callback() {
  }
  virtual void cb_signal_n_irq_1(bool value) {
    n_irq_1_callback();
  }
  virtual void n_fiq_1_callback() {
  }
  virtual void cb_signal_n_fiq_1(bool value) {
    n_fiq_1_callback();
  }
  virtual void n_reset_0_callback() {
  }
  virtual void cb_signal_n_reset_0(bool value) {
    n_reset_0_callback();
  }
  virtual void n_wd_reset_0_callback() {
  }
  virtual void cb_signal_n_wd_reset_0(bool value) {
    n_wd_reset_0_callback();
  }
  virtual void n_reset_1_callback() {
  }
  virtual void cb_signal_n_reset_1(bool value) {
    n_reset_1_callback();
  }
  virtual void n_wd_reset_1_callback() {
  }
  virtual void cb_signal_n_wd_reset_1(bool value) {
    n_wd_reset_1_callback();
  }
  virtual void irq_0_callback() {
  }
  virtual void cb_signal_irq_0(bool value) {
    irq_0_callback();
  }
  virtual void irq_1_callback() {
  }
  virtual void cb_signal_irq_1(bool value) {
    irq_1_callback();
  }
  virtual void irq_2_callback() {
  }
  virtual void cb_signal_irq_2(bool value) {
    irq_2_callback();
  }
  virtual void irq_3_callback() {
  }
  virtual void cb_signal_irq_3(bool value) {
    irq_3_callback();
  }
  virtual void irq_4_callback() {
  }
  virtual void cb_signal_irq_4(bool value) {
    irq_4_callback();
  }
  virtual void irq_5_callback() {
  }
  virtual void cb_signal_irq_5(bool value) {
    irq_5_callback();
  }
  virtual void irq_6_callback() {
  }
  virtual void cb_signal_irq_6(bool value) {
    irq_6_callback();
  }
  virtual void irq_7_callback() {
  }
  virtual void cb_signal_irq_7(bool value) {
    irq_7_callback();
  } 
  
  
 

 public:
  typedef tlm::tlm_base_protocol_types master0_protocol_types;
  typedef tlm::tlm_base_protocol_types master1_protocol_types;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type master0_payload_type;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type master1_payload_type;

 public:
  // port declarations 

  tlm::tlm_initiator_socket <64, tlm::tlm_base_protocol_types> master0;
  tlm::tlm_initiator_socket <64, tlm::tlm_base_protocol_types> master1;
  sc_core::sc_out<bool> wd_reset_req_0;
  sc_core::sc_out<bool> wd_reset_req_1;  
  mb::tlm20::signal_in<bool> n_scu_reset; 
  mb::tlm20::signal_in<bool> n_periph_reset; 
  mb::tlm20::signal_in<bool> n_irq_0; 
  mb::tlm20::signal_in<bool> n_fiq_0; 
  mb::tlm20::signal_in<bool> n_irq_1; 
  mb::tlm20::signal_in<bool> n_fiq_1; 
  mb::tlm20::signal_in<bool> n_reset_0; 
  mb::tlm20::signal_in<bool> n_wd_reset_0; 
  mb::tlm20::signal_in<bool> n_reset_1; 
  mb::tlm20::signal_in<bool> n_wd_reset_1; 
  mb::tlm20::signal_in<bool> irq_0; 
  mb::tlm20::signal_in<bool> irq_1; 
  mb::tlm20::signal_in<bool> irq_2; 
  mb::tlm20::signal_in<bool> irq_3; 
  mb::tlm20::signal_in<bool> irq_4; 
  mb::tlm20::signal_in<bool> irq_5; 
  mb::tlm20::signal_in<bool> irq_6; 
  mb::tlm20::signal_in<bool> irq_7; 

    
 public:
  void send_b_transport(unsigned port_index, tlm::tlm_generic_payload& trans, sc_core::sc_time& t) {
    if (port_index > get_port_count() || !is_master(port_index))
      return;
    switch (port_index) {
    case master0_idx:
      master0->b_transport(trans, t);
    case master1_idx:
      master1->b_transport(trans, t);
    }
  }

  unsigned send_transport_dbg(unsigned port_index, tlm::tlm_generic_payload& trans) {
    if (port_index > get_port_count() || !is_master(port_index))
      return 0;
    switch (port_index) {
    case master0_idx:
      return master0->transport_dbg(trans);
    case master1_idx:
      return master1->transport_dbg(trans);
    }
    return 0;
  }
  
  

 public:
  mb::mb_token_ptr get_current_token() {
    mb::mb_token_ptr token_ptr = mb_module::get_current_token();
    if (token_ptr)
      return token_ptr;
    if (payload_for_token) {
      mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(*payload_for_token);
      if (extension) {
        mb_module::set_current_token(extension->getToken());
        return extension->getToken();
      }
    }
    return 0;
  }
  

 protected:
};



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your cpu_subsystem model.
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>


#pragma once

#include "model_builder.h"


class cpu_subsystem_machine_arch : public MachineArch { 
    
    public:
    
    public:
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: master0
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: master0, transaction: WRITE
        //////
        
        void transaction_instance__master0__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        //////
        // functions for port: master0, transaction: READ
        //////
        
        void transaction_instance__master0__READ
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: master1
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: master1, transaction: WRITE
        //////
        
        void transaction_instance__master1__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        //////
        // functions for port: master1, transaction: READ
        //////
        
        void transaction_instance__master1__READ
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_scu_reset
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_scu_reset, transaction: WRITE
        //////
        
        void transaction_instance__n_scu_reset__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_periph_reset
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_periph_reset, transaction: WRITE
        //////
        
        void transaction_instance__n_periph_reset__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_irq_0
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_irq_0, transaction: WRITE
        //////
        
        void transaction_instance__n_irq_0__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_fiq_0
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_fiq_0, transaction: WRITE
        //////
        
        void transaction_instance__n_fiq_0__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_irq_1
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_irq_1, transaction: WRITE
        //////
        
        void transaction_instance__n_irq_1__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_fiq_1
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_fiq_1, transaction: WRITE
        //////
        
        void transaction_instance__n_fiq_1__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_reset_0
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_reset_0, transaction: WRITE
        //////
        
        void transaction_instance__n_reset_0__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_wd_reset_0
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_wd_reset_0, transaction: WRITE
        //////
        
        void transaction_instance__n_wd_reset_0__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: wd_reset_req_0
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: wd_reset_req_0, transaction: WRITE
        //////
        
        void transaction_instance__wd_reset_req_0__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_reset_1
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_reset_1, transaction: WRITE
        //////
        
        void transaction_instance__n_reset_1__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: n_wd_reset_1
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: n_wd_reset_1, transaction: WRITE
        //////
        
        void transaction_instance__n_wd_reset_1__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: wd_reset_req_1
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: wd_reset_req_1, transaction: WRITE
        //////
        
        void transaction_instance__wd_reset_req_1__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_0
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_0, transaction: WRITE
        //////
        
        void transaction_instance__irq_0__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_1
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_1, transaction: WRITE
        //////
        
        void transaction_instance__irq_1__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_2
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_2, transaction: WRITE
        //////
        
        void transaction_instance__irq_2__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_3
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_3, transaction: WRITE
        //////
        
        void transaction_instance__irq_3__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_4
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_4, transaction: WRITE
        //////
        
        void transaction_instance__irq_4__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_5
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_5, transaction: WRITE
        //////
        
        void transaction_instance__irq_5__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_6
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_6, transaction: WRITE
        //////
        
        void transaction_instance__irq_6__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: irq_7
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: irq_7, transaction: WRITE
        //////
        
        void transaction_instance__irq_7__WRITE
          (
            sc_dt::uint64 _address,
            sc_dt::uint64 _size,
            sc_dt::uint64 _data, 
            bool has_been_error, 
            sc_dt::uint64 currentTime
          );
        
        
    
    public:
        void configureClock(unsigned portIndex, sc_dt::uint64 clock) {
          m_clocks[portIndex] = clock;
        }
        void startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime);
        VariableBase* getVariableBasePtrByName(const char* name);
        Register* getRegisterByName(const char* name);
        virtual void reset();
        
        virtual bool getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end);
        
    
    public:
        void callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime);
    
    public:
        //constructor
        cpu_subsystem_machine_arch();
    
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The cpu_subsystem_t will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>


#pragma once

#include "model_builder.h"
#include "axi_protocol.h"

#include "signal_protocol.h"
 


class cpu_subsystem_t_base : public papoulis::SystemCBaseModel {
public:
  static cpu_subsystem_t_base* create_t(const char* _name, long simulation);
public:
  cpu_subsystem_t_base(sc_core::sc_module_name& module_name, long simulation);
 
  enum port_enum {master0, master1, n_scu_reset, n_periph_reset, n_irq_0, n_fiq_0, n_irq_1, n_fiq_1, n_reset_0, n_wd_reset_0, wd_reset_req_0, n_reset_1, n_wd_reset_1, wd_reset_req_1, irq_0, irq_1, irq_2, irq_3, irq_4, irq_5, irq_6, irq_7};

protected:
  // The following callbacks are called whenever there is a transaction start or end in the port
  // If you want to add your own code (like updating the machine architecture object), 
  // you have to overload these functions in your derived class.

  virtual void accept_axi_READ
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64& TR_ID,
     sc_dt::uint64 ARADDR,
     sc_dt::uint64 RDATA,
     sc_dt::uint64& ARSIZE,
     sc_dt::uint64 block_size,
     sc_dt::uint64& ARBURST,
     sc_dt::uint64& ARLEN,
     sc_dt::uint64& ARLOCK) {};
  virtual void end_axi_READ
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64& TR_ID,
     sc_dt::uint64 ARADDR,
     sc_dt::uint64 RDATA,
     sc_dt::uint64& ARSIZE,
     sc_dt::uint64 block_size,
     sc_dt::uint64& ARBURST,
     sc_dt::uint64& ARLEN,
     sc_dt::uint64& ARLOCK) {};

  virtual void accept_axi_WRITE
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64& TR_ID,
     sc_dt::uint64 AWADDR,
     sc_dt::uint64 WDATA,
     sc_dt::uint64& AWSIZE,
     sc_dt::uint64 block_size,
     sc_dt::uint64& AWBURST,
     sc_dt::uint64& AWLEN,
     sc_dt::uint64& AWLOCK) {};
  virtual void end_axi_WRITE
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64& TR_ID,
     sc_dt::uint64 AWADDR,
     sc_dt::uint64 WDATA,
     sc_dt::uint64& AWSIZE,
     sc_dt::uint64 block_size,
     sc_dt::uint64& AWBURST,
     sc_dt::uint64& AWLEN,
     sc_dt::uint64& AWLOCK) {};

  virtual void accept_signal_WRITE
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 address,
     sc_dt::uint64 value_p,
     sc_dt::uint64 block_size) {};
  virtual void end_signal_WRITE
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 address,
     sc_dt::uint64 value_p,
     sc_dt::uint64 block_size) {};


public:
  virtual cpu_subsystem_machine_arch* getMachineArch() const {
    return m_machineArch;
  }

  virtual bool portHasRegisters(unsigned portIndex);
  
  virtual bool triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans);

  virtual const char* get_library_name() {return "Models";}
  virtual const char* get_model_vendor() {return "Mentor.com";}
  virtual const char* get_model_version() {return "1.0";}

protected:
  /* schedule functions */
  void schedule_axi_READ
    (long port_index,
     sc_dt::uint64 delay,
     long& burst_size,
     esl::include::transaction_power& power , long TR_ID, long ARADDR, long* RDATA, long ARSIZE, long block_size, long ARBURST, long ARLEN, long ARLOCK);
  void schedule_axi_WRITE
    (long port_index,
     sc_dt::uint64 delay,
     long& burst_size,
     esl::include::transaction_power& power , long TR_ID, long AWADDR, long* WDATA, long AWSIZE, long block_size, long AWBURST, long AWLEN, long AWLOCK);
  void schedule_signal_WRITE
    (long port_index,
     sc_dt::uint64 delay,
     long& burst_size,
     esl::include::transaction_power& power , long address, long* value_p, long block_size);
public:
  /* called when "params.m_phase" is sent through the "port_index" port */
  virtual void sent_phase_cb(unsigned port_index,
                             esl::sc_sim::mb_cb_params& params) {
    
  }
                             
  /* called when "params.m_phase" is received by the "port_index" port */
  virtual void received_phase_cb(unsigned port_index,
                                 esl::sc_sim::mb_cb_params& params) {
    
  }

  
protected:
  /* machine architecture */
  cpu_subsystem_machine_arch* m_machineArch;

protected:
  friend class cpu_subsystem_model;
  
  

protected:
  // parameters
  sc_core::sc_time clock;
  sc_core::sc_time signal_clock;
  sc_core::sc_time axi_clock;
  double nominal_voltage;
  bool verbose_parameters;
  bool dmi_enabled;
  const char* warning_level;
  unsigned int master0_outstanding;
  unsigned int master0_read_data_queue_size;
  unsigned int master0_write_data_queue_size;
  unsigned int master1_outstanding;
  unsigned int master1_read_data_queue_size;
  unsigned int master1_write_data_queue_size;
  unsigned int n_scu_reset_pipeline_length;
  unsigned int n_periph_reset_pipeline_length;
  unsigned int n_irq_0_pipeline_length;
  unsigned int n_fiq_0_pipeline_length;
  unsigned int n_irq_1_pipeline_length;
  unsigned int n_fiq_1_pipeline_length;
  unsigned int n_reset_0_pipeline_length;
  unsigned int n_wd_reset_0_pipeline_length;
  unsigned int n_reset_1_pipeline_length;
  unsigned int n_wd_reset_1_pipeline_length;
  unsigned int irq_0_pipeline_length;
  unsigned int irq_1_pipeline_length;
  unsigned int irq_2_pipeline_length;
  unsigned int irq_3_pipeline_length;
  unsigned int irq_4_pipeline_length;
  unsigned int irq_5_pipeline_length;
  unsigned int irq_6_pipeline_length;
  unsigned int irq_7_pipeline_length;
  unsigned int dcache_size;
  unsigned int icache_size;
  const char* cache_control;
  const char* dcache_control;
  const char* icache_control;
  unsigned long long control_page_address;
  const char* elf_image_file;
  unsigned int gdbstub_port;
  sc_core::sc_time instruction_latency;
  mb::utl::energy instruction_energy;
  sc_core::sc_time lt_synch_quantum;
  bool high_vec;
  unsigned int cluster_id;
  sc_core::sc_time periph_clock;
  unsigned int periph_base;

protected:
  long m_simulation;

 
  
  
  

  static const unsigned port_count = 22;
  papoulis::SystemCBaseModel::PortDescription port_descriptions[port_count];
  
  

protected:
  std::vector<esl::sc_sim::pipeline_policy*> m_pipeline_vector;
  std::vector<esl::sc_sim::sequential_policy*> m_sequential_vector;
  std::vector<esl::sc_sim::delay_policy*> m_delay_vector;
  std::vector<esl::sc_sim::uniform_bus_policy*> m_bus_vector;
  std::vector<esl::sc_sim::power_policy*> m_power_vector;
  std::vector<esl::sc_sim::state_power_policy*> m_state_power_vector;
public:
  virtual void update_sync_all();
  virtual void update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle);
  virtual void update_sequential_parameters(esl::sc_sim::sequential_policy* handle);
  virtual void update_delay_parameters(esl::sc_sim::delay_policy* handle);
  virtual void update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle);
  virtual void update_power_parameters(esl::sc_sim::power_policy* handle);
  virtual void update_global_power_parameters(esl::sc_sim::constant_global_power_policy* handle);
  virtual void update_state_power_parameters(esl::sc_sim::state_power_policy* handle);
protected: /* InterfaceFunctions */
  virtual TransactionCallbackFunctionPointer getTransactionCallback(unsigned callbackIndex);
  config::real80 get_state_power();
protected:

  void start_transaction_axi_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void end_transaction_axi_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void start_transaction_axi_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void end_transaction_axi_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void start_transaction_signal_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
  void end_transaction_signal_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     sc_dt::uint64 startTime,
     sc_dt::uint64 endTime,
     sc_dt::uint64* parameters,
     bool hasBeenError);
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for cpu_subsystem.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>


#pragma once

#include "model_builder.h"



 


// forward declaration for pv class
class cpu_subsystem_pv;



using namespace std;

class cpu_subsystem_pvt_param_defaults {
  
public:
  cpu_subsystem_pvt_param_defaults(const char* hier_name) {

    sc_core::sc_time clock;
    sc_core::sc_time signal_clock;
    sc_core::sc_time axi_clock;
    double nominal_voltage;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    unsigned int master0_outstanding;
    unsigned int master0_read_data_queue_size;
    unsigned int master0_write_data_queue_size;
    unsigned int master1_outstanding;
    unsigned int master1_read_data_queue_size;
    unsigned int master1_write_data_queue_size;
    unsigned int n_scu_reset_pipeline_length;
    unsigned int n_periph_reset_pipeline_length;
    unsigned int n_irq_0_pipeline_length;
    unsigned int n_fiq_0_pipeline_length;
    unsigned int n_irq_1_pipeline_length;
    unsigned int n_fiq_1_pipeline_length;
    unsigned int n_reset_0_pipeline_length;
    unsigned int n_wd_reset_0_pipeline_length;
    unsigned int n_reset_1_pipeline_length;
    unsigned int n_wd_reset_1_pipeline_length;
    unsigned int irq_0_pipeline_length;
    unsigned int irq_1_pipeline_length;
    unsigned int irq_2_pipeline_length;
    unsigned int irq_3_pipeline_length;
    unsigned int irq_4_pipeline_length;
    unsigned int irq_5_pipeline_length;
    unsigned int irq_6_pipeline_length;
    unsigned int irq_7_pipeline_length;
    unsigned int dcache_size;
    unsigned int icache_size;
    const char* cache_control;
    const char* dcache_control;
    const char* icache_control;
    unsigned long long control_page_address;
    const char* elf_image_file;
    unsigned int gdbstub_port;
    sc_core::sc_time instruction_latency;
    mb::utl::energy instruction_energy;
    sc_core::sc_time lt_synch_quantum;
    bool high_vec;
    unsigned int cluster_id;
    sc_core::sc_time periph_clock;
    unsigned int periph_base;
    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    signal_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("signal_clock", clock, hier_name);
    axi_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("axi_clock", clock, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", 1, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", true, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", true, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", "WARNING", hier_name);
    master0_outstanding = ::mb::sysc::sdInitParameter<unsigned int>("master0_outstanding", 1, hier_name);
    master0_read_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master0_read_data_queue_size", 0, hier_name);
    master0_write_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master0_write_data_queue_size", 0, hier_name);
    master1_outstanding = ::mb::sysc::sdInitParameter<unsigned int>("master1_outstanding", 1, hier_name);
    master1_read_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master1_read_data_queue_size", 0, hier_name);
    master1_write_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master1_write_data_queue_size", 0, hier_name);
    n_scu_reset_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_scu_reset_pipeline_length", 2, hier_name);
    n_periph_reset_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_periph_reset_pipeline_length", 2, hier_name);
    n_irq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_irq_0_pipeline_length", 2, hier_name);
    n_fiq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_fiq_0_pipeline_length", 2, hier_name);
    n_irq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_irq_1_pipeline_length", 2, hier_name);
    n_fiq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_fiq_1_pipeline_length", 2, hier_name);
    n_reset_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_reset_0_pipeline_length", 2, hier_name);
    n_wd_reset_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_wd_reset_0_pipeline_length", 2, hier_name);
    n_reset_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_reset_1_pipeline_length", 2, hier_name);
    n_wd_reset_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_wd_reset_1_pipeline_length", 2, hier_name);
    irq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_0_pipeline_length", 2, hier_name);
    irq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_1_pipeline_length", 2, hier_name);
    irq_2_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_2_pipeline_length", 2, hier_name);
    irq_3_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_3_pipeline_length", 2, hier_name);
    irq_4_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_4_pipeline_length", 2, hier_name);
    irq_5_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_5_pipeline_length", 2, hier_name);
    irq_6_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_6_pipeline_length", 2, hier_name);
    irq_7_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_7_pipeline_length", 2, hier_name);
    dcache_size = ::mb::sysc::sdInitParameter<unsigned int>("dcache_size", 32768, hier_name);
    icache_size = ::mb::sysc::sdInitParameter<unsigned int>("icache_size", 32768, hier_name);
    cache_control = ::mb::sysc::sdInitParameter<const char*>("cache_control", "hardware", hier_name);
    dcache_control = ::mb::sysc::sdInitParameter<const char*>("dcache_control", "hardware", hier_name);
    icache_control = ::mb::sysc::sdInitParameter<const char*>("icache_control", "hardware", hier_name);
    control_page_address = ::mb::sysc::sdInitParameter<unsigned long long>("control_page_address", 0, hier_name);
    elf_image_file = ::mb::sysc::sdInitParameter<const char*>("elf_image_file", "", hier_name);
    gdbstub_port = ::mb::sysc::sdInitParameter<unsigned int>("gdbstub_port", 0, hier_name);
    instruction_latency = ::mb::sysc::sdInitParameter<sc_core::sc_time>("instruction_latency", clock, hier_name);
    instruction_energy = ::mb::sysc::sdInitParameter<mb::utl::energy>("instruction_energy", mb::utl::energy(0.3, mb::utl::NJ), hier_name);
    lt_synch_quantum = ::mb::sysc::sdInitParameter<sc_core::sc_time>("lt_synch_quantum", sc_core::sc_time(50, sc_core::SC_US), hier_name);
    high_vec = ::mb::sysc::sdInitParameter<bool>("high_vec", 0, hier_name);
    cluster_id = ::mb::sysc::sdInitParameter<unsigned int>("cluster_id", 0, hier_name);
    periph_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("periph_clock", sc_core::sc_time(20, sc_core::SC_NS), hier_name);
    periph_base = ::mb::sysc::sdInitParameter<unsigned int>("periph_base", 0x1F000000, hier_name);
    ::mb::sysc::sdPropagateParameters();
  }

  cpu_subsystem_pvt_param_defaults(const char* hier_name, sc_core::sc_time clock_init, sc_core::sc_time signal_clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int master0_outstanding_init, unsigned int master0_read_data_queue_size_init, unsigned int master0_write_data_queue_size_init, unsigned int master1_outstanding_init, unsigned int master1_read_data_queue_size_init, unsigned int master1_write_data_queue_size_init, unsigned int n_scu_reset_pipeline_length_init, unsigned int n_periph_reset_pipeline_length_init, unsigned int n_irq_0_pipeline_length_init, unsigned int n_fiq_0_pipeline_length_init, unsigned int n_irq_1_pipeline_length_init, unsigned int n_fiq_1_pipeline_length_init, unsigned int n_reset_0_pipeline_length_init, unsigned int n_wd_reset_0_pipeline_length_init, unsigned int n_reset_1_pipeline_length_init, unsigned int n_wd_reset_1_pipeline_length_init, unsigned int irq_0_pipeline_length_init, unsigned int irq_1_pipeline_length_init, unsigned int irq_2_pipeline_length_init, unsigned int irq_3_pipeline_length_init, unsigned int irq_4_pipeline_length_init, unsigned int irq_5_pipeline_length_init, unsigned int irq_6_pipeline_length_init, unsigned int irq_7_pipeline_length_init, unsigned int dcache_size_init, unsigned int icache_size_init, const char* cache_control_init, const char* dcache_control_init, const char* icache_control_init, unsigned long long control_page_address_init, const char* elf_image_file_init, unsigned int gdbstub_port_init, sc_core::sc_time instruction_latency_init, mb::utl::energy instruction_energy_init, sc_core::sc_time lt_synch_quantum_init, bool high_vec_init, unsigned int cluster_id_init, sc_core::sc_time periph_clock_init, unsigned int periph_base_init) {

    sc_core::sc_time clock;
    sc_core::sc_time signal_clock;
    sc_core::sc_time axi_clock;
    double nominal_voltage;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    unsigned int master0_outstanding;
    unsigned int master0_read_data_queue_size;
    unsigned int master0_write_data_queue_size;
    unsigned int master1_outstanding;
    unsigned int master1_read_data_queue_size;
    unsigned int master1_write_data_queue_size;
    unsigned int n_scu_reset_pipeline_length;
    unsigned int n_periph_reset_pipeline_length;
    unsigned int n_irq_0_pipeline_length;
    unsigned int n_fiq_0_pipeline_length;
    unsigned int n_irq_1_pipeline_length;
    unsigned int n_fiq_1_pipeline_length;
    unsigned int n_reset_0_pipeline_length;
    unsigned int n_wd_reset_0_pipeline_length;
    unsigned int n_reset_1_pipeline_length;
    unsigned int n_wd_reset_1_pipeline_length;
    unsigned int irq_0_pipeline_length;
    unsigned int irq_1_pipeline_length;
    unsigned int irq_2_pipeline_length;
    unsigned int irq_3_pipeline_length;
    unsigned int irq_4_pipeline_length;
    unsigned int irq_5_pipeline_length;
    unsigned int irq_6_pipeline_length;
    unsigned int irq_7_pipeline_length;
    unsigned int dcache_size;
    unsigned int icache_size;
    const char* cache_control;
    const char* dcache_control;
    const char* icache_control;
    unsigned long long control_page_address;
    const char* elf_image_file;
    unsigned int gdbstub_port;
    sc_core::sc_time instruction_latency;
    mb::utl::energy instruction_energy;
    sc_core::sc_time lt_synch_quantum;
    bool high_vec;
    unsigned int cluster_id;
    sc_core::sc_time periph_clock;
    unsigned int periph_base;
    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", clock_init, hier_name);
    signal_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("signal_clock", signal_clock_init, hier_name);
    axi_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("axi_clock", axi_clock_init, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", nominal_voltage_init, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", verbose_parameters_init, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", dmi_enabled_init, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", warning_level_init, hier_name);
    master0_outstanding = ::mb::sysc::sdInitParameter<unsigned int>("master0_outstanding", master0_outstanding_init, hier_name);
    master0_read_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master0_read_data_queue_size", master0_read_data_queue_size_init, hier_name);
    master0_write_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master0_write_data_queue_size", master0_write_data_queue_size_init, hier_name);
    master1_outstanding = ::mb::sysc::sdInitParameter<unsigned int>("master1_outstanding", master1_outstanding_init, hier_name);
    master1_read_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master1_read_data_queue_size", master1_read_data_queue_size_init, hier_name);
    master1_write_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master1_write_data_queue_size", master1_write_data_queue_size_init, hier_name);
    n_scu_reset_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_scu_reset_pipeline_length", n_scu_reset_pipeline_length_init, hier_name);
    n_periph_reset_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_periph_reset_pipeline_length", n_periph_reset_pipeline_length_init, hier_name);
    n_irq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_irq_0_pipeline_length", n_irq_0_pipeline_length_init, hier_name);
    n_fiq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_fiq_0_pipeline_length", n_fiq_0_pipeline_length_init, hier_name);
    n_irq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_irq_1_pipeline_length", n_irq_1_pipeline_length_init, hier_name);
    n_fiq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_fiq_1_pipeline_length", n_fiq_1_pipeline_length_init, hier_name);
    n_reset_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_reset_0_pipeline_length", n_reset_0_pipeline_length_init, hier_name);
    n_wd_reset_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_wd_reset_0_pipeline_length", n_wd_reset_0_pipeline_length_init, hier_name);
    n_reset_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_reset_1_pipeline_length", n_reset_1_pipeline_length_init, hier_name);
    n_wd_reset_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_wd_reset_1_pipeline_length", n_wd_reset_1_pipeline_length_init, hier_name);
    irq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_0_pipeline_length", irq_0_pipeline_length_init, hier_name);
    irq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_1_pipeline_length", irq_1_pipeline_length_init, hier_name);
    irq_2_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_2_pipeline_length", irq_2_pipeline_length_init, hier_name);
    irq_3_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_3_pipeline_length", irq_3_pipeline_length_init, hier_name);
    irq_4_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_4_pipeline_length", irq_4_pipeline_length_init, hier_name);
    irq_5_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_5_pipeline_length", irq_5_pipeline_length_init, hier_name);
    irq_6_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_6_pipeline_length", irq_6_pipeline_length_init, hier_name);
    irq_7_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_7_pipeline_length", irq_7_pipeline_length_init, hier_name);
    dcache_size = ::mb::sysc::sdInitParameter<unsigned int>("dcache_size", dcache_size_init, hier_name);
    icache_size = ::mb::sysc::sdInitParameter<unsigned int>("icache_size", icache_size_init, hier_name);
    cache_control = ::mb::sysc::sdInitParameter<const char*>("cache_control", cache_control_init, hier_name);
    dcache_control = ::mb::sysc::sdInitParameter<const char*>("dcache_control", dcache_control_init, hier_name);
    icache_control = ::mb::sysc::sdInitParameter<const char*>("icache_control", icache_control_init, hier_name);
    control_page_address = ::mb::sysc::sdInitParameter<unsigned long long>("control_page_address", control_page_address_init, hier_name);
    elf_image_file = ::mb::sysc::sdInitParameter<const char*>("elf_image_file", elf_image_file_init, hier_name);
    gdbstub_port = ::mb::sysc::sdInitParameter<unsigned int>("gdbstub_port", gdbstub_port_init, hier_name);
    instruction_latency = ::mb::sysc::sdInitParameter<sc_core::sc_time>("instruction_latency", instruction_latency_init, hier_name);
    instruction_energy = ::mb::sysc::sdInitParameter<mb::utl::energy>("instruction_energy", instruction_energy_init, hier_name);
    lt_synch_quantum = ::mb::sysc::sdInitParameter<sc_core::sc_time>("lt_synch_quantum", lt_synch_quantum_init, hier_name);
    high_vec = ::mb::sysc::sdInitParameter<bool>("high_vec", high_vec_init, hier_name);
    cluster_id = ::mb::sysc::sdInitParameter<unsigned int>("cluster_id", cluster_id_init, hier_name);
    periph_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("periph_clock", periph_clock_init, hier_name);
    periph_base = ::mb::sysc::sdInitParameter<unsigned int>("periph_base", periph_base_init, hier_name);

    ::mb::sysc::sdPropagateParameters();
    }

  cpu_subsystem_pvt_param_defaults(const char* hier_name, std::vector<std::pair<char*, unsigned int> > &change_parameters){

    sc_core::sc_time clock;
    sc_core::sc_time signal_clock;
    sc_core::sc_time axi_clock;
    double nominal_voltage;
    bool verbose_parameters;
    bool dmi_enabled;
    const char* warning_level;
    unsigned int master0_outstanding;
    unsigned int master0_read_data_queue_size;
    unsigned int master0_write_data_queue_size;
    unsigned int master1_outstanding;
    unsigned int master1_read_data_queue_size;
    unsigned int master1_write_data_queue_size;
    unsigned int n_scu_reset_pipeline_length;
    unsigned int n_periph_reset_pipeline_length;
    unsigned int n_irq_0_pipeline_length;
    unsigned int n_fiq_0_pipeline_length;
    unsigned int n_irq_1_pipeline_length;
    unsigned int n_fiq_1_pipeline_length;
    unsigned int n_reset_0_pipeline_length;
    unsigned int n_wd_reset_0_pipeline_length;
    unsigned int n_reset_1_pipeline_length;
    unsigned int n_wd_reset_1_pipeline_length;
    unsigned int irq_0_pipeline_length;
    unsigned int irq_1_pipeline_length;
    unsigned int irq_2_pipeline_length;
    unsigned int irq_3_pipeline_length;
    unsigned int irq_4_pipeline_length;
    unsigned int irq_5_pipeline_length;
    unsigned int irq_6_pipeline_length;
    unsigned int irq_7_pipeline_length;
    unsigned int dcache_size;
    unsigned int icache_size;
    const char* cache_control;
    const char* dcache_control;
    const char* icache_control;
    unsigned long long control_page_address;
    const char* elf_image_file;
    unsigned int gdbstub_port;
    sc_core::sc_time instruction_latency;
    mb::utl::energy instruction_energy;
    sc_core::sc_time lt_synch_quantum;
    bool high_vec;
    unsigned int cluster_id;
    sc_core::sc_time periph_clock;
    unsigned int periph_base;
    for (unsigned i =0; i<change_parameters.size(); i++){
      ::mb::sysc::sdInitParameter<unsigned int>(change_parameters[i].first, change_parameters[i].second, hier_name);
    }

    clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    signal_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("signal_clock", clock, hier_name);
    axi_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("axi_clock", clock, hier_name);
    nominal_voltage = ::mb::sysc::sdInitParameter<double>("nominal_voltage", 1, hier_name);
    verbose_parameters = ::mb::sysc::sdInitParameter<bool>("verbose_parameters", true, hier_name);
    dmi_enabled = ::mb::sysc::sdInitParameter<bool>("dmi_enabled", true, hier_name);
    warning_level = ::mb::sysc::sdInitParameter<const char*>("warning_level", "WARNING", hier_name);
    master0_outstanding = ::mb::sysc::sdInitParameter<unsigned int>("master0_outstanding", 1, hier_name);
    master0_read_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master0_read_data_queue_size", 0, hier_name);
    master0_write_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master0_write_data_queue_size", 0, hier_name);
    master1_outstanding = ::mb::sysc::sdInitParameter<unsigned int>("master1_outstanding", 1, hier_name);
    master1_read_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master1_read_data_queue_size", 0, hier_name);
    master1_write_data_queue_size = ::mb::sysc::sdInitParameter<unsigned int>("master1_write_data_queue_size", 0, hier_name);
    n_scu_reset_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_scu_reset_pipeline_length", 2, hier_name);
    n_periph_reset_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_periph_reset_pipeline_length", 2, hier_name);
    n_irq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_irq_0_pipeline_length", 2, hier_name);
    n_fiq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_fiq_0_pipeline_length", 2, hier_name);
    n_irq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_irq_1_pipeline_length", 2, hier_name);
    n_fiq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_fiq_1_pipeline_length", 2, hier_name);
    n_reset_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_reset_0_pipeline_length", 2, hier_name);
    n_wd_reset_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_wd_reset_0_pipeline_length", 2, hier_name);
    n_reset_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_reset_1_pipeline_length", 2, hier_name);
    n_wd_reset_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("n_wd_reset_1_pipeline_length", 2, hier_name);
    irq_0_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_0_pipeline_length", 2, hier_name);
    irq_1_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_1_pipeline_length", 2, hier_name);
    irq_2_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_2_pipeline_length", 2, hier_name);
    irq_3_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_3_pipeline_length", 2, hier_name);
    irq_4_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_4_pipeline_length", 2, hier_name);
    irq_5_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_5_pipeline_length", 2, hier_name);
    irq_6_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_6_pipeline_length", 2, hier_name);
    irq_7_pipeline_length = ::mb::sysc::sdInitParameter<unsigned int>("irq_7_pipeline_length", 2, hier_name);
    dcache_size = ::mb::sysc::sdInitParameter<unsigned int>("dcache_size", 32768, hier_name);
    icache_size = ::mb::sysc::sdInitParameter<unsigned int>("icache_size", 32768, hier_name);
    cache_control = ::mb::sysc::sdInitParameter<const char*>("cache_control", "hardware", hier_name);
    dcache_control = ::mb::sysc::sdInitParameter<const char*>("dcache_control", "hardware", hier_name);
    icache_control = ::mb::sysc::sdInitParameter<const char*>("icache_control", "hardware", hier_name);
    control_page_address = ::mb::sysc::sdInitParameter<unsigned long long>("control_page_address", 0, hier_name);
    elf_image_file = ::mb::sysc::sdInitParameter<const char*>("elf_image_file", "", hier_name);
    gdbstub_port = ::mb::sysc::sdInitParameter<unsigned int>("gdbstub_port", 0, hier_name);
    instruction_latency = ::mb::sysc::sdInitParameter<sc_core::sc_time>("instruction_latency", clock, hier_name);
    instruction_energy = ::mb::sysc::sdInitParameter<mb::utl::energy>("instruction_energy", mb::utl::energy(0.3, mb::utl::NJ), hier_name);
    lt_synch_quantum = ::mb::sysc::sdInitParameter<sc_core::sc_time>("lt_synch_quantum", sc_core::sc_time(50, sc_core::SC_US), hier_name);
    high_vec = ::mb::sysc::sdInitParameter<bool>("high_vec", 0, hier_name);
    cluster_id = ::mb::sysc::sdInitParameter<unsigned int>("cluster_id", 0, hier_name);
    periph_clock = ::mb::sysc::sdInitParameter<sc_core::sc_time>("periph_clock", sc_core::sc_time(20, sc_core::SC_NS), hier_name);
    periph_base = ::mb::sysc::sdInitParameter<unsigned int>("periph_base", 0x1F000000, hier_name);  

    ::mb::sysc::sdPropagateParameters();
  }
  
  //void set_clock (

};

class cpu_subsystem_pvt : public esl::sc_sim::PVTBaseModel, 
                          public mb::utl::cb_owner,
                          private cpu_subsystem_pvt_param_defaults {

 public:
  typedef cpu_subsystem_pvt self_type;

 public: 
  // Constructor
  cpu_subsystem_pvt(sc_core::sc_module_name module_name); 
  cpu_subsystem_pvt(sc_core::sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time signal_clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int master0_outstanding_init, unsigned int master0_read_data_queue_size_init, unsigned int master0_write_data_queue_size_init, unsigned int master1_outstanding_init, unsigned int master1_read_data_queue_size_init, unsigned int master1_write_data_queue_size_init, unsigned int n_scu_reset_pipeline_length_init, unsigned int n_periph_reset_pipeline_length_init, unsigned int n_irq_0_pipeline_length_init, unsigned int n_fiq_0_pipeline_length_init, unsigned int n_irq_1_pipeline_length_init, unsigned int n_fiq_1_pipeline_length_init, unsigned int n_reset_0_pipeline_length_init, unsigned int n_wd_reset_0_pipeline_length_init, unsigned int n_reset_1_pipeline_length_init, unsigned int n_wd_reset_1_pipeline_length_init, unsigned int irq_0_pipeline_length_init, unsigned int irq_1_pipeline_length_init, unsigned int irq_2_pipeline_length_init, unsigned int irq_3_pipeline_length_init, unsigned int irq_4_pipeline_length_init, unsigned int irq_5_pipeline_length_init, unsigned int irq_6_pipeline_length_init, unsigned int irq_7_pipeline_length_init, unsigned int dcache_size_init, unsigned int icache_size_init, const char* cache_control_init, const char* dcache_control_init, const char* icache_control_init, unsigned long long control_page_address_init, const char* elf_image_file_init, unsigned int gdbstub_port_init, sc_core::sc_time instruction_latency_init, mb::utl::energy instruction_energy_init, sc_core::sc_time lt_synch_quantum_init, bool high_vec_init, unsigned int cluster_id_init, sc_core::sc_time periph_clock_init, unsigned int periph_base_init); 
  cpu_subsystem_pvt(sc_core::sc_module_name module_name, std::vector<std::pair<char*, unsigned int> > &change_parameters);
  ~cpu_subsystem_pvt(); 

 
 public:
    //access the T instance
  inline cpu_subsystem_t_base* getT() const {
    return m_cpu_subsystem_t;
  }
  
  //access the PV instance
  inline cpu_subsystem_pv* getPV() const {
    return m_cpu_subsystem_pv;
  }

  virtual const SystemCBaseModel* getSystemCBaseModel() const {
    return getT();
  }
  virtual SystemCBaseModel* getSystemCBaseModel() {
    return getT();
  }
  

 private:
  void bind();
  

  void b_transport_outside_master0(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_master0(tlm::tlm_generic_payload& p);
  void b_transport_outside_master1(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  unsigned int transport_dbg_outside_master1(tlm::tlm_generic_payload& p);
  void b_transport_inside_n_scu_reset(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_periph_reset(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_irq_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_fiq_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_irq_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_fiq_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_reset_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_wd_reset_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_reset_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_n_wd_reset_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_2(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_3(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_4(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_5(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_6(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_inside_irq_7(tlm::tlm_generic_payload& p, sc_core::sc_time& t);
  void b_transport_outside_wd_reset_req_0(bool data);
  void b_transport_outside_wd_reset_req_1(bool data); 

 private:
  
  //T instance
  cpu_subsystem_t_base* m_cpu_subsystem_t;
  
  //PV instance
  cpu_subsystem_pv* m_cpu_subsystem_pv;

 public:
  // External ports

  typedef esl::sc_sim::pvt_initiator_socket<64, axi_protocol_types, 1, sc_core::SC_ONE_OR_MORE_BOUND> master0_type;
  master0_type master0;
  typedef esl::sc_sim::pvt_initiator_socket<64, axi_protocol_types, 1, sc_core::SC_ONE_OR_MORE_BOUND> master1_type;
  master1_type master1;
  esl::sc_sim::pvt_initiator_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> wd_reset_req_0;
  esl::sc_sim::pvt_initiator_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> wd_reset_req_1;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_scu_reset;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_periph_reset;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_irq_0;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_fiq_0;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_irq_1;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_fiq_1;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_reset_0;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_wd_reset_0;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_reset_1;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> n_wd_reset_1;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_0;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_1;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_2;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_3;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_4;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_5;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_6;
  esl::sc_sim::pvt_target_socket<1, tlm::tlm_base_protocol_types, 1, sc_core::SC_ZERO_OR_MORE_BOUND> irq_7;

 private:
  // PV connection ports

  typedef mb::tlm20::target_socket_cb<64> master0_entry_type;
  master0_entry_type master0_entry;
  typedef mb::tlm20::target_socket_cb<64> master1_entry_type;
  master1_entry_type master1_entry;    
  sc_core::sc_out<bool> n_scu_reset_entry; 
  sc_core::sc_out<bool> n_periph_reset_entry; 
  sc_core::sc_out<bool> n_irq_0_entry; 
  sc_core::sc_out<bool> n_fiq_0_entry; 
  sc_core::sc_out<bool> n_irq_1_entry; 
  sc_core::sc_out<bool> n_fiq_1_entry; 
  sc_core::sc_out<bool> n_reset_0_entry; 
  sc_core::sc_out<bool> n_wd_reset_0_entry; 
  sc_core::sc_out<bool> n_reset_1_entry; 
  sc_core::sc_out<bool> n_wd_reset_1_entry; 
  sc_core::sc_out<bool> irq_0_entry; 
  sc_core::sc_out<bool> irq_1_entry; 
  sc_core::sc_out<bool> irq_2_entry; 
  sc_core::sc_out<bool> irq_3_entry; 
  sc_core::sc_out<bool> irq_4_entry; 
  sc_core::sc_out<bool> irq_5_entry; 
  sc_core::sc_out<bool> irq_6_entry; 
  sc_core::sc_out<bool> irq_7_entry; 
  esl::sc_sim::signal_out<bool> wd_reset_req_0_entry;
  esl::sc_sim::signal_out<bool> wd_reset_req_1_entry;  

 public:
  sc_core::sc_time master0_time;

  sc_core::sc_time master1_time;


 private:

  struct master0_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    master0_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.master0.nb_transport_fw((axi_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.master0;
    }
  };
  friend struct master0_nb_connector;
  master0_nb_connector m_master0_nb_connector;

  struct master1_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    master1_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.master1.nb_transport_fw((axi_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.master1;
    }
  };
  friend struct master1_nb_connector;
  master1_nb_connector m_master1_nb_connector;

  struct wd_reset_req_0_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    wd_reset_req_0_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.wd_reset_req_0.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.wd_reset_req_0;
    }
  };
  friend struct wd_reset_req_0_nb_connector;
  wd_reset_req_0_nb_connector m_wd_reset_req_0_nb_connector;

  struct wd_reset_req_1_nb_connector : public tlm::tlm_fw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    wd_reset_req_1_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_fw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.wd_reset_req_1.nb_transport_fw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.wd_reset_req_1;
    }
  };
  friend struct wd_reset_req_1_nb_connector;
  wd_reset_req_1_nb_connector m_wd_reset_req_1_nb_connector;



  struct n_scu_reset_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_scu_reset_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_scu_reset.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_scu_reset;
    }
  };
  friend struct n_scu_reset_nb_connector;
  n_scu_reset_nb_connector m_n_scu_reset_nb_connector;

  struct n_periph_reset_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_periph_reset_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_periph_reset.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_periph_reset;
    }
  };
  friend struct n_periph_reset_nb_connector;
  n_periph_reset_nb_connector m_n_periph_reset_nb_connector;

  struct n_irq_0_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_irq_0_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_irq_0.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_irq_0;
    }
  };
  friend struct n_irq_0_nb_connector;
  n_irq_0_nb_connector m_n_irq_0_nb_connector;

  struct n_fiq_0_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_fiq_0_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_fiq_0.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_fiq_0;
    }
  };
  friend struct n_fiq_0_nb_connector;
  n_fiq_0_nb_connector m_n_fiq_0_nb_connector;

  struct n_irq_1_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_irq_1_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_irq_1.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_irq_1;
    }
  };
  friend struct n_irq_1_nb_connector;
  n_irq_1_nb_connector m_n_irq_1_nb_connector;

  struct n_fiq_1_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_fiq_1_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_fiq_1.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_fiq_1;
    }
  };
  friend struct n_fiq_1_nb_connector;
  n_fiq_1_nb_connector m_n_fiq_1_nb_connector;

  struct n_reset_0_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_reset_0_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_reset_0.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_reset_0;
    }
  };
  friend struct n_reset_0_nb_connector;
  n_reset_0_nb_connector m_n_reset_0_nb_connector;

  struct n_wd_reset_0_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_wd_reset_0_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_wd_reset_0.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_wd_reset_0;
    }
  };
  friend struct n_wd_reset_0_nb_connector;
  n_wd_reset_0_nb_connector m_n_wd_reset_0_nb_connector;

  struct n_reset_1_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_reset_1_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_reset_1.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_reset_1;
    }
  };
  friend struct n_reset_1_nb_connector;
  n_reset_1_nb_connector m_n_reset_1_nb_connector;

  struct n_wd_reset_1_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    n_wd_reset_1_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.n_wd_reset_1.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.n_wd_reset_1;
    }
  };
  friend struct n_wd_reset_1_nb_connector;
  n_wd_reset_1_nb_connector m_n_wd_reset_1_nb_connector;

  struct irq_0_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_0_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_0.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_0;
    }
  };
  friend struct irq_0_nb_connector;
  irq_0_nb_connector m_irq_0_nb_connector;

  struct irq_1_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_1_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_1.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_1;
    }
  };
  friend struct irq_1_nb_connector;
  irq_1_nb_connector m_irq_1_nb_connector;

  struct irq_2_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_2_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_2.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_2;
    }
  };
  friend struct irq_2_nb_connector;
  irq_2_nb_connector m_irq_2_nb_connector;

  struct irq_3_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_3_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_3.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_3;
    }
  };
  friend struct irq_3_nb_connector;
  irq_3_nb_connector m_irq_3_nb_connector;

  struct irq_4_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_4_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_4.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_4;
    }
  };
  friend struct irq_4_nb_connector;
  irq_4_nb_connector m_irq_4_nb_connector;

  struct irq_5_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_5_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_5.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_5;
    }
  };
  friend struct irq_5_nb_connector;
  irq_5_nb_connector m_irq_5_nb_connector;

  struct irq_6_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_6_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_6.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_6;
    }
  };
  friend struct irq_6_nb_connector;
  irq_6_nb_connector m_irq_6_nb_connector;

  struct irq_7_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<>, public ::mb::tlm20::socket_tracer_holder {
    cpu_subsystem_pvt& m_owner;
    irq_7_nb_connector(cpu_subsystem_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.irq_7.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
    virtual ::mb::tlm20::socket_tracer *get_socket_tracer() {
      return &m_owner.irq_7;
    }
  };
  friend struct irq_7_nb_connector;
  irq_7_nb_connector m_irq_7_nb_connector;

  

  tlm::tlm_sync_enum receive_nb_transport_master0(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                       sc_core::sc_time& t) {
    return getT()->receive_nb_transport(0, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_master1(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                       sc_core::sc_time& t) {
    return getT()->receive_nb_transport(1, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_wd_reset_req_0(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                       sc_core::sc_time& t) {
    return getT()->receive_nb_transport(10, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_wd_reset_req_1(tlm::tlm_generic_payload& trans,
                                                       tlm::tlm_phase& phase,
                                                       sc_core::sc_time& t) {
    return getT()->receive_nb_transport(13, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_scu_reset(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(2, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_periph_reset(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(3, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_irq_0(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(4, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_fiq_0(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(5, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_irq_1(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(6, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_fiq_1(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(7, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_reset_0(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(8, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_wd_reset_0(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(9, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_reset_1(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(11, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_n_wd_reset_1(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(12, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_0(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(14, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_1(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(15, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_2(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(16, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_3(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(17, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_4(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(18, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_5(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(19, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_6(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(20, trans, phase, t);
  }
  tlm::tlm_sync_enum receive_nb_transport_irq_7(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(21, trans, phase, t);
  }

};



