
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The H264_DECODER_pv will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>


#include "H264_DECODER_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


H264_DECODER_pv_base::H264_DECODER_pv_base(sc_module_name& module_name) : 
  H264_DECODER_pv_base_mb_compatibility(module_name),
  H264_DECODER_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(master),
  VISTA_MB_PV_INIT_MEMBER(slave),
  VISTA_MB_PV_INIT_MEMBER(slave_memory),
  start("start", &slave_memory, ((0x0) / 8), ( (0) + (((0x0) % 8) << 3)), ( (31) + (((0x0) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  stop("stop", &slave_memory, ((0x4) / 8), ( (0) + (((0x4) % 8) << 3)), ( (31) + (((0x4) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  resume("resume", &slave_memory, ((0x8) / 8), ( (0) + (((0x8) % 8) << 3)), ( (31) + (((0x8) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  sw_reset("sw_reset", &slave_memory, ((0xC) / 8), ( (0) + (((0xC) % 8) << 3)), ( (31) + (((0xC) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  interrupt("interrupt", &slave_memory, ((0x10) / 8), ( (0) + (((0x10) % 8) << 3)), ( (31) + (((0x10) % 8) << 3)),  (32), mb::tlm20::READ_ACCESS),
  frame_done("frame_done", &slave_memory, ((0x14) / 8), ( (0) + (((0x14) % 8) << 3)), ( (31) + (((0x14) % 8) << 3)),  (32), mb::tlm20::READ_WRITE_ACCESS),
  frame_type("frame_type", &slave_memory, ((0x18) / 8), ( (0) + (((0x18) % 8) << 3)), ( (31) + (((0x18) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  bitstream_buffer_low("bitstream_buffer_low", &slave_memory, ((0x1C) / 8), ( (0) + (((0x1C) % 8) << 3)), ( (31) + (((0x1C) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  BASE_ADDR_Y("BASE_ADDR_Y", &slave_memory, ((0x20) / 8), ( (0) + (((0x20) % 8) << 3)), ( (31) + (((0x20) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  BASE_ADDR_U("BASE_ADDR_U", &slave_memory, ((0x24) / 8), ( (0) + (((0x24) % 8) << 3)), ( (31) + (((0x24) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  BASE_ADDR_V("BASE_ADDR_V", &slave_memory, ((0x28) / 8), ( (0) + (((0x28) % 8) << 3)), ( (31) + (((0x28) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS),
  BASE_BITSTREAM_ADDR("BASE_BITSTREAM_ADDR", &slave_memory, ((0x2C) / 8), ( (0) + (((0x2C) % 8) << 3)), ( (31) + (((0x2C) % 8) << 3)),  (32), mb::tlm20::WRITE_ACCESS) {


  slave_memory.setPortIndex("slave");
  payload_on_stack = 0;
  payload_for_token = 0;

  start.setResetValue(0);
  interrupt.setResetValue(0);
  frame_done.setResetValue(0);
  frame_type.setResetValue(0);
  bitstream_buffer_low.setResetValue(0);
  BASE_ADDR_Y.setResetValue(0);
  BASE_ADDR_U.setResetValue(0);
  BASE_ADDR_V.setResetValue(0);
  BASE_BITSTREAM_ADDR.setResetValue(0);
  stop.setResetValue(0);
  resume.setResetValue(0);
  sw_reset.setResetValue(0);
  VISTA_MB_PV_SET_SELF_TRANSPORT_DBG(start);
  VISTA_MB_PV_SET_SELF_TRANSPORT_DBG(stop);
  VISTA_MB_PV_SET_SELF_TRANSPORT_DBG(frame_done);
  VISTA_MB_PV_SET_SELF_WRITE_CB(start);
  VISTA_MB_PV_SET_SELF_WRITE_CB(stop);
  VISTA_MB_PV_SET_SELF_WRITE_CB(frame_done);
  VISTA_MB_PV_SET_SELF_READ_CB(frame_done);
  VISTA_MB_PV_SET_TARGET_GET_DMI_DELAY_CB(slave);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_MEMORY_DEFAULT_IF(slave);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(master);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(slave);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(master);

}

void H264_DECODER_pv_base::reset_model() {
  // reset all registers


  start.setResetValue(0);
  interrupt.setResetValue(0);
  frame_done.setResetValue(0);
  frame_type.setResetValue(0);
  bitstream_buffer_low.setResetValue(0);
  BASE_ADDR_Y.setResetValue(0);
  BASE_ADDR_U.setResetValue(0);
  BASE_ADDR_V.setResetValue(0);
  BASE_BITSTREAM_ADDR.setResetValue(0);
  stop.setResetValue(0);
  resume.setResetValue(0);
  sw_reset.setResetValue(0);
  
  // reset value for output signals

  // reset value for input signals

}

H264_DECODER_pv_base_parameters::H264_DECODER_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, axi_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mb_debug, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, call_to_default_if, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_outstanding, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_write_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master_outstanding, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master_write_data_queue_size, 0)
{
  if(verbose_parameters) print_parameters();
}

void H264_DECODER_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\taxi_clock = " << axi_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tmb_debug = " << mb_debug << "\n";
  std::cout << "\tcall_to_default_if = " << call_to_default_if << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tslave_pipeline_length = " << slave_pipeline_length << "\n";
  std::cout << "\tslave_outstanding = " << slave_outstanding << "\n";
  std::cout << "\tslave_read_data_queue_size = " << slave_read_data_queue_size << "\n";
  std::cout << "\tslave_write_data_queue_size = " << slave_write_data_queue_size << "\n";
  std::cout << "\tmaster_outstanding = " << master_outstanding << "\n";
  std::cout << "\tmaster_read_data_queue_size = " << master_read_data_queue_size << "\n";
  std::cout << "\tmaster_write_data_queue_size = " << master_write_data_queue_size << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}


void H264_DECODER_pv_base::end_of_elaboration() {
  BASE_TYPE::end_of_elaboration();
  slave_memory.bind_bw_direct_mem_if(slave[0]);
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your H264_DECODER model.
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>

#include "H264_DECODER_model.h"
#include "model_builder.h"

using namespace ::mb::utl::minmax;

H264_DECODER_machine_arch::H264_DECODER_machine_arch()
    : MachineArch(2, 12), 
    start(0x0), 
    stop(0x4), 
    resume(0x8), 
    sw_reset(0xC), 
    interrupt(0x10), 
    frame_done(0x14), 
    frame_type(0x18), 
    bitstream_buffer_low(0x1C), 
    BASE_ADDR_Y(0x20), 
    BASE_ADDR_U(0x24), 
    BASE_ADDR_V(0x28), 
    BASE_BITSTREAM_ADDR(0x2C) {
    sc_dt::uint64* values = m_values;
    frame_type.setValuePtr(values);
    start.setValuePtr(values);
    sw_reset.setValuePtr(values);
    stop.setValuePtr(values);
    BASE_ADDR_U.setValuePtr(values);
    bitstream_buffer_low.setValuePtr(values);
    BASE_ADDR_V.setValuePtr(values);
    BASE_ADDR_Y.setValuePtr(values);
    BASE_BITSTREAM_ADDR.setValuePtr(values);
    frame_done.setValuePtr(values);
    interrupt.setValuePtr(values);
    resume.setValuePtr(values);
    
    reset();
}

////////////////////////////////////////////////////////////////////
//   function for port: slave
////////////////////////////////////////////////////////////////////


//////
// functions for port: slave, transaction: WRITE
//////

void H264_DECODER_machine_arch::transaction_instance__slave__WRITE
  (
    sc_dt::uint64 _address,
    sc_dt::uint64 _size,
    sc_dt::uint64 _data, 
    bool has_been_error, 
    sc_dt::uint64 currentTime
  )
{
  if ( _address == start.getAddress()) { 
      start = _data &(0xffffffff);
  }
  if ( _address == stop.getAddress()) { 
      stop = _data &(0xffffffff);
  }
  if ( _address == resume.getAddress()) { 
      resume = _data &(0xffffffff);
  }
  if ( _address == sw_reset.getAddress()) { 
      sw_reset = _data &(0xffffffff);
  }
  if ( _address == interrupt.getAddress()) { 
      interrupt = _data &(0xffffffff);
  }
  if ( _address == frame_done.getAddress()) { 
      frame_done = _data &(0xffffffff);
  }
  if ( _address == frame_type.getAddress()) { 
      frame_type = _data &(0xffffffff);
  }
  if ( _address == bitstream_buffer_low.getAddress()) { 
      bitstream_buffer_low = _data &(0xffffffff);
  }
  if ( _address == BASE_ADDR_Y.getAddress()) { 
      BASE_ADDR_Y = _data &(0xffffffff);
  }
  if ( _address == BASE_ADDR_U.getAddress()) { 
      BASE_ADDR_U = _data &(0xffffffff);
  }
  if ( _address == BASE_ADDR_V.getAddress()) { 
      BASE_ADDR_V = _data &(0xffffffff);
  }
  if ( _address == BASE_BITSTREAM_ADDR.getAddress()) { 
      BASE_BITSTREAM_ADDR = _data &(0xffffffff);
  }
}

//////
// functions for port: slave, transaction: READ
//////

void H264_DECODER_machine_arch::transaction_instance__slave__READ
  (
    sc_dt::uint64 _address,
    sc_dt::uint64 _size,
    sc_dt::uint64 _data, 
    bool has_been_error, 
    sc_dt::uint64 currentTime
  )
{
  
}

////////////////////////////////////////////////////////////////////
//   function for port: master
////////////////////////////////////////////////////////////////////


//////
// functions for port: master, transaction: WRITE
//////

void H264_DECODER_machine_arch::transaction_instance__master__WRITE
  (
    sc_dt::uint64 _address,
    sc_dt::uint64 _size,
    sc_dt::uint64 _data, 
    bool has_been_error, 
    sc_dt::uint64 currentTime
  )
{
  
}

//////
// functions for port: master, transaction: READ
//////

void H264_DECODER_machine_arch::transaction_instance__master__READ
  (
    sc_dt::uint64 _address,
    sc_dt::uint64 _size,
    sc_dt::uint64 _data, 
    bool has_been_error, 
    sc_dt::uint64 currentTime
  )
{
  
}

void H264_DECODER_machine_arch::startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime) {
  switch(portIndex) {
    case(0) : break;
    case(1) : break;
    default: break;
  }
}
VariableBase* H264_DECODER_machine_arch::getVariableBasePtrByName(const char* name) {
  return NULL;
}
Register* H264_DECODER_machine_arch::getRegisterByName(const char* name) {
  if (!strcmp(name, "frame_type")) {
    return &frame_type;
  }
  if (!strcmp(name, "start")) {
    return &start;
  }
  if (!strcmp(name, "sw_reset")) {
    return &sw_reset;
  }
  if (!strcmp(name, "stop")) {
    return &stop;
  }
  if (!strcmp(name, "BASE_ADDR_U")) {
    return &BASE_ADDR_U;
  }
  if (!strcmp(name, "bitstream_buffer_low")) {
    return &bitstream_buffer_low;
  }
  if (!strcmp(name, "BASE_ADDR_V")) {
    return &BASE_ADDR_V;
  }
  if (!strcmp(name, "BASE_ADDR_Y")) {
    return &BASE_ADDR_Y;
  }
  if (!strcmp(name, "BASE_BITSTREAM_ADDR")) {
    return &BASE_BITSTREAM_ADDR;
  }
  if (!strcmp(name, "frame_done")) {
    return &frame_done;
  }
  if (!strcmp(name, "interrupt")) {
    return &interrupt;
  }
  if (!strcmp(name, "resume")) {
    return &resume;
  }
  return 0;
}
void H264_DECODER_machine_arch::reset() { 
    MachineArch::reset();
}
bool H264_DECODER_machine_arch::getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end) {
    switch(portIndex) {
        case(0) : begin = min(12, (sc_dt::uint64)(0x0), (sc_dt::uint64)(0x4), (sc_dt::uint64)(0x8), (sc_dt::uint64)(0xC), (sc_dt::uint64)(0x10), (sc_dt::uint64)(0x14), (sc_dt::uint64)(0x18), (sc_dt::uint64)(0x1C), (sc_dt::uint64)(0x20), (sc_dt::uint64)(0x24), (sc_dt::uint64)(0x28), (sc_dt::uint64)(0x2C));
            end = max(12, (sc_dt::uint64)(0x0 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x4 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x8 + ((64 + 7) >> 3)), (sc_dt::uint64)(0xC + ((64 + 7) >> 3)), (sc_dt::uint64)(0x10 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x14 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x18 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x1C + ((64 + 7) >> 3)), (sc_dt::uint64)(0x20 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x24 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x28 + ((64 + 7) >> 3)), (sc_dt::uint64)(0x2C + ((64 + 7) >> 3)));
            return true;
        case(1) :   return false;
        default: break;
    }
    return false; 
}
void H264_DECODER_machine_arch::callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime) {
    switch(portIndex) {
        case(0) : { //port: slave
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(1) : { //port: master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        default: break;
    }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The H264_DECODER_t will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>




#include "H264_DECODER_model.h"
#include <math.h>
#include <stdlib.h>

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;


void H264_DECODER_t_base::schedule_axi_READ
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long ARADDR, long* RDATA, long ARSIZE, long block_size, long ARBURST, long ARLEN, long ARLOCK) {
  sc_dt::uint64 local_address = 0;
  local_address = ARADDR,
  scheduleGenericTransaction(port_index,
                             0,
                             local_address,
                             (unsigned char*)RDATA,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

void H264_DECODER_t_base::schedule_axi_WRITE
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long AWADDR, long* WDATA, long AWSIZE, long block_size, long AWBURST, long AWLEN, long AWLOCK) {
  sc_dt::uint64 local_address = 0;
  local_address = AWADDR,
  scheduleGenericTransaction(port_index,
                             1,
                             local_address,
                             (unsigned char*)WDATA,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}



void H264_DECODER_t_base::start_transaction_axi_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           1,
                                           startTime);
  
  this->accept_axi_READ
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5], 
     parameters[6], 
     parameters[7]);
}

void H264_DECODER_t_base::end_transaction_axi_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          1, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_axi_READ
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5],
     parameters[6],
     parameters[7]);
}
void H264_DECODER_t_base::start_transaction_axi_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           0,
                                           startTime);
  
  this->accept_axi_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5], 
     parameters[6], 
     parameters[7]);
}

void H264_DECODER_t_base::end_transaction_axi_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          0, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_axi_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5],
     parameters[6],
     parameters[7]);
}

H264_DECODER_t_base::TransactionCallbackFunctionPointer H264_DECODER_t_base::getTransactionCallback(unsigned callbackIndex) {
  static TransactionCallbackFunctionPointer funcArray[] = {
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::start_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::start_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::start_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::start_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::end_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::end_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::end_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&H264_DECODER_t_base::end_transaction_axi_WRITE),
    0
  };
  if(callbackIndex >= sizeof(funcArray) / sizeof(*funcArray) - 1)
    return 0;
  return funcArray[callbackIndex];
}

config::real80 H264_DECODER_t_base::get_state_power() { 
  config::real80 power_value = 0;

  

  return power_value;
}

H264_DECODER_t_base::H264_DECODER_t_base(sc_module_name& module_name, long simulation) :
  papoulis::SystemCBaseModel(module_name),
  m_machineArch(new H264_DECODER_machine_arch()),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(axi_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(mb_debug, false),
  SD_INITIALIZE_PARAMETER(call_to_default_if, false),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(slave_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(slave_outstanding, 1),
  SD_INITIALIZE_PARAMETER(slave_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER(slave_write_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER(master_outstanding, 1),
  SD_INITIALIZE_PARAMETER(master_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER(master_write_data_queue_size, 0),
  m_simulation(simulation),
  start("start", this),
  stop("stop", this),
  resume("resume", this),
  sw_reset("sw_reset", this),
  interrupt("interrupt", this),
  frame_done("frame_done", this),
  frame_type("frame_type", this),
  bitstream_buffer_low("bitstream_buffer_low", this),
  BASE_ADDR_Y("BASE_ADDR_Y", this),
  BASE_ADDR_U("BASE_ADDR_U", this),
  BASE_ADDR_V("BASE_ADDR_V", this),
  BASE_BITSTREAM_ADDR("BASE_BITSTREAM_ADDR", this)
{
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  fix_clock_parameter(axi_clock, "axi_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[slave].port_name = "slave";
  separate_read_channel = true;
  port_descriptions[slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[slave].is_read_write_address_channel = 0;
  
  port_descriptions[slave].is_master_port = 0;
  port_descriptions[slave].is_signal_port = 0;
  port_descriptions[slave].port_width = ((64 + 7) >> 3);
  port_descriptions[slave].port_width_in_bits = 64;
  port_descriptions[slave].protocol_name = "axi";
  port_descriptions[slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[slave].ipxactBusDef.name = "AXI";
  port_descriptions[slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[slave].port_must_bind = 1;
  port_descriptions[slave].params_count = 8;
  if (slave_outstanding == 0) {
    slave_outstanding = 1;
    printf("WARNING: in \"%s\" the \"slave_outstanding\" parameter is 0, a default value of 1 is used\n", name());
  }
  port_descriptions[slave].pending = slave_outstanding;
  port_descriptions[slave].read_data_queue_size = slave_read_data_queue_size;
  port_descriptions[slave].write_data_queue_size = slave_write_data_queue_size;
  port_descriptions[slave].clock = axi_clock;
  m_machineArch->configureClock(slave, mb::sysc::sc_time_to_ps(axi_clock));
  port_descriptions[slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);

  fix_clock_parameter(axi_clock, "axi_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[master].port_name = "master";
  separate_read_channel = true;
  port_descriptions[master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[master].is_read_write_address_channel = 0;
  
  port_descriptions[master].is_master_port = 1;
  port_descriptions[master].is_signal_port = 0;
  port_descriptions[master].port_width = ((64 + 7) >> 3);
  port_descriptions[master].port_width_in_bits = 64;
  port_descriptions[master].protocol_name = "axi";
  port_descriptions[master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[master].ipxactBusDef.library = "AMBA3";
  port_descriptions[master].ipxactBusDef.name = "AXI";
  port_descriptions[master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[master].ipxactAbstrDef.version = "1.0";
  port_descriptions[master].port_must_bind = 1;
  port_descriptions[master].params_count = 8;
  if (master_outstanding == 0) {
    master_outstanding = 1;
    printf("WARNING: in \"%s\" the \"master_outstanding\" parameter is 0, a default value of 1 is used\n", name());
  }
  port_descriptions[master].pending = master_outstanding;
  port_descriptions[master].read_data_queue_size = master_read_data_queue_size;
  port_descriptions[master].write_data_queue_size = master_write_data_queue_size;
  port_descriptions[master].clock = axi_clock;
  m_machineArch->configureClock(master, mb::sysc::sc_time_to_ps(axi_clock));
  port_descriptions[master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);


  port_descriptions[slave].default_read_transaction_name = "READ";
  port_descriptions[master].default_read_transaction_name = "READ";
  port_descriptions[slave].default_write_transaction_name = "WRITE";
  port_descriptions[master].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);

  bool isCpu = false;
  
  esl::tlm_sim::UserRunningModel* userRunningModel = Papoulis_CreateUserRunningModel(name(),
                                                                                     0,
                                                                                     this,
                                                                                     simulation,
                                                                                     false,
                                                                                     isCpu);
  setUserRunningModel(userRunningModel, isCpu);
  set_nominal_voltage(nominal_voltage);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("axi_clock", "sc_core::sc_time", sdGetParameterAsConstString("axi_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("mb_debug", "bool", sdGetParameterAsConstString("mb_debug"));
  registerParameter("call_to_default_if", "bool", sdGetParameterAsConstString("call_to_default_if"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("slave_pipeline_length", "unsigned int", sdGetParameterAsConstString("slave_pipeline_length"));
  registerParameter("slave_outstanding", "unsigned int", sdGetParameterAsConstString("slave_outstanding"));
  registerParameter("slave_read_data_queue_size", "unsigned int", sdGetParameterAsConstString("slave_read_data_queue_size"));
  registerParameter("slave_write_data_queue_size", "unsigned int", sdGetParameterAsConstString("slave_write_data_queue_size"));
  registerParameter("master_outstanding", "unsigned int", sdGetParameterAsConstString("master_outstanding"));
  registerParameter("master_read_data_queue_size", "unsigned int", sdGetParameterAsConstString("master_read_data_queue_size"));
  registerParameter("master_write_data_queue_size", "unsigned int", sdGetParameterAsConstString("master_write_data_queue_size"));
  set_sync_all(0); 
  set_sync_all(0);
  
  
  
  unsigned sequential_policy_index = 0;
  sequential_policy* sequential_policy_handle = 0;
  user_sequential_policy_descriptions[sequential_policy_index].firstTransaction = "slave";
  user_sequential_policy_descriptions[sequential_policy_index].secondTransaction = "master";
  user_sequential_policy_descriptions[sequential_policy_index].setLatency(4000);
  user_sequential_policy_descriptions[sequential_policy_index].syncMode = mb::tlm20::NO_SYNC;
  sequential_policy_handle = new sequential_policy(userRunningModel, user_sequential_policy_descriptions[sequential_policy_index]);
  m_sequential_vector.push_back(sequential_policy_handle);
  sequential_policy_handle->set_power(10);
  sequential_policy_index++;
  set_user_sequential_policies(user_sequential_policy_count, user_sequential_policy_descriptions);
  
  

  
  

  delay_policy* delay_policy_handle = 0;

  delay_policy_handle = new delay_policy(userRunningModel,
                                         "slave",
                                         2,
                                         2,
                                         mb::tlm20::NO_SYNC);
  delay_policy_handle->set_power(5);
  m_delay_vector.push_back(delay_policy_handle);

  

  constant_global_power_policy* p = new constant_global_power_policy(userRunningModel);
  p->set_leakage_power(0.05);
  p->set_clock_tree_power(0.1);
  set_nominal_clock(1000000/100); /* in ps */ 
  update_coefficients();
  set_global_power_policy(p);
}

void H264_DECODER_t_base::update_sync_all() {
  set_sync_all(0);
  set_sync_all(0);
}

void H264_DECODER_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;


}

void H264_DECODER_t_base::update_sequential_parameters(esl::sc_sim::sequential_policy* handle) {
  if (m_sequential_vector.size() == 0)
    return;

  if (handle == m_sequential_vector[0]) {
    handle->setLatency(4000);
    handle->setSyncMode(mb::tlm20::NO_SYNC);
    handle->set_power(10);
    return;
  }
}

void H264_DECODER_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(2);
    handle->set_start_delay(2);
    handle->setSyncMode(mb::tlm20::NO_SYNC);
    handle->set_power(5);
    return;
  }
}

void H264_DECODER_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}

void H264_DECODER_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}

void H264_DECODER_t_base::update_state_power_parameters(esl::sc_sim::state_power_policy* handle) {
  if (m_state_power_vector.size() == 0)
    return;

}

void H264_DECODER_t_base::update_global_power_parameters(esl::sc_sim::constant_global_power_policy* handle) {
  handle->set_leakage_power(0.05);
  handle->set_clock_tree_power(0.1);
  return;  
}

bool H264_DECODER_t_base::triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans) {
  mb::utl::Segment<uint64_t> transactionRange(trans.get_address(), trans.get_address() + trans.get_data_length());

  {
    if (0 == portIndex) {
      mb::utl::Segment<uint64_t> current((1 + ((0x0 % 8) << 3)), (1 + ((0x0 % 8) << 3)));
      mb::utl::Segment<uint64_t> intersect = transactionRange.intersect(current);
      if (!intersect.empty())
        return true;
    }
  }
  {
    if (0 == portIndex) {
      mb::utl::Segment<uint64_t> current((1 + ((0x4 % 8) << 3)), (1 + ((0x4 % 8) << 3)));
      mb::utl::Segment<uint64_t> intersect = transactionRange.intersect(current);
      if (!intersect.empty())
        return true;
    }
  }
  {
    if (0 == portIndex) {
      mb::utl::Segment<uint64_t> current((1 + ((0x14 % 8) << 3)), (1 + ((0x14 % 8) << 3)));
      mb::utl::Segment<uint64_t> intersect = transactionRange.intersect(current);
      if (!intersect.empty())
        return true;
    }
  }
  return false;
}

bool H264_DECODER_t_base::portHasRegisters(unsigned portIndex) {
  switch (portIndex) {

    {
    case 0:
      return true;
    }
  }
  return false;
}


unsigned H264_DECODER_t_base::getPortCountForRegister(unsigned regIndex) {
  if (!strcmp(get_register_name(regIndex), "start"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "stop"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "resume"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "sw_reset"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "interrupt"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "frame_done"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "frame_type"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "bitstream_buffer_low"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "BASE_ADDR_Y"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "BASE_ADDR_U"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "BASE_ADDR_V"))
    return 1;
  if (!strcmp(get_register_name(regIndex), "BASE_BITSTREAM_ADDR"))
    return 1;
  return 0;
}

void H264_DECODER_t_base::getPortNamesForRegister(unsigned regIndex, const char **names) {
  long i = 0;
  if (!strcmp(get_register_name(regIndex), "start")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "stop")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "resume")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "sw_reset")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "interrupt")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "frame_done")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "frame_type")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "bitstream_buffer_low")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "BASE_ADDR_Y")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "BASE_ADDR_U")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "BASE_ADDR_V")) {
    names[i++] = "slave";
    return;
  }
  if (!strcmp(get_register_name(regIndex), "BASE_BITSTREAM_ADDR")) {
    names[i++] = "slave";
    return;
  }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for H264_DECODER.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>

#include "H264_DECODER_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "H264_DECODER_pv.h"




// Constructor
H264_DECODER_pvt::H264_DECODER_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    H264_DECODER_pvt_param_defaults(this->name()),
    master("master"),
    slave("slave"), 
    master_entry("unvisible_master_entry"),
    slave_entry("unvisible_slave_entry"),
    m_master_nb_connector(*this),
    m_slave_nb_connector(*this)

{


  m_H264_DECODER_t = H264_DECODER_t_base::create_t("T", 1);
  m_H264_DECODER_pv = new H264_DECODER_pv("PV");
  bind();
}  


H264_DECODER_pvt::H264_DECODER_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool mb_debug_init, bool call_to_default_if_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int slave_pipeline_length_init, unsigned int slave_outstanding_init, unsigned int slave_read_data_queue_size_init, unsigned int slave_write_data_queue_size_init, unsigned int master_outstanding_init, unsigned int master_read_data_queue_size_init, unsigned int master_write_data_queue_size_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  H264_DECODER_pvt_param_defaults(this->name(), clock_init, axi_clock_init, nominal_voltage_init, mb_debug_init, call_to_default_if_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, slave_pipeline_length_init, slave_outstanding_init, slave_read_data_queue_size_init, slave_write_data_queue_size_init, master_outstanding_init, master_read_data_queue_size_init, master_write_data_queue_size_init),
    master("master"),
    slave("slave"), 
    master_entry("unvisible_master_entry"),
    slave_entry("unvisible_slave_entry"),
    m_master_nb_connector(*this),
    m_slave_nb_connector(*this)
{


  m_H264_DECODER_t = H264_DECODER_t_base::create_t("T", 1);
  m_H264_DECODER_pv = new H264_DECODER_pv("PV");
  bind();
} 

H264_DECODER_pvt::H264_DECODER_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  H264_DECODER_pvt_param_defaults(this->name(), change_parameters),
    master("master"),
    slave("slave"), 
    master_entry("unvisible_master_entry"),
    slave_entry("unvisible_slave_entry"),
    m_master_nb_connector(*this),
    m_slave_nb_connector(*this)
{


  m_H264_DECODER_t = H264_DECODER_t_base::create_t("T", 1);
  m_H264_DECODER_pv = new H264_DECODER_pv("PV");
  bind();
} 

H264_DECODER_pvt::~H264_DECODER_pvt() {
  remove_pending_scenes();
  delete m_H264_DECODER_t; delete m_H264_DECODER_pv;
}




void H264_DECODER_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->master.bind(master_entry);
  slave_entry.bind(getPV()->slave);   

  /* set callbacks on external and entry ports */ 

  slave.b_transport_cb.set(&slave_entry, &slave_entry_type::b_transport);
  slave.transport_dbg_cb.set(&slave_entry, &slave_entry_type::transport_dbg);
  slave.get_direct_mem_ptr_cb.set(&slave_entry, &slave_entry_type::get_direct_mem_ptr);

  master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_master);
  master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_master);
  master_entry.get_direct_mem_ptr_cb.set(&master, &master_type::get_direct_mem_ptr);

  
  /* connect t non blocking callbacks */

  master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_master);
  getT()->set_port_cb(1, &m_master_nb_connector);

  slave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_slave);
  getT()->set_port_cb(0, &m_slave_nb_connector);

  slave_entry.invalidate_direct_mem_ptr_cb.set(&slave, &slave_type::invalidate_direct_mem_ptr);

  master.invalidate_direct_mem_ptr_cb.set(&master_entry, &master_entry_type::invalidate_direct_mem_ptr);

  /* check mb_event policies */
  m_H264_DECODER_t->check_mb_events();
}



void H264_DECODER_pvt::b_transport_outside_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  master.b_transport(p, t);
  
} 

unsigned int H264_DECODER_pvt::transport_dbg_outside_master(tlm::tlm_generic_payload& p)
{
  
  return master.transport_dbg(p);
  
}

