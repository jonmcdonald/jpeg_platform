
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the timing class for RST_CLK_CTRL.
//*
//* This is a template file: You may modify this file to implement the 
//* timing behavior of your component.
//* The functions below allows advance users to customize the timing behavior of your model.
//* 
//* Model Builder version: 3.0.2.beta1
//* Generated on: Nov. 17, 2010 10:01:22 AM, (user: sagihb)
//* Automatically merged on: Dec. 26, 2010 03:27:05 PM, (user: sagihb)
//* Automatically merged on: Dec. 26, 2010 03:27:23 PM, (user: sagihb)
//* Automatically merged on: Feb. 04, 2011 10:36:49 AM, (user: zamir)
//* Automatically merged on: Feb. 27, 2011 07:18:03 PM, (user: zamir)
//* Automatically merged on: Sep. 07, 2011 11:39:35 AM, (user: awinterg)
//* Automatically merged on: Feb. 22, 2012 07:00:37 PM, (user: zamir)
//*>


#pragma once

#include "RST_CLK_CTRL_model.h"
#include "model_builder.h"

class RST_CLK_CTRL_t : public RST_CLK_CTRL_t_base {

public:
  typedef RST_CLK_CTRL_t self_type;

public:  
  RST_CLK_CTRL_t(sc_core::sc_module_name module_name, long simulation);

  /* policies callbacks */

  // The following callback is called for a target port. Note that the wait_states, power and 
  // influence_time are already computed using a learned policy (if any) or your defined
  // delay and/or power policy.
  // If under certain conditions you want to overwrite the above values, you have to overload
  // this callback in your derived class.
  
  virtual void evaluate_delay_policy(mb::mb_delay_request& request) {}

  // The following callback is called for an initiator port. Note that the latency, power and 
  // influence_time are already computed using a learned policy (if any) or your defined
  // split and/or power policy.
  // If under certain conditions you want to overwrite the above values, you have to overload
  // this callback in your derived class.

  virtual void evaluate_split_policy(mb::mb_split_request& request) {}
  
  // The following function is called whenever a pipeline policy is detected on
  // the current initiator port transaction. If you want to overwrite the latency parameter, you
  // have to overload these functions in your derived class
  virtual void evaluate_pipeline_policy(mb::mb_request& cause_request, mb::mb_effect_request& effect_request) {}

  // The following function is called whenever a sequential policy is detected on
  // the current initiator port transaction. If you want to overwrite the latency parameter, you
  // have to overload these functions in your derived class
  virtual void evaluate_sequential_policy(mb::mb_request& cause_request, mb::mb_effect_request& effect_request) {}

protected:
  // The following callbacks are called whenever there is a transaction start or end in the port
  // If you want to add your own code (like updating the machine architecture object), 
  // you have to overload these functions.

  virtual void accept_apb_READ
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 PADDR,
     sc_dt::uint64 PRDATA,
     sc_dt::uint64 block_size) {}
  virtual void end_apb_READ
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 PADDR,
     sc_dt::uint64 PRDATA,
     sc_dt::uint64 block_size) {}

  virtual void accept_apb_WRITE
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 PADDR,
     sc_dt::uint64 PWDATA,
     sc_dt::uint64 block_size) {}
  virtual void end_apb_WRITE
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 PADDR,
     sc_dt::uint64 PWDATA,
     sc_dt::uint64 block_size) {}

  virtual void accept_signal_WRITE
    (long port_index,
     sc_dt::int64 time,
     long& burst_size,
     sc_dt::uint64 address,
     sc_dt::uint64 value_p,
     sc_dt::uint64 block_size) {}
  virtual void end_signal_WRITE
    (long port_index,
     sc_dt::uint64 time,
     long& burst_size,
     sc_dt::uint64 address,
     sc_dt::uint64 value_p,
     sc_dt::uint64 block_size) {}

};
