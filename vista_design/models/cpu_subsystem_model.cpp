
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The cpu_subsystem_pv will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>


#include "cpu_subsystem_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


cpu_subsystem_pv_base::cpu_subsystem_pv_base(sc_module_name& module_name) : 
  cpu_subsystem_pv_base_mb_compatibility(module_name),
  cpu_subsystem_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(master0),
  VISTA_MB_PV_INIT_MEMBER(master1),
  VISTA_MB_PV_INIT_MEMBER(wd_reset_req_0),
  VISTA_MB_PV_INIT_MEMBER(wd_reset_req_1),
  VISTA_MB_PV_INIT_MEMBER(n_scu_reset),
  VISTA_MB_PV_INIT_MEMBER(n_periph_reset),
  VISTA_MB_PV_INIT_MEMBER(n_irq_0),
  VISTA_MB_PV_INIT_MEMBER(n_fiq_0),
  VISTA_MB_PV_INIT_MEMBER(n_irq_1),
  VISTA_MB_PV_INIT_MEMBER(n_fiq_1),
  VISTA_MB_PV_INIT_MEMBER(n_reset_0),
  VISTA_MB_PV_INIT_MEMBER(n_wd_reset_0),
  VISTA_MB_PV_INIT_MEMBER(n_reset_1),
  VISTA_MB_PV_INIT_MEMBER(n_wd_reset_1),
  VISTA_MB_PV_INIT_MEMBER(irq_0),
  VISTA_MB_PV_INIT_MEMBER(irq_1),
  VISTA_MB_PV_INIT_MEMBER(irq_2),
  VISTA_MB_PV_INIT_MEMBER(irq_3),
  VISTA_MB_PV_INIT_MEMBER(irq_4),
  VISTA_MB_PV_INIT_MEMBER(irq_5),
  VISTA_MB_PV_INIT_MEMBER(irq_6),
  VISTA_MB_PV_INIT_MEMBER(irq_7) {


  payload_on_stack = 0;
  payload_for_token = 0;

  n_scu_reset.register_cb(this, &self::cb_signal_n_scu_reset);
  n_periph_reset.register_cb(this, &self::cb_signal_n_periph_reset);
  n_irq_0.register_cb(this, &self::cb_signal_n_irq_0);
  n_fiq_0.register_cb(this, &self::cb_signal_n_fiq_0);
  n_irq_1.register_cb(this, &self::cb_signal_n_irq_1);
  n_fiq_1.register_cb(this, &self::cb_signal_n_fiq_1);
  n_reset_0.register_cb(this, &self::cb_signal_n_reset_0);
  n_wd_reset_0.register_cb(this, &self::cb_signal_n_wd_reset_0);
  n_reset_1.register_cb(this, &self::cb_signal_n_reset_1);
  n_wd_reset_1.register_cb(this, &self::cb_signal_n_wd_reset_1);
  irq_0.register_cb(this, &self::cb_signal_irq_0);
  irq_1.register_cb(this, &self::cb_signal_irq_1);
  irq_2.register_cb(this, &self::cb_signal_irq_2);
  irq_3.register_cb(this, &self::cb_signal_irq_3);
  irq_4.register_cb(this, &self::cb_signal_irq_4);
  irq_5.register_cb(this, &self::cb_signal_irq_5);
  irq_6.register_cb(this, &self::cb_signal_irq_6);
  irq_7.register_cb(this, &self::cb_signal_irq_7);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(master0);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(master1);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(master0);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(master1);

}

void cpu_subsystem_pv_base::reset_model() {
  // reset all registers


  
  // reset value for output signals

  // reset value for input signals

}

cpu_subsystem_pv_base_parameters::cpu_subsystem_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, signal_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, axi_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master0_outstanding, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master0_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master0_write_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master1_outstanding, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master1_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, master1_write_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_scu_reset_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_periph_reset_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_irq_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_fiq_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_irq_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_fiq_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_reset_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_wd_reset_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_reset_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, n_wd_reset_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_2_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_3_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_4_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_5_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_6_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, irq_7_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dcache_size, 32768),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, icache_size, 32768),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, cache_control, "hardware"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dcache_control, "hardware"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, icache_control, "hardware"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, control_page_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, elf_image_file, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, gdbstub_port, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, instruction_latency, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, instruction_energy, mb::utl::energy(0.3, mb::utl::NJ)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lt_synch_quantum, sc_core::sc_time(50, sc_core::SC_US)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, high_vec, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, cluster_id, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, periph_clock, sc_core::sc_time(20, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, periph_base, 0x1F000000)
{
  if(verbose_parameters) print_parameters();
}

void cpu_subsystem_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\tsignal_clock = " << signal_clock << "\n";
  std::cout << "\taxi_clock = " << axi_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tmaster0_outstanding = " << master0_outstanding << "\n";
  std::cout << "\tmaster0_read_data_queue_size = " << master0_read_data_queue_size << "\n";
  std::cout << "\tmaster0_write_data_queue_size = " << master0_write_data_queue_size << "\n";
  std::cout << "\tmaster1_outstanding = " << master1_outstanding << "\n";
  std::cout << "\tmaster1_read_data_queue_size = " << master1_read_data_queue_size << "\n";
  std::cout << "\tmaster1_write_data_queue_size = " << master1_write_data_queue_size << "\n";
  std::cout << "\tn_scu_reset_pipeline_length = " << n_scu_reset_pipeline_length << "\n";
  std::cout << "\tn_periph_reset_pipeline_length = " << n_periph_reset_pipeline_length << "\n";
  std::cout << "\tn_irq_0_pipeline_length = " << n_irq_0_pipeline_length << "\n";
  std::cout << "\tn_fiq_0_pipeline_length = " << n_fiq_0_pipeline_length << "\n";
  std::cout << "\tn_irq_1_pipeline_length = " << n_irq_1_pipeline_length << "\n";
  std::cout << "\tn_fiq_1_pipeline_length = " << n_fiq_1_pipeline_length << "\n";
  std::cout << "\tn_reset_0_pipeline_length = " << n_reset_0_pipeline_length << "\n";
  std::cout << "\tn_wd_reset_0_pipeline_length = " << n_wd_reset_0_pipeline_length << "\n";
  std::cout << "\tn_reset_1_pipeline_length = " << n_reset_1_pipeline_length << "\n";
  std::cout << "\tn_wd_reset_1_pipeline_length = " << n_wd_reset_1_pipeline_length << "\n";
  std::cout << "\tirq_0_pipeline_length = " << irq_0_pipeline_length << "\n";
  std::cout << "\tirq_1_pipeline_length = " << irq_1_pipeline_length << "\n";
  std::cout << "\tirq_2_pipeline_length = " << irq_2_pipeline_length << "\n";
  std::cout << "\tirq_3_pipeline_length = " << irq_3_pipeline_length << "\n";
  std::cout << "\tirq_4_pipeline_length = " << irq_4_pipeline_length << "\n";
  std::cout << "\tirq_5_pipeline_length = " << irq_5_pipeline_length << "\n";
  std::cout << "\tirq_6_pipeline_length = " << irq_6_pipeline_length << "\n";
  std::cout << "\tirq_7_pipeline_length = " << irq_7_pipeline_length << "\n";
  std::cout << "\tdcache_size = " << dcache_size << "\n";
  std::cout << "\ticache_size = " << icache_size << "\n";
  std::cout << "\tcache_control = " << cache_control << "\n";
  std::cout << "\tdcache_control = " << dcache_control << "\n";
  std::cout << "\ticache_control = " << icache_control << "\n";
  std::cout << "\tcontrol_page_address = " << control_page_address << "\n";
  std::cout << "\telf_image_file = " << elf_image_file << "\n";
  std::cout << "\tgdbstub_port = " << gdbstub_port << "\n";
  std::cout << "\tinstruction_latency = " << instruction_latency << "\n";
  std::cout << "\tinstruction_energy = " << instruction_energy << "\n";
  std::cout << "\tlt_synch_quantum = " << lt_synch_quantum << "\n";
  std::cout << "\thigh_vec = " << high_vec << "\n";
  std::cout << "\tcluster_id = " << cluster_id << "\n";
  std::cout << "\tperiph_clock = " << periph_clock << "\n";
  std::cout << "\tperiph_base = " << periph_base << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your cpu_subsystem model.
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>

#include "cpu_subsystem_model.h"
#include "model_builder.h"

using namespace ::mb::utl::minmax;

cpu_subsystem_machine_arch::cpu_subsystem_machine_arch()
    : MachineArch(22, 0) {
        reset();
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: master0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: master0, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__master0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: master0, transaction: READ
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__master0__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: master1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: master1, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__master1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: master1, transaction: READ
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__master1__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_scu_reset
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_scu_reset, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_scu_reset__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_periph_reset
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_periph_reset, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_periph_reset__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_irq_0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_irq_0, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_irq_0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_fiq_0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_fiq_0, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_fiq_0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_irq_1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_irq_1, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_irq_1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_fiq_1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_fiq_1, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_fiq_1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_reset_0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_reset_0, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_reset_0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_wd_reset_0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_wd_reset_0, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_wd_reset_0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: wd_reset_req_0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: wd_reset_req_0, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__wd_reset_req_0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_reset_1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_reset_1, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_reset_1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: n_wd_reset_1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: n_wd_reset_1, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__n_wd_reset_1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: wd_reset_req_1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: wd_reset_req_1, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__wd_reset_req_1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_0, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_1, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_2
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_2, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_2__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_3
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_3, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_3__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_4
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_4, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_4__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_5
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_5, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_5__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_6
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_6, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_6__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: irq_7
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: irq_7, transaction: WRITE
    //////
    
    void cpu_subsystem_machine_arch::transaction_instance__irq_7__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }

void cpu_subsystem_machine_arch::startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime) {
  switch(portIndex) {
    case(0) : break;
    case(1) : break;
    case(2) : break;
    case(3) : break;
    case(4) : break;
    case(5) : break;
    case(6) : break;
    case(7) : break;
    case(8) : break;
    case(9) : break;
    case(10) : break;
    case(11) : break;
    case(12) : break;
    case(13) : break;
    case(14) : break;
    case(15) : break;
    case(16) : break;
    case(17) : break;
    case(18) : break;
    case(19) : break;
    case(20) : break;
    case(21) : break;
    default: break;
  }
}
VariableBase* cpu_subsystem_machine_arch::getVariableBasePtrByName(const char* name) {
  return NULL;
}
Register* cpu_subsystem_machine_arch::getRegisterByName(const char* name) {
  return 0;
}
void cpu_subsystem_machine_arch::reset() { 
    MachineArch::reset();
}
bool cpu_subsystem_machine_arch::getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end) {
    switch(portIndex) {
        case(0) :   return false;
        case(1) :   return false;
        case(2) :   return false;
        case(3) :   return false;
        case(4) :   return false;
        case(5) :   return false;
        case(6) :   return false;
        case(7) :   return false;
        case(8) :   return false;
        case(9) :   return false;
        case(10) :   return false;
        case(11) :   return false;
        case(12) :   return false;
        case(13) :   return false;
        case(14) :   return false;
        case(15) :   return false;
        case(16) :   return false;
        case(17) :   return false;
        case(18) :   return false;
        case(19) :   return false;
        case(20) :   return false;
        case(21) :   return false;
        default: break;
    }
    return false; 
}
void cpu_subsystem_machine_arch::callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime) {
    switch(portIndex) {
        case(0) : { //port: master0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__master0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__master0__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(1) : { //port: master1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__master1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__master1__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(2) : { //port: n_scu_reset
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_scu_reset__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(3) : { //port: n_periph_reset
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_periph_reset__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(4) : { //port: n_irq_0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_irq_0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(5) : { //port: n_fiq_0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_fiq_0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(6) : { //port: n_irq_1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_irq_1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(7) : { //port: n_fiq_1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_fiq_1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(8) : { //port: n_reset_0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_reset_0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(9) : { //port: n_wd_reset_0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_wd_reset_0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(10) : { //port: wd_reset_req_0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__wd_reset_req_0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(11) : { //port: n_reset_1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_reset_1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(12) : { //port: n_wd_reset_1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__n_wd_reset_1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(13) : { //port: wd_reset_req_1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__wd_reset_req_1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(14) : { //port: irq_0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(15) : { //port: irq_1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(16) : { //port: irq_2
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_2__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(17) : { //port: irq_3
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_3__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(18) : { //port: irq_4
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_4__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(19) : { //port: irq_5
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_5__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(20) : { //port: irq_6
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_6__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(21) : { //port: irq_7
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__irq_7__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        default: break;
    }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The cpu_subsystem_t will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>




#include "cpu_subsystem_model.h"
#include <math.h>
#include <stdlib.h>

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;


void cpu_subsystem_t_base::schedule_axi_READ
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long ARADDR, long* RDATA, long ARSIZE, long block_size, long ARBURST, long ARLEN, long ARLOCK) {
  sc_dt::uint64 local_address = 0;
  local_address = ARADDR,
  scheduleGenericTransaction(port_index,
                             0,
                             local_address,
                             (unsigned char*)RDATA,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

void cpu_subsystem_t_base::schedule_axi_WRITE
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long AWADDR, long* WDATA, long AWSIZE, long block_size, long AWBURST, long AWLEN, long AWLOCK) {
  sc_dt::uint64 local_address = 0;
  local_address = AWADDR,
  scheduleGenericTransaction(port_index,
                             1,
                             local_address,
                             (unsigned char*)WDATA,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

void cpu_subsystem_t_base::schedule_signal_WRITE
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long address, long* value_p, long block_size) {
  sc_dt::uint64 local_address = 0;
  local_address = address,
  scheduleGenericTransaction(port_index,
                             1,
                             local_address,
                             (unsigned char*)value_p,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}



void cpu_subsystem_t_base::start_transaction_axi_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           1,
                                           startTime);
  
  this->accept_axi_READ
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5], 
     parameters[6], 
     parameters[7]);
}

void cpu_subsystem_t_base::end_transaction_axi_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          1, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_axi_READ
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5],
     parameters[6],
     parameters[7]);
}
void cpu_subsystem_t_base::start_transaction_axi_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           0,
                                           startTime);
  
  this->accept_axi_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5], 
     parameters[6], 
     parameters[7]);
}

void cpu_subsystem_t_base::end_transaction_axi_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[1] = request->getAddress();
  parameters[2] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          0, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_axi_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5],
     parameters[6],
     parameters[7]);
}
void cpu_subsystem_t_base::start_transaction_signal_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           0,
                                           startTime);
  
  this->accept_signal_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2]);
}

void cpu_subsystem_t_base::end_transaction_signal_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          0, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_signal_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2]);
}

cpu_subsystem_t_base::TransactionCallbackFunctionPointer cpu_subsystem_t_base::getTransactionCallback(unsigned callbackIndex) {
  static TransactionCallbackFunctionPointer funcArray[] = {
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_axi_READ),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_axi_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&cpu_subsystem_t_base::end_transaction_signal_WRITE),
    0
  };
  if(callbackIndex >= sizeof(funcArray) / sizeof(*funcArray) - 1)
    return 0;
  return funcArray[callbackIndex];
}

config::real80 cpu_subsystem_t_base::get_state_power() { 
  config::real80 power_value = 0;

  

  return power_value;
}

cpu_subsystem_t_base::cpu_subsystem_t_base(sc_module_name& module_name, long simulation) :
  papoulis::SystemCBaseModel(module_name),
  m_machineArch(new cpu_subsystem_machine_arch()),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(signal_clock, clock),
  SD_INITIALIZE_PARAMETER(axi_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(master0_outstanding, 1),
  SD_INITIALIZE_PARAMETER(master0_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER(master0_write_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER(master1_outstanding, 1),
  SD_INITIALIZE_PARAMETER(master1_read_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER(master1_write_data_queue_size, 0),
  SD_INITIALIZE_PARAMETER(n_scu_reset_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_periph_reset_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_irq_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_fiq_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_irq_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_fiq_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_reset_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_wd_reset_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_reset_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(n_wd_reset_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_0_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_1_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_2_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_3_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_4_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_5_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_6_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(irq_7_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(dcache_size, 32768),
  SD_INITIALIZE_PARAMETER(icache_size, 32768),
  SD_INITIALIZE_PARAMETER(cache_control, "hardware"),
  SD_INITIALIZE_PARAMETER(dcache_control, "hardware"),
  SD_INITIALIZE_PARAMETER(icache_control, "hardware"),
  SD_INITIALIZE_PARAMETER(control_page_address, 0),
  SD_INITIALIZE_PARAMETER(elf_image_file, ""),
  SD_INITIALIZE_PARAMETER(gdbstub_port, 0),
  SD_INITIALIZE_PARAMETER(instruction_latency, clock),
  SD_INITIALIZE_PARAMETER(instruction_energy, mb::utl::energy(0.3, mb::utl::NJ)),
  SD_INITIALIZE_PARAMETER(lt_synch_quantum, sc_core::sc_time(50, sc_core::SC_US)),
  SD_INITIALIZE_PARAMETER(high_vec, 0),
  SD_INITIALIZE_PARAMETER(cluster_id, 0),
  SD_INITIALIZE_PARAMETER(periph_clock, sc_core::sc_time(20, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(periph_base, 0x1F000000),
  m_simulation(simulation)
{
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  fix_clock_parameter(axi_clock, "axi_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[master0].port_name = "master0";
  separate_read_channel = true;
  port_descriptions[master0].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[master0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[master0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[master0].is_read_write_address_channel = 0;
  
  port_descriptions[master0].is_master_port = 1;
  port_descriptions[master0].is_signal_port = 0;
  port_descriptions[master0].port_width = ((64 + 7) >> 3);
  port_descriptions[master0].port_width_in_bits = 64;
  port_descriptions[master0].protocol_name = "axi";
  port_descriptions[master0].ipxactBusDef.vendor = "amba.com";
  port_descriptions[master0].ipxactBusDef.library = "AMBA3";
  port_descriptions[master0].ipxactBusDef.name = "AXI";
  port_descriptions[master0].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[master0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[master0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[master0].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[master0].ipxactAbstrDef.version = "1.0";
  port_descriptions[master0].port_must_bind = 1;
  port_descriptions[master0].params_count = 8;
  if (master0_outstanding == 0) {
    master0_outstanding = 1;
    printf("WARNING: in \"%s\" the \"master0_outstanding\" parameter is 0, a default value of 1 is used\n", name());
  }
  port_descriptions[master0].pending = master0_outstanding;
  port_descriptions[master0].read_data_queue_size = master0_read_data_queue_size;
  port_descriptions[master0].write_data_queue_size = master0_write_data_queue_size;
  port_descriptions[master0].clock = axi_clock;
  m_machineArch->configureClock(master0, mb::sysc::sc_time_to_ps(axi_clock));
  port_descriptions[master0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[master0].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[master0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[master0].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[master0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[master0].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[master0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[master0].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);

  fix_clock_parameter(axi_clock, "axi_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[master1].port_name = "master1";
  separate_read_channel = true;
  port_descriptions[master1].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[master1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[master1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[master1].is_read_write_address_channel = 0;
  
  port_descriptions[master1].is_master_port = 1;
  port_descriptions[master1].is_signal_port = 0;
  port_descriptions[master1].port_width = ((64 + 7) >> 3);
  port_descriptions[master1].port_width_in_bits = 64;
  port_descriptions[master1].protocol_name = "axi";
  port_descriptions[master1].ipxactBusDef.vendor = "amba.com";
  port_descriptions[master1].ipxactBusDef.library = "AMBA3";
  port_descriptions[master1].ipxactBusDef.name = "AXI";
  port_descriptions[master1].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[master1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[master1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[master1].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[master1].ipxactAbstrDef.version = "1.0";
  port_descriptions[master1].port_must_bind = 1;
  port_descriptions[master1].params_count = 8;
  if (master1_outstanding == 0) {
    master1_outstanding = 1;
    printf("WARNING: in \"%s\" the \"master1_outstanding\" parameter is 0, a default value of 1 is used\n", name());
  }
  port_descriptions[master1].pending = master1_outstanding;
  port_descriptions[master1].read_data_queue_size = master1_read_data_queue_size;
  port_descriptions[master1].write_data_queue_size = master1_write_data_queue_size;
  port_descriptions[master1].clock = axi_clock;
  m_machineArch->configureClock(master1, mb::sysc::sc_time_to_ps(axi_clock));
  port_descriptions[master1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[master1].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[master1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[master1].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[master1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[master1].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[master1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[master1].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_scu_reset].port_name = "n_scu_reset";
  separate_write_channel = true;
  port_descriptions[n_scu_reset].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_scu_reset].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_scu_reset].is_read_write_address_channel = 0;
  
  port_descriptions[n_scu_reset].is_master_port = 0;
  port_descriptions[n_scu_reset].is_signal_port = 1;
  port_descriptions[n_scu_reset].port_width = ((1 + 7) >> 3);
  port_descriptions[n_scu_reset].port_width_in_bits = 1;
  port_descriptions[n_scu_reset].protocol_name = "signal";
  port_descriptions[n_scu_reset].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_scu_reset].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_scu_reset].ipxactBusDef.name = "signal";
  port_descriptions[n_scu_reset].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_scu_reset].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_scu_reset].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_scu_reset].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_scu_reset].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_scu_reset].port_must_bind = 0;
  port_descriptions[n_scu_reset].params_count = 3;
  port_descriptions[n_scu_reset].clock = signal_clock;
  m_machineArch->configureClock(n_scu_reset, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_scu_reset].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_scu_reset].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_periph_reset].port_name = "n_periph_reset";
  separate_write_channel = true;
  port_descriptions[n_periph_reset].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_periph_reset].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_periph_reset].is_read_write_address_channel = 0;
  
  port_descriptions[n_periph_reset].is_master_port = 0;
  port_descriptions[n_periph_reset].is_signal_port = 1;
  port_descriptions[n_periph_reset].port_width = ((1 + 7) >> 3);
  port_descriptions[n_periph_reset].port_width_in_bits = 1;
  port_descriptions[n_periph_reset].protocol_name = "signal";
  port_descriptions[n_periph_reset].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_periph_reset].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_periph_reset].ipxactBusDef.name = "signal";
  port_descriptions[n_periph_reset].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_periph_reset].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_periph_reset].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_periph_reset].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_periph_reset].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_periph_reset].port_must_bind = 0;
  port_descriptions[n_periph_reset].params_count = 3;
  port_descriptions[n_periph_reset].clock = signal_clock;
  m_machineArch->configureClock(n_periph_reset, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_periph_reset].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_periph_reset].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_irq_0].port_name = "n_irq_0";
  separate_write_channel = true;
  port_descriptions[n_irq_0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_irq_0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_irq_0].is_read_write_address_channel = 0;
  
  port_descriptions[n_irq_0].is_master_port = 0;
  port_descriptions[n_irq_0].is_signal_port = 1;
  port_descriptions[n_irq_0].port_width = ((1 + 7) >> 3);
  port_descriptions[n_irq_0].port_width_in_bits = 1;
  port_descriptions[n_irq_0].protocol_name = "signal";
  port_descriptions[n_irq_0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_irq_0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_irq_0].ipxactBusDef.name = "signal";
  port_descriptions[n_irq_0].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_irq_0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_irq_0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_irq_0].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_irq_0].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_irq_0].port_must_bind = 0;
  port_descriptions[n_irq_0].params_count = 3;
  port_descriptions[n_irq_0].clock = signal_clock;
  m_machineArch->configureClock(n_irq_0, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_irq_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_irq_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_fiq_0].port_name = "n_fiq_0";
  separate_write_channel = true;
  port_descriptions[n_fiq_0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_fiq_0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_fiq_0].is_read_write_address_channel = 0;
  
  port_descriptions[n_fiq_0].is_master_port = 0;
  port_descriptions[n_fiq_0].is_signal_port = 1;
  port_descriptions[n_fiq_0].port_width = ((1 + 7) >> 3);
  port_descriptions[n_fiq_0].port_width_in_bits = 1;
  port_descriptions[n_fiq_0].protocol_name = "signal";
  port_descriptions[n_fiq_0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_fiq_0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_fiq_0].ipxactBusDef.name = "signal";
  port_descriptions[n_fiq_0].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_fiq_0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_fiq_0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_fiq_0].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_fiq_0].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_fiq_0].port_must_bind = 0;
  port_descriptions[n_fiq_0].params_count = 3;
  port_descriptions[n_fiq_0].clock = signal_clock;
  m_machineArch->configureClock(n_fiq_0, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_fiq_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_fiq_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_irq_1].port_name = "n_irq_1";
  separate_write_channel = true;
  port_descriptions[n_irq_1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_irq_1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_irq_1].is_read_write_address_channel = 0;
  
  port_descriptions[n_irq_1].is_master_port = 0;
  port_descriptions[n_irq_1].is_signal_port = 1;
  port_descriptions[n_irq_1].port_width = ((1 + 7) >> 3);
  port_descriptions[n_irq_1].port_width_in_bits = 1;
  port_descriptions[n_irq_1].protocol_name = "signal";
  port_descriptions[n_irq_1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_irq_1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_irq_1].ipxactBusDef.name = "signal";
  port_descriptions[n_irq_1].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_irq_1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_irq_1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_irq_1].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_irq_1].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_irq_1].port_must_bind = 0;
  port_descriptions[n_irq_1].params_count = 3;
  port_descriptions[n_irq_1].clock = signal_clock;
  m_machineArch->configureClock(n_irq_1, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_irq_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_irq_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_fiq_1].port_name = "n_fiq_1";
  separate_write_channel = true;
  port_descriptions[n_fiq_1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_fiq_1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_fiq_1].is_read_write_address_channel = 0;
  
  port_descriptions[n_fiq_1].is_master_port = 0;
  port_descriptions[n_fiq_1].is_signal_port = 1;
  port_descriptions[n_fiq_1].port_width = ((1 + 7) >> 3);
  port_descriptions[n_fiq_1].port_width_in_bits = 1;
  port_descriptions[n_fiq_1].protocol_name = "signal";
  port_descriptions[n_fiq_1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_fiq_1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_fiq_1].ipxactBusDef.name = "signal";
  port_descriptions[n_fiq_1].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_fiq_1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_fiq_1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_fiq_1].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_fiq_1].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_fiq_1].port_must_bind = 0;
  port_descriptions[n_fiq_1].params_count = 3;
  port_descriptions[n_fiq_1].clock = signal_clock;
  m_machineArch->configureClock(n_fiq_1, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_fiq_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_fiq_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_reset_0].port_name = "n_reset_0";
  separate_write_channel = true;
  port_descriptions[n_reset_0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_reset_0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_reset_0].is_read_write_address_channel = 0;
  
  port_descriptions[n_reset_0].is_master_port = 0;
  port_descriptions[n_reset_0].is_signal_port = 1;
  port_descriptions[n_reset_0].port_width = ((1 + 7) >> 3);
  port_descriptions[n_reset_0].port_width_in_bits = 1;
  port_descriptions[n_reset_0].protocol_name = "signal";
  port_descriptions[n_reset_0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_reset_0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_reset_0].ipxactBusDef.name = "signal";
  port_descriptions[n_reset_0].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_reset_0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_reset_0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_reset_0].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_reset_0].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_reset_0].port_must_bind = 0;
  port_descriptions[n_reset_0].params_count = 3;
  port_descriptions[n_reset_0].clock = signal_clock;
  m_machineArch->configureClock(n_reset_0, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_reset_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_reset_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_wd_reset_0].port_name = "n_wd_reset_0";
  separate_write_channel = true;
  port_descriptions[n_wd_reset_0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_wd_reset_0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_wd_reset_0].is_read_write_address_channel = 0;
  
  port_descriptions[n_wd_reset_0].is_master_port = 0;
  port_descriptions[n_wd_reset_0].is_signal_port = 1;
  port_descriptions[n_wd_reset_0].port_width = ((1 + 7) >> 3);
  port_descriptions[n_wd_reset_0].port_width_in_bits = 1;
  port_descriptions[n_wd_reset_0].protocol_name = "signal";
  port_descriptions[n_wd_reset_0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_wd_reset_0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_wd_reset_0].ipxactBusDef.name = "signal";
  port_descriptions[n_wd_reset_0].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_wd_reset_0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_wd_reset_0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_wd_reset_0].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_wd_reset_0].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_wd_reset_0].port_must_bind = 0;
  port_descriptions[n_wd_reset_0].params_count = 3;
  port_descriptions[n_wd_reset_0].clock = signal_clock;
  m_machineArch->configureClock(n_wd_reset_0, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_wd_reset_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_wd_reset_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[wd_reset_req_0].port_name = "wd_reset_req_0";
  separate_write_channel = true;
  port_descriptions[wd_reset_req_0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[wd_reset_req_0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[wd_reset_req_0].is_read_write_address_channel = 0;
  
  port_descriptions[wd_reset_req_0].is_master_port = 1;
  port_descriptions[wd_reset_req_0].is_signal_port = 1;
  port_descriptions[wd_reset_req_0].port_width = ((1 + 7) >> 3);
  port_descriptions[wd_reset_req_0].port_width_in_bits = 1;
  port_descriptions[wd_reset_req_0].protocol_name = "signal";
  port_descriptions[wd_reset_req_0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[wd_reset_req_0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[wd_reset_req_0].ipxactBusDef.name = "signal";
  port_descriptions[wd_reset_req_0].ipxactBusDef.version = "1.0"; 
  port_descriptions[wd_reset_req_0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[wd_reset_req_0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[wd_reset_req_0].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[wd_reset_req_0].ipxactAbstrDef.version = "1.0";
  port_descriptions[wd_reset_req_0].port_must_bind = 0;
  port_descriptions[wd_reset_req_0].params_count = 3;
  port_descriptions[wd_reset_req_0].clock = signal_clock;
  m_machineArch->configureClock(wd_reset_req_0, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[wd_reset_req_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[wd_reset_req_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_reset_1].port_name = "n_reset_1";
  separate_write_channel = true;
  port_descriptions[n_reset_1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_reset_1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_reset_1].is_read_write_address_channel = 0;
  
  port_descriptions[n_reset_1].is_master_port = 0;
  port_descriptions[n_reset_1].is_signal_port = 1;
  port_descriptions[n_reset_1].port_width = ((1 + 7) >> 3);
  port_descriptions[n_reset_1].port_width_in_bits = 1;
  port_descriptions[n_reset_1].protocol_name = "signal";
  port_descriptions[n_reset_1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_reset_1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_reset_1].ipxactBusDef.name = "signal";
  port_descriptions[n_reset_1].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_reset_1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_reset_1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_reset_1].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_reset_1].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_reset_1].port_must_bind = 0;
  port_descriptions[n_reset_1].params_count = 3;
  port_descriptions[n_reset_1].clock = signal_clock;
  m_machineArch->configureClock(n_reset_1, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_reset_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_reset_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[n_wd_reset_1].port_name = "n_wd_reset_1";
  separate_write_channel = true;
  port_descriptions[n_wd_reset_1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[n_wd_reset_1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[n_wd_reset_1].is_read_write_address_channel = 0;
  
  port_descriptions[n_wd_reset_1].is_master_port = 0;
  port_descriptions[n_wd_reset_1].is_signal_port = 1;
  port_descriptions[n_wd_reset_1].port_width = ((1 + 7) >> 3);
  port_descriptions[n_wd_reset_1].port_width_in_bits = 1;
  port_descriptions[n_wd_reset_1].protocol_name = "signal";
  port_descriptions[n_wd_reset_1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[n_wd_reset_1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[n_wd_reset_1].ipxactBusDef.name = "signal";
  port_descriptions[n_wd_reset_1].ipxactBusDef.version = "1.0"; 
  port_descriptions[n_wd_reset_1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[n_wd_reset_1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[n_wd_reset_1].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[n_wd_reset_1].ipxactAbstrDef.version = "1.0";
  port_descriptions[n_wd_reset_1].port_must_bind = 0;
  port_descriptions[n_wd_reset_1].params_count = 3;
  port_descriptions[n_wd_reset_1].clock = signal_clock;
  m_machineArch->configureClock(n_wd_reset_1, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[n_wd_reset_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[n_wd_reset_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[wd_reset_req_1].port_name = "wd_reset_req_1";
  separate_write_channel = true;
  port_descriptions[wd_reset_req_1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[wd_reset_req_1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[wd_reset_req_1].is_read_write_address_channel = 0;
  
  port_descriptions[wd_reset_req_1].is_master_port = 1;
  port_descriptions[wd_reset_req_1].is_signal_port = 1;
  port_descriptions[wd_reset_req_1].port_width = ((1 + 7) >> 3);
  port_descriptions[wd_reset_req_1].port_width_in_bits = 1;
  port_descriptions[wd_reset_req_1].protocol_name = "signal";
  port_descriptions[wd_reset_req_1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[wd_reset_req_1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[wd_reset_req_1].ipxactBusDef.name = "signal";
  port_descriptions[wd_reset_req_1].ipxactBusDef.version = "1.0"; 
  port_descriptions[wd_reset_req_1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[wd_reset_req_1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[wd_reset_req_1].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[wd_reset_req_1].ipxactAbstrDef.version = "1.0";
  port_descriptions[wd_reset_req_1].port_must_bind = 0;
  port_descriptions[wd_reset_req_1].params_count = 3;
  port_descriptions[wd_reset_req_1].clock = signal_clock;
  m_machineArch->configureClock(wd_reset_req_1, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[wd_reset_req_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[wd_reset_req_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_0].port_name = "irq_0";
  separate_write_channel = true;
  port_descriptions[irq_0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_0].is_read_write_address_channel = 0;
  
  port_descriptions[irq_0].is_master_port = 0;
  port_descriptions[irq_0].is_signal_port = 1;
  port_descriptions[irq_0].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_0].port_width_in_bits = 1;
  port_descriptions[irq_0].protocol_name = "signal";
  port_descriptions[irq_0].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_0].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_0].ipxactBusDef.name = "signal";
  port_descriptions[irq_0].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_0].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_0].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_0].port_must_bind = 0;
  port_descriptions[irq_0].params_count = 3;
  port_descriptions[irq_0].clock = signal_clock;
  m_machineArch->configureClock(irq_0, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_1].port_name = "irq_1";
  separate_write_channel = true;
  port_descriptions[irq_1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_1].is_read_write_address_channel = 0;
  
  port_descriptions[irq_1].is_master_port = 0;
  port_descriptions[irq_1].is_signal_port = 1;
  port_descriptions[irq_1].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_1].port_width_in_bits = 1;
  port_descriptions[irq_1].protocol_name = "signal";
  port_descriptions[irq_1].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_1].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_1].ipxactBusDef.name = "signal";
  port_descriptions[irq_1].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_1].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_1].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_1].port_must_bind = 0;
  port_descriptions[irq_1].params_count = 3;
  port_descriptions[irq_1].clock = signal_clock;
  m_machineArch->configureClock(irq_1, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_2].port_name = "irq_2";
  separate_write_channel = true;
  port_descriptions[irq_2].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_2].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_2].is_read_write_address_channel = 0;
  
  port_descriptions[irq_2].is_master_port = 0;
  port_descriptions[irq_2].is_signal_port = 1;
  port_descriptions[irq_2].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_2].port_width_in_bits = 1;
  port_descriptions[irq_2].protocol_name = "signal";
  port_descriptions[irq_2].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_2].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_2].ipxactBusDef.name = "signal";
  port_descriptions[irq_2].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_2].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_2].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_2].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_2].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_2].port_must_bind = 0;
  port_descriptions[irq_2].params_count = 3;
  port_descriptions[irq_2].clock = signal_clock;
  m_machineArch->configureClock(irq_2, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_2].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_2].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_3].port_name = "irq_3";
  separate_write_channel = true;
  port_descriptions[irq_3].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_3].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_3].is_read_write_address_channel = 0;
  
  port_descriptions[irq_3].is_master_port = 0;
  port_descriptions[irq_3].is_signal_port = 1;
  port_descriptions[irq_3].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_3].port_width_in_bits = 1;
  port_descriptions[irq_3].protocol_name = "signal";
  port_descriptions[irq_3].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_3].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_3].ipxactBusDef.name = "signal";
  port_descriptions[irq_3].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_3].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_3].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_3].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_3].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_3].port_must_bind = 0;
  port_descriptions[irq_3].params_count = 3;
  port_descriptions[irq_3].clock = signal_clock;
  m_machineArch->configureClock(irq_3, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_3].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_3].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_4].port_name = "irq_4";
  separate_write_channel = true;
  port_descriptions[irq_4].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_4].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_4].is_read_write_address_channel = 0;
  
  port_descriptions[irq_4].is_master_port = 0;
  port_descriptions[irq_4].is_signal_port = 1;
  port_descriptions[irq_4].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_4].port_width_in_bits = 1;
  port_descriptions[irq_4].protocol_name = "signal";
  port_descriptions[irq_4].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_4].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_4].ipxactBusDef.name = "signal";
  port_descriptions[irq_4].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_4].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_4].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_4].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_4].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_4].port_must_bind = 0;
  port_descriptions[irq_4].params_count = 3;
  port_descriptions[irq_4].clock = signal_clock;
  m_machineArch->configureClock(irq_4, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_4].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_4].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_5].port_name = "irq_5";
  separate_write_channel = true;
  port_descriptions[irq_5].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_5].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_5].is_read_write_address_channel = 0;
  
  port_descriptions[irq_5].is_master_port = 0;
  port_descriptions[irq_5].is_signal_port = 1;
  port_descriptions[irq_5].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_5].port_width_in_bits = 1;
  port_descriptions[irq_5].protocol_name = "signal";
  port_descriptions[irq_5].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_5].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_5].ipxactBusDef.name = "signal";
  port_descriptions[irq_5].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_5].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_5].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_5].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_5].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_5].port_must_bind = 0;
  port_descriptions[irq_5].params_count = 3;
  port_descriptions[irq_5].clock = signal_clock;
  m_machineArch->configureClock(irq_5, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_5].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_5].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_6].port_name = "irq_6";
  separate_write_channel = true;
  port_descriptions[irq_6].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_6].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_6].is_read_write_address_channel = 0;
  
  port_descriptions[irq_6].is_master_port = 0;
  port_descriptions[irq_6].is_signal_port = 1;
  port_descriptions[irq_6].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_6].port_width_in_bits = 1;
  port_descriptions[irq_6].protocol_name = "signal";
  port_descriptions[irq_6].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_6].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_6].ipxactBusDef.name = "signal";
  port_descriptions[irq_6].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_6].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_6].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_6].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_6].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_6].port_must_bind = 0;
  port_descriptions[irq_6].params_count = 3;
  port_descriptions[irq_6].clock = signal_clock;
  m_machineArch->configureClock(irq_6, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_6].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_6].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[irq_7].port_name = "irq_7";
  separate_write_channel = true;
  port_descriptions[irq_7].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[irq_7].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[irq_7].is_read_write_address_channel = 0;
  
  port_descriptions[irq_7].is_master_port = 0;
  port_descriptions[irq_7].is_signal_port = 1;
  port_descriptions[irq_7].port_width = ((1 + 7) >> 3);
  port_descriptions[irq_7].port_width_in_bits = 1;
  port_descriptions[irq_7].protocol_name = "signal";
  port_descriptions[irq_7].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[irq_7].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[irq_7].ipxactBusDef.name = "signal";
  port_descriptions[irq_7].ipxactBusDef.version = "1.0"; 
  port_descriptions[irq_7].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[irq_7].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[irq_7].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[irq_7].ipxactAbstrDef.version = "1.0";
  port_descriptions[irq_7].port_must_bind = 0;
  port_descriptions[irq_7].params_count = 3;
  port_descriptions[irq_7].clock = signal_clock;
  m_machineArch->configureClock(irq_7, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[irq_7].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[irq_7].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);


  port_descriptions[master0].default_read_transaction_name = "READ";
  port_descriptions[master1].default_read_transaction_name = "READ";
  port_descriptions[master0].default_write_transaction_name = "WRITE";
  port_descriptions[master1].default_write_transaction_name = "WRITE";
  port_descriptions[n_scu_reset].default_write_transaction_name = "WRITE";
  port_descriptions[n_periph_reset].default_write_transaction_name = "WRITE";
  port_descriptions[n_irq_0].default_write_transaction_name = "WRITE";
  port_descriptions[n_fiq_0].default_write_transaction_name = "WRITE";
  port_descriptions[n_irq_1].default_write_transaction_name = "WRITE";
  port_descriptions[n_fiq_1].default_write_transaction_name = "WRITE";
  port_descriptions[n_reset_0].default_write_transaction_name = "WRITE";
  port_descriptions[n_wd_reset_0].default_write_transaction_name = "WRITE";
  port_descriptions[wd_reset_req_0].default_write_transaction_name = "WRITE";
  port_descriptions[n_reset_1].default_write_transaction_name = "WRITE";
  port_descriptions[n_wd_reset_1].default_write_transaction_name = "WRITE";
  port_descriptions[wd_reset_req_1].default_write_transaction_name = "WRITE";
  port_descriptions[irq_0].default_write_transaction_name = "WRITE";
  port_descriptions[irq_1].default_write_transaction_name = "WRITE";
  port_descriptions[irq_2].default_write_transaction_name = "WRITE";
  port_descriptions[irq_3].default_write_transaction_name = "WRITE";
  port_descriptions[irq_4].default_write_transaction_name = "WRITE";
  port_descriptions[irq_5].default_write_transaction_name = "WRITE";
  port_descriptions[irq_6].default_write_transaction_name = "WRITE";
  port_descriptions[irq_7].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);

  bool isCpu = false;
  isCpu = true;
  esl::tlm_sim::UserRunningModel* userRunningModel = Papoulis_CreateUserRunningModel(name(),
                                                                                     0,
                                                                                     this,
                                                                                     simulation,
                                                                                     false,
                                                                                     isCpu);
  setUserRunningModel(userRunningModel, isCpu);
  set_nominal_voltage(nominal_voltage);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("signal_clock", "sc_core::sc_time", sdGetParameterAsConstString("signal_clock"));
  registerParameter("axi_clock", "sc_core::sc_time", sdGetParameterAsConstString("axi_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("master0_outstanding", "unsigned int", sdGetParameterAsConstString("master0_outstanding"));
  registerParameter("master0_read_data_queue_size", "unsigned int", sdGetParameterAsConstString("master0_read_data_queue_size"));
  registerParameter("master0_write_data_queue_size", "unsigned int", sdGetParameterAsConstString("master0_write_data_queue_size"));
  registerParameter("master1_outstanding", "unsigned int", sdGetParameterAsConstString("master1_outstanding"));
  registerParameter("master1_read_data_queue_size", "unsigned int", sdGetParameterAsConstString("master1_read_data_queue_size"));
  registerParameter("master1_write_data_queue_size", "unsigned int", sdGetParameterAsConstString("master1_write_data_queue_size"));
  registerParameter("n_scu_reset_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_scu_reset_pipeline_length"));
  registerParameter("n_periph_reset_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_periph_reset_pipeline_length"));
  registerParameter("n_irq_0_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_irq_0_pipeline_length"));
  registerParameter("n_fiq_0_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_fiq_0_pipeline_length"));
  registerParameter("n_irq_1_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_irq_1_pipeline_length"));
  registerParameter("n_fiq_1_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_fiq_1_pipeline_length"));
  registerParameter("n_reset_0_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_reset_0_pipeline_length"));
  registerParameter("n_wd_reset_0_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_wd_reset_0_pipeline_length"));
  registerParameter("n_reset_1_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_reset_1_pipeline_length"));
  registerParameter("n_wd_reset_1_pipeline_length", "unsigned int", sdGetParameterAsConstString("n_wd_reset_1_pipeline_length"));
  registerParameter("irq_0_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_0_pipeline_length"));
  registerParameter("irq_1_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_1_pipeline_length"));
  registerParameter("irq_2_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_2_pipeline_length"));
  registerParameter("irq_3_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_3_pipeline_length"));
  registerParameter("irq_4_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_4_pipeline_length"));
  registerParameter("irq_5_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_5_pipeline_length"));
  registerParameter("irq_6_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_6_pipeline_length"));
  registerParameter("irq_7_pipeline_length", "unsigned int", sdGetParameterAsConstString("irq_7_pipeline_length"));
  registerParameter("dcache_size", "unsigned int", sdGetParameterAsConstString("dcache_size"));
  registerParameter("icache_size", "unsigned int", sdGetParameterAsConstString("icache_size"));
  registerParameter("cache_control", "const char*", sdGetParameterAsConstString("cache_control"));
  registerParameter("dcache_control", "const char*", sdGetParameterAsConstString("dcache_control"));
  registerParameter("icache_control", "const char*", sdGetParameterAsConstString("icache_control"));
  registerParameter("control_page_address", "unsigned long long", sdGetParameterAsConstString("control_page_address"));
  registerParameter("elf_image_file", "const char*", sdGetParameterAsConstString("elf_image_file"));
  registerParameter("gdbstub_port", "unsigned int", sdGetParameterAsConstString("gdbstub_port"));
  registerParameter("instruction_latency", "sc_core::sc_time", sdGetParameterAsConstString("instruction_latency"));
  registerParameter("instruction_energy", "mb::utl::energy", sdGetParameterAsConstString("instruction_energy"));
  registerParameter("lt_synch_quantum", "sc_core::sc_time", sdGetParameterAsConstString("lt_synch_quantum"));
  registerParameter("high_vec", "bool", sdGetParameterAsConstString("high_vec"));
  registerParameter("cluster_id", "unsigned int", sdGetParameterAsConstString("cluster_id"));
  registerParameter("periph_clock", "sc_core::sc_time", sdGetParameterAsConstString("periph_clock"));
  registerParameter("periph_base", "unsigned int", sdGetParameterAsConstString("periph_base"));
  set_sync_all(0); 
  
  
  
  
  

  
  

  


  

  constant_global_power_policy* p = new constant_global_power_policy(userRunningModel);
  p->set_leakage_power(0.1);
  p->set_clock_tree_power(0.2);
  set_nominal_clock(1000000/100); /* in ps */ 
  update_coefficients();
  set_global_power_policy(p);
}

void cpu_subsystem_t_base::update_sync_all() {
  set_sync_all(0);
  
}

void cpu_subsystem_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;


}

void cpu_subsystem_t_base::update_sequential_parameters(esl::sc_sim::sequential_policy* handle) {
  if (m_sequential_vector.size() == 0)
    return;

}

void cpu_subsystem_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

}

void cpu_subsystem_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}

void cpu_subsystem_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}

void cpu_subsystem_t_base::update_state_power_parameters(esl::sc_sim::state_power_policy* handle) {
  if (m_state_power_vector.size() == 0)
    return;

}

void cpu_subsystem_t_base::update_global_power_parameters(esl::sc_sim::constant_global_power_policy* handle) {
  handle->set_leakage_power(0.1);
  handle->set_clock_tree_power(0.2);
  return;  
}

bool cpu_subsystem_t_base::triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans) {
  mb::utl::Segment<uint64_t> transactionRange(trans.get_address(), trans.get_address() + trans.get_data_length());

  return false;
}

bool cpu_subsystem_t_base::portHasRegisters(unsigned portIndex) {
  switch (portIndex) {

  }
  return false;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for cpu_subsystem.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>

#include "cpu_subsystem_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "cpu_subsystem_pv.h"




// Constructor
cpu_subsystem_pvt::cpu_subsystem_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 1),
    cpu_subsystem_pvt_param_defaults(this->name()),
    master0("master0"),
    master1("master1"),
    wd_reset_req_0("wd_reset_req_0"),
    wd_reset_req_1("wd_reset_req_1"),
    n_scu_reset("n_scu_reset"),
    n_periph_reset("n_periph_reset"),
    n_irq_0("n_irq_0"),
    n_fiq_0("n_fiq_0"),
    n_irq_1("n_irq_1"),
    n_fiq_1("n_fiq_1"),
    n_reset_0("n_reset_0"),
    n_wd_reset_0("n_wd_reset_0"),
    n_reset_1("n_reset_1"),
    n_wd_reset_1("n_wd_reset_1"),
    irq_0("irq_0"),
    irq_1("irq_1"),
    irq_2("irq_2"),
    irq_3("irq_3"),
    irq_4("irq_4"),
    irq_5("irq_5"),
    irq_6("irq_6"),
    irq_7("irq_7"), 
    master0_entry("unvisible_master0_entry"), 
    master1_entry("unvisible_master1_entry"),
    n_scu_reset_entry("unvisible_n_scu_reset_entry"),
    n_periph_reset_entry("unvisible_n_periph_reset_entry"),
    n_irq_0_entry("unvisible_n_irq_0_entry"),
    n_fiq_0_entry("unvisible_n_fiq_0_entry"),
    n_irq_1_entry("unvisible_n_irq_1_entry"),
    n_fiq_1_entry("unvisible_n_fiq_1_entry"),
    n_reset_0_entry("unvisible_n_reset_0_entry"),
    n_wd_reset_0_entry("unvisible_n_wd_reset_0_entry"),
    n_reset_1_entry("unvisible_n_reset_1_entry"),
    n_wd_reset_1_entry("unvisible_n_wd_reset_1_entry"),
    irq_0_entry("unvisible_irq_0_entry"),
    irq_1_entry("unvisible_irq_1_entry"),
    irq_2_entry("unvisible_irq_2_entry"),
    irq_3_entry("unvisible_irq_3_entry"),
    irq_4_entry("unvisible_irq_4_entry"),
    irq_5_entry("unvisible_irq_5_entry"),
    irq_6_entry("unvisible_irq_6_entry"),
    irq_7_entry("unvisible_irq_7_entry"),
    m_master0_nb_connector(*this),
    m_master1_nb_connector(*this),
    m_wd_reset_req_0_nb_connector(*this),
    m_wd_reset_req_1_nb_connector(*this),
    m_n_scu_reset_nb_connector(*this),
    m_n_periph_reset_nb_connector(*this),
    m_n_irq_0_nb_connector(*this),
    m_n_fiq_0_nb_connector(*this),
    m_n_irq_1_nb_connector(*this),
    m_n_fiq_1_nb_connector(*this),
    m_n_reset_0_nb_connector(*this),
    m_n_wd_reset_0_nb_connector(*this),
    m_n_reset_1_nb_connector(*this),
    m_n_wd_reset_1_nb_connector(*this),
    m_irq_0_nb_connector(*this),
    m_irq_1_nb_connector(*this),
    m_irq_2_nb_connector(*this),
    m_irq_3_nb_connector(*this),
    m_irq_4_nb_connector(*this),
    m_irq_5_nb_connector(*this),
    m_irq_6_nb_connector(*this),
    m_irq_7_nb_connector(*this)

{


  m_cpu_subsystem_t = cpu_subsystem_t_base::create_t("T", 1);
  m_cpu_subsystem_pv = new cpu_subsystem_pv("PV");
  bind();
}  


cpu_subsystem_pvt::cpu_subsystem_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time signal_clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int master0_outstanding_init, unsigned int master0_read_data_queue_size_init, unsigned int master0_write_data_queue_size_init, unsigned int master1_outstanding_init, unsigned int master1_read_data_queue_size_init, unsigned int master1_write_data_queue_size_init, unsigned int n_scu_reset_pipeline_length_init, unsigned int n_periph_reset_pipeline_length_init, unsigned int n_irq_0_pipeline_length_init, unsigned int n_fiq_0_pipeline_length_init, unsigned int n_irq_1_pipeline_length_init, unsigned int n_fiq_1_pipeline_length_init, unsigned int n_reset_0_pipeline_length_init, unsigned int n_wd_reset_0_pipeline_length_init, unsigned int n_reset_1_pipeline_length_init, unsigned int n_wd_reset_1_pipeline_length_init, unsigned int irq_0_pipeline_length_init, unsigned int irq_1_pipeline_length_init, unsigned int irq_2_pipeline_length_init, unsigned int irq_3_pipeline_length_init, unsigned int irq_4_pipeline_length_init, unsigned int irq_5_pipeline_length_init, unsigned int irq_6_pipeline_length_init, unsigned int irq_7_pipeline_length_init, unsigned int dcache_size_init, unsigned int icache_size_init, const char* cache_control_init, const char* dcache_control_init, const char* icache_control_init, unsigned long long control_page_address_init, const char* elf_image_file_init, unsigned int gdbstub_port_init, sc_core::sc_time instruction_latency_init, mb::utl::energy instruction_energy_init, sc_core::sc_time lt_synch_quantum_init, bool high_vec_init, unsigned int cluster_id_init, sc_core::sc_time periph_clock_init, unsigned int periph_base_init)
  : esl::sc_sim::PVTBaseModel(module_name, 1),
  cpu_subsystem_pvt_param_defaults(this->name(), clock_init, signal_clock_init, axi_clock_init, nominal_voltage_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, master0_outstanding_init, master0_read_data_queue_size_init, master0_write_data_queue_size_init, master1_outstanding_init, master1_read_data_queue_size_init, master1_write_data_queue_size_init, n_scu_reset_pipeline_length_init, n_periph_reset_pipeline_length_init, n_irq_0_pipeline_length_init, n_fiq_0_pipeline_length_init, n_irq_1_pipeline_length_init, n_fiq_1_pipeline_length_init, n_reset_0_pipeline_length_init, n_wd_reset_0_pipeline_length_init, n_reset_1_pipeline_length_init, n_wd_reset_1_pipeline_length_init, irq_0_pipeline_length_init, irq_1_pipeline_length_init, irq_2_pipeline_length_init, irq_3_pipeline_length_init, irq_4_pipeline_length_init, irq_5_pipeline_length_init, irq_6_pipeline_length_init, irq_7_pipeline_length_init, dcache_size_init, icache_size_init, cache_control_init, dcache_control_init, icache_control_init, control_page_address_init, elf_image_file_init, gdbstub_port_init, instruction_latency_init, instruction_energy_init, lt_synch_quantum_init, high_vec_init, cluster_id_init, periph_clock_init, periph_base_init),
    master0("master0"),
    master1("master1"),
    wd_reset_req_0("wd_reset_req_0"),
    wd_reset_req_1("wd_reset_req_1"),
    n_scu_reset("n_scu_reset"),
    n_periph_reset("n_periph_reset"),
    n_irq_0("n_irq_0"),
    n_fiq_0("n_fiq_0"),
    n_irq_1("n_irq_1"),
    n_fiq_1("n_fiq_1"),
    n_reset_0("n_reset_0"),
    n_wd_reset_0("n_wd_reset_0"),
    n_reset_1("n_reset_1"),
    n_wd_reset_1("n_wd_reset_1"),
    irq_0("irq_0"),
    irq_1("irq_1"),
    irq_2("irq_2"),
    irq_3("irq_3"),
    irq_4("irq_4"),
    irq_5("irq_5"),
    irq_6("irq_6"),
    irq_7("irq_7"), 
    master0_entry("unvisible_master0_entry"), 
    master1_entry("unvisible_master1_entry"),
    n_scu_reset_entry("unvisible_n_scu_reset_entry"),
    n_periph_reset_entry("unvisible_n_periph_reset_entry"),
    n_irq_0_entry("unvisible_n_irq_0_entry"),
    n_fiq_0_entry("unvisible_n_fiq_0_entry"),
    n_irq_1_entry("unvisible_n_irq_1_entry"),
    n_fiq_1_entry("unvisible_n_fiq_1_entry"),
    n_reset_0_entry("unvisible_n_reset_0_entry"),
    n_wd_reset_0_entry("unvisible_n_wd_reset_0_entry"),
    n_reset_1_entry("unvisible_n_reset_1_entry"),
    n_wd_reset_1_entry("unvisible_n_wd_reset_1_entry"),
    irq_0_entry("unvisible_irq_0_entry"),
    irq_1_entry("unvisible_irq_1_entry"),
    irq_2_entry("unvisible_irq_2_entry"),
    irq_3_entry("unvisible_irq_3_entry"),
    irq_4_entry("unvisible_irq_4_entry"),
    irq_5_entry("unvisible_irq_5_entry"),
    irq_6_entry("unvisible_irq_6_entry"),
    irq_7_entry("unvisible_irq_7_entry"),
    m_master0_nb_connector(*this),
    m_master1_nb_connector(*this),
    m_wd_reset_req_0_nb_connector(*this),
    m_wd_reset_req_1_nb_connector(*this),
    m_n_scu_reset_nb_connector(*this),
    m_n_periph_reset_nb_connector(*this),
    m_n_irq_0_nb_connector(*this),
    m_n_fiq_0_nb_connector(*this),
    m_n_irq_1_nb_connector(*this),
    m_n_fiq_1_nb_connector(*this),
    m_n_reset_0_nb_connector(*this),
    m_n_wd_reset_0_nb_connector(*this),
    m_n_reset_1_nb_connector(*this),
    m_n_wd_reset_1_nb_connector(*this),
    m_irq_0_nb_connector(*this),
    m_irq_1_nb_connector(*this),
    m_irq_2_nb_connector(*this),
    m_irq_3_nb_connector(*this),
    m_irq_4_nb_connector(*this),
    m_irq_5_nb_connector(*this),
    m_irq_6_nb_connector(*this),
    m_irq_7_nb_connector(*this)
{


  m_cpu_subsystem_t = cpu_subsystem_t_base::create_t("T", 1);
  m_cpu_subsystem_pv = new cpu_subsystem_pv("PV");
  bind();
} 

cpu_subsystem_pvt::cpu_subsystem_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 1),
  cpu_subsystem_pvt_param_defaults(this->name(), change_parameters),
    master0("master0"),
    master1("master1"),
    wd_reset_req_0("wd_reset_req_0"),
    wd_reset_req_1("wd_reset_req_1"),
    n_scu_reset("n_scu_reset"),
    n_periph_reset("n_periph_reset"),
    n_irq_0("n_irq_0"),
    n_fiq_0("n_fiq_0"),
    n_irq_1("n_irq_1"),
    n_fiq_1("n_fiq_1"),
    n_reset_0("n_reset_0"),
    n_wd_reset_0("n_wd_reset_0"),
    n_reset_1("n_reset_1"),
    n_wd_reset_1("n_wd_reset_1"),
    irq_0("irq_0"),
    irq_1("irq_1"),
    irq_2("irq_2"),
    irq_3("irq_3"),
    irq_4("irq_4"),
    irq_5("irq_5"),
    irq_6("irq_6"),
    irq_7("irq_7"), 
    master0_entry("unvisible_master0_entry"), 
    master1_entry("unvisible_master1_entry"),
    n_scu_reset_entry("unvisible_n_scu_reset_entry"),
    n_periph_reset_entry("unvisible_n_periph_reset_entry"),
    n_irq_0_entry("unvisible_n_irq_0_entry"),
    n_fiq_0_entry("unvisible_n_fiq_0_entry"),
    n_irq_1_entry("unvisible_n_irq_1_entry"),
    n_fiq_1_entry("unvisible_n_fiq_1_entry"),
    n_reset_0_entry("unvisible_n_reset_0_entry"),
    n_wd_reset_0_entry("unvisible_n_wd_reset_0_entry"),
    n_reset_1_entry("unvisible_n_reset_1_entry"),
    n_wd_reset_1_entry("unvisible_n_wd_reset_1_entry"),
    irq_0_entry("unvisible_irq_0_entry"),
    irq_1_entry("unvisible_irq_1_entry"),
    irq_2_entry("unvisible_irq_2_entry"),
    irq_3_entry("unvisible_irq_3_entry"),
    irq_4_entry("unvisible_irq_4_entry"),
    irq_5_entry("unvisible_irq_5_entry"),
    irq_6_entry("unvisible_irq_6_entry"),
    irq_7_entry("unvisible_irq_7_entry"),
    m_master0_nb_connector(*this),
    m_master1_nb_connector(*this),
    m_wd_reset_req_0_nb_connector(*this),
    m_wd_reset_req_1_nb_connector(*this),
    m_n_scu_reset_nb_connector(*this),
    m_n_periph_reset_nb_connector(*this),
    m_n_irq_0_nb_connector(*this),
    m_n_fiq_0_nb_connector(*this),
    m_n_irq_1_nb_connector(*this),
    m_n_fiq_1_nb_connector(*this),
    m_n_reset_0_nb_connector(*this),
    m_n_wd_reset_0_nb_connector(*this),
    m_n_reset_1_nb_connector(*this),
    m_n_wd_reset_1_nb_connector(*this),
    m_irq_0_nb_connector(*this),
    m_irq_1_nb_connector(*this),
    m_irq_2_nb_connector(*this),
    m_irq_3_nb_connector(*this),
    m_irq_4_nb_connector(*this),
    m_irq_5_nb_connector(*this),
    m_irq_6_nb_connector(*this),
    m_irq_7_nb_connector(*this)
{


  m_cpu_subsystem_t = cpu_subsystem_t_base::create_t("T", 1);
  m_cpu_subsystem_pv = new cpu_subsystem_pv("PV");
  bind();
} 

cpu_subsystem_pvt::~cpu_subsystem_pvt() {
  remove_pending_scenes();
  delete m_cpu_subsystem_t; delete m_cpu_subsystem_pv;
}




void cpu_subsystem_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->master0.bind(master0_entry);
  getPV()->master1.bind(master1_entry);
  getPV()->wd_reset_req_0.bind(wd_reset_req_0_entry);
  getPV()->wd_reset_req_1.bind(wd_reset_req_1_entry); 
  n_scu_reset_entry(getPV()->n_scu_reset);
  n_periph_reset_entry(getPV()->n_periph_reset);
  n_irq_0_entry(getPV()->n_irq_0);
  n_fiq_0_entry(getPV()->n_fiq_0);
  n_irq_1_entry(getPV()->n_irq_1);
  n_fiq_1_entry(getPV()->n_fiq_1);
  n_reset_0_entry(getPV()->n_reset_0);
  n_wd_reset_0_entry(getPV()->n_wd_reset_0);
  n_reset_1_entry(getPV()->n_reset_1);
  n_wd_reset_1_entry(getPV()->n_wd_reset_1);
  irq_0_entry(getPV()->irq_0);
  irq_1_entry(getPV()->irq_1);
  irq_2_entry(getPV()->irq_2);
  irq_3_entry(getPV()->irq_3);
  irq_4_entry(getPV()->irq_4);
  irq_5_entry(getPV()->irq_5);
  irq_6_entry(getPV()->irq_6);
  irq_7_entry(getPV()->irq_7);  

  /* set callbacks on external and entry ports */ 

  n_scu_reset.b_transport_cb.set(this, &self_type::b_transport_inside_n_scu_reset);

  n_periph_reset.b_transport_cb.set(this, &self_type::b_transport_inside_n_periph_reset);

  n_irq_0.b_transport_cb.set(this, &self_type::b_transport_inside_n_irq_0);

  n_fiq_0.b_transport_cb.set(this, &self_type::b_transport_inside_n_fiq_0);

  n_irq_1.b_transport_cb.set(this, &self_type::b_transport_inside_n_irq_1);

  n_fiq_1.b_transport_cb.set(this, &self_type::b_transport_inside_n_fiq_1);

  n_reset_0.b_transport_cb.set(this, &self_type::b_transport_inside_n_reset_0);

  n_wd_reset_0.b_transport_cb.set(this, &self_type::b_transport_inside_n_wd_reset_0);

  n_reset_1.b_transport_cb.set(this, &self_type::b_transport_inside_n_reset_1);

  n_wd_reset_1.b_transport_cb.set(this, &self_type::b_transport_inside_n_wd_reset_1);

  irq_0.b_transport_cb.set(this, &self_type::b_transport_inside_irq_0);

  irq_1.b_transport_cb.set(this, &self_type::b_transport_inside_irq_1);

  irq_2.b_transport_cb.set(this, &self_type::b_transport_inside_irq_2);

  irq_3.b_transport_cb.set(this, &self_type::b_transport_inside_irq_3);

  irq_4.b_transport_cb.set(this, &self_type::b_transport_inside_irq_4);

  irq_5.b_transport_cb.set(this, &self_type::b_transport_inside_irq_5);

  irq_6.b_transport_cb.set(this, &self_type::b_transport_inside_irq_6);

  irq_7.b_transport_cb.set(this, &self_type::b_transport_inside_irq_7);

  master0_entry.b_transport_cb.set(this, &self_type::b_transport_outside_master0);
  master0_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_master0);
  master0_entry.get_direct_mem_ptr_cb.set(&master0, &master0_type::get_direct_mem_ptr);

  master1_entry.b_transport_cb.set(this, &self_type::b_transport_outside_master1);
  master1_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_master1);
  master1_entry.get_direct_mem_ptr_cb.set(&master1, &master1_type::get_direct_mem_ptr);

  wd_reset_req_0_entry.write_cb.set(this, &self_type::b_transport_outside_wd_reset_req_0);

  wd_reset_req_1_entry.write_cb.set(this, &self_type::b_transport_outside_wd_reset_req_1);

  
  /* connect t non blocking callbacks */

  master0.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_master0);
  getT()->set_port_cb(0, &m_master0_nb_connector);

  master1.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_master1);
  getT()->set_port_cb(1, &m_master1_nb_connector);

  wd_reset_req_0.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_wd_reset_req_0);
  getT()->set_port_cb(10, &m_wd_reset_req_0_nb_connector);

  wd_reset_req_1.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_wd_reset_req_1);
  getT()->set_port_cb(13, &m_wd_reset_req_1_nb_connector);

  n_scu_reset.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_scu_reset);
  getT()->set_port_cb(2, &m_n_scu_reset_nb_connector);

  n_periph_reset.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_periph_reset);
  getT()->set_port_cb(3, &m_n_periph_reset_nb_connector);

  n_irq_0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_irq_0);
  getT()->set_port_cb(4, &m_n_irq_0_nb_connector);

  n_fiq_0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_fiq_0);
  getT()->set_port_cb(5, &m_n_fiq_0_nb_connector);

  n_irq_1.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_irq_1);
  getT()->set_port_cb(6, &m_n_irq_1_nb_connector);

  n_fiq_1.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_fiq_1);
  getT()->set_port_cb(7, &m_n_fiq_1_nb_connector);

  n_reset_0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_reset_0);
  getT()->set_port_cb(8, &m_n_reset_0_nb_connector);

  n_wd_reset_0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_wd_reset_0);
  getT()->set_port_cb(9, &m_n_wd_reset_0_nb_connector);

  n_reset_1.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_reset_1);
  getT()->set_port_cb(11, &m_n_reset_1_nb_connector);

  n_wd_reset_1.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_n_wd_reset_1);
  getT()->set_port_cb(12, &m_n_wd_reset_1_nb_connector);

  irq_0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_0);
  getT()->set_port_cb(14, &m_irq_0_nb_connector);

  irq_1.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_1);
  getT()->set_port_cb(15, &m_irq_1_nb_connector);

  irq_2.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_2);
  getT()->set_port_cb(16, &m_irq_2_nb_connector);

  irq_3.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_3);
  getT()->set_port_cb(17, &m_irq_3_nb_connector);

  irq_4.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_4);
  getT()->set_port_cb(18, &m_irq_4_nb_connector);

  irq_5.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_5);
  getT()->set_port_cb(19, &m_irq_5_nb_connector);

  irq_6.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_6);
  getT()->set_port_cb(20, &m_irq_6_nb_connector);

  irq_7.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_irq_7);
  getT()->set_port_cb(21, &m_irq_7_nb_connector);

  master0.invalidate_direct_mem_ptr_cb.set(&master0_entry, &master0_entry_type::invalidate_direct_mem_ptr);

  master1.invalidate_direct_mem_ptr_cb.set(&master1_entry, &master1_entry_type::invalidate_direct_mem_ptr);

  /* check mb_event policies */
  m_cpu_subsystem_t->check_mb_events();
}


void cpu_subsystem_pvt::b_transport_inside_n_scu_reset(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_scu_reset_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_periph_reset(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_periph_reset_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_irq_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_irq_0_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_fiq_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_fiq_0_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_irq_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_irq_1_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_fiq_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_fiq_1_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_reset_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_reset_0_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_wd_reset_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_wd_reset_0_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_reset_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_reset_1_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_n_wd_reset_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  n_wd_reset_1_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_0_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_1(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_1_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_2(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_2_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_3(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_3_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_4(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_4_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_5(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_5_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_6(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_6_entry.write(*(bool*)p.get_data_ptr());
}
void cpu_subsystem_pvt::b_transport_inside_irq_7(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  irq_7_entry.write(*(bool*)p.get_data_ptr());
}

void cpu_subsystem_pvt::b_transport_outside_master0(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  master0.b_transport(p, t);
  
} 

unsigned int cpu_subsystem_pvt::transport_dbg_outside_master0(tlm::tlm_generic_payload& p)
{
  
  return master0.transport_dbg(p);
  
}

void cpu_subsystem_pvt::b_transport_outside_master1(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  master1.b_transport(p, t);
  
} 

unsigned int cpu_subsystem_pvt::transport_dbg_outside_master1(tlm::tlm_generic_payload& p)
{
  
  return master1.transport_dbg(p);
  
}

void cpu_subsystem_pvt::b_transport_outside_wd_reset_req_0(bool data)
{
  static tlm::tlm_generic_payload payload;

  payload.reset();
  payload.set_command(tlm::TLM_WRITE_COMMAND);
  payload.set_data_ptr((unsigned char*)&data);
  payload.set_data_length(sizeof(bool));
  payload.set_streaming_width(sizeof(bool));

  mb::tlm20::clear_pvt_ext(payload);
  mb::tlm20::setup_pvt_ext(payload)->set_signal(true);

  if (!wd_reset_req_0.get_interface()) {
    return;
  }

  mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
  if (current_model)
    mb::tlm20::setup_pvt_ext(payload)->setToken(current_model->get_current_token());
  sc_time t;
  wd_reset_req_0.b_transport(payload, t);
}

void cpu_subsystem_pvt::b_transport_outside_wd_reset_req_1(bool data)
{
  static tlm::tlm_generic_payload payload;

  payload.reset();
  payload.set_command(tlm::TLM_WRITE_COMMAND);
  payload.set_data_ptr((unsigned char*)&data);
  payload.set_data_length(sizeof(bool));
  payload.set_streaming_width(sizeof(bool));

  mb::tlm20::clear_pvt_ext(payload);
  mb::tlm20::setup_pvt_ext(payload)->set_signal(true);

  if (!wd_reset_req_1.get_interface()) {
    return;
  }

  mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_cpu_subsystem_pv);
  if (current_model)
    mb::tlm20::setup_pvt_ext(payload)->setToken(current_model->get_current_token());
  sc_time t;
  wd_reset_req_1.b_transport(payload, t);
}

