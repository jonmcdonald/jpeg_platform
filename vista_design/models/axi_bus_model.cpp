
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The axi_bus_pv will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>


#include "axi_bus_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


axi_bus_pv_base::axi_bus_pv_base(sc_module_name& module_name) : 
  axi_bus_pv_base_mb_compatibility(module_name),
  axi_bus_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(sram_master),
  VISTA_MB_PV_INIT_MEMBER(apb_master),
  VISTA_MB_PV_INIT_MEMBER(h264_master),
  VISTA_MB_PV_INIT_MEMBER(lcd_master),
  VISTA_MB_PV_INIT_MEMBER(jpeg_master),
  VISTA_MB_PV_INIT_MEMBER(io_master),
  VISTA_MB_PV_INIT_MEMBER(eth_slave),
  VISTA_MB_PV_INIT_MEMBER(bus_slave0),
  VISTA_MB_PV_INIT_MEMBER(bus_slave1),
  VISTA_MB_PV_INIT_MEMBER(h264_slave),
  VISTA_MB_PV_INIT_MEMBER(lcd_slave),
  VISTA_MB_PV_INIT_MEMBER(jpeg_slave),
  VISTA_MB_PV_INIT_MEMBER(io_slave) {


  payload_on_stack = 0;
  payload_for_token = 0;

  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(bus_slave0);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(bus_slave1);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(h264_slave);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(lcd_slave);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(jpeg_slave);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(io_slave);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(sram_master);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(apb_master);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(h264_master);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(lcd_master);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(jpeg_master);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(io_master);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(eth_slave);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(bus_slave0);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(bus_slave1);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(h264_slave);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(lcd_slave);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(jpeg_slave);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(io_slave);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(sram_master);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(apb_master);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(h264_master);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(lcd_master);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(jpeg_master);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(io_master);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(eth_slave);

}

void axi_bus_pv_base::reset_model() {
  // reset all registers


  
  // reset value for output signals

  // reset value for input signals

}

axi_bus_pv_base_parameters::axi_bus_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, axi_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, layers, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_sets, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, write_broadcast, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_slave0_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_slave0_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_slave1_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_slave1_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_slave_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_slave_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_size, 0x10000000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, sram_master_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_master_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_master_base_address, 0x40000000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_master_size, 0x10000000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_master_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_master_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_master_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_master_base_address, 0x14004000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_master_size, 0x1000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_master_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, h264_master_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_master_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_master_base_address, 0x14004000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_master_size, 0x1000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_master_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, lcd_master_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_master_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_master_base_address, 0x10000000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_master_size, 0x20),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_master_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_master_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_master_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_master_base_address, 0x10000020),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_master_size, 0x20),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_master_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_master_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_slave_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, jpeg_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_slave_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, io_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, eth_slave_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, eth_slave_base_address, 0x14005000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, eth_slave_size, 0x10),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, eth_slave_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, eth_slave_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, eth_slave_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, eth_slave_latency, 0)
{
  if(verbose_parameters) print_parameters();
}

void axi_bus_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\taxi_clock = " << axi_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tlayers = " << layers << "\n";
  std::cout << "\tslave_sets = " << slave_sets << "\n";
  std::cout << "\twrite_broadcast = " << write_broadcast << "\n";
  std::cout << "\tbus_slave0_priority = " << bus_slave0_priority << "\n";
  std::cout << "\tbus_slave0_vmap = " << bus_slave0_vmap << "\n";
  std::cout << "\tbus_slave1_priority = " << bus_slave1_priority << "\n";
  std::cout << "\tbus_slave1_vmap = " << bus_slave1_vmap << "\n";
  std::cout << "\th264_slave_priority = " << h264_slave_priority << "\n";
  std::cout << "\th264_slave_vmap = " << h264_slave_vmap << "\n";
  std::cout << "\tlcd_slave_priority = " << lcd_slave_priority << "\n";
  std::cout << "\tlcd_slave_vmap = " << lcd_slave_vmap << "\n";
  std::cout << "\tsram_master_priority = " << sram_master_priority << "\n";
  std::cout << "\tsram_master_base_address = " << sram_master_base_address << "\n";
  std::cout << "\tsram_master_size = " << sram_master_size << "\n";
  std::cout << "\tsram_master_subtract_base_address = " << sram_master_subtract_base_address << "\n";
  std::cout << "\tsram_master_secure = " << sram_master_secure << "\n";
  std::cout << "\tsram_master_additional_ranges = " << sram_master_additional_ranges << "\n";
  std::cout << "\tsram_master_latency = " << sram_master_latency << "\n";
  std::cout << "\tapb_master_priority = " << apb_master_priority << "\n";
  std::cout << "\tapb_master_base_address = " << apb_master_base_address << "\n";
  std::cout << "\tapb_master_size = " << apb_master_size << "\n";
  std::cout << "\tapb_master_subtract_base_address = " << apb_master_subtract_base_address << "\n";
  std::cout << "\tapb_master_secure = " << apb_master_secure << "\n";
  std::cout << "\tapb_master_additional_ranges = " << apb_master_additional_ranges << "\n";
  std::cout << "\tapb_master_latency = " << apb_master_latency << "\n";
  std::cout << "\th264_master_priority = " << h264_master_priority << "\n";
  std::cout << "\th264_master_base_address = " << h264_master_base_address << "\n";
  std::cout << "\th264_master_size = " << h264_master_size << "\n";
  std::cout << "\th264_master_subtract_base_address = " << h264_master_subtract_base_address << "\n";
  std::cout << "\th264_master_secure = " << h264_master_secure << "\n";
  std::cout << "\th264_master_additional_ranges = " << h264_master_additional_ranges << "\n";
  std::cout << "\th264_master_latency = " << h264_master_latency << "\n";
  std::cout << "\tlcd_master_priority = " << lcd_master_priority << "\n";
  std::cout << "\tlcd_master_base_address = " << lcd_master_base_address << "\n";
  std::cout << "\tlcd_master_size = " << lcd_master_size << "\n";
  std::cout << "\tlcd_master_subtract_base_address = " << lcd_master_subtract_base_address << "\n";
  std::cout << "\tlcd_master_secure = " << lcd_master_secure << "\n";
  std::cout << "\tlcd_master_additional_ranges = " << lcd_master_additional_ranges << "\n";
  std::cout << "\tlcd_master_latency = " << lcd_master_latency << "\n";
  std::cout << "\tjpeg_master_priority = " << jpeg_master_priority << "\n";
  std::cout << "\tjpeg_master_base_address = " << jpeg_master_base_address << "\n";
  std::cout << "\tjpeg_master_size = " << jpeg_master_size << "\n";
  std::cout << "\tjpeg_master_subtract_base_address = " << jpeg_master_subtract_base_address << "\n";
  std::cout << "\tjpeg_master_secure = " << jpeg_master_secure << "\n";
  std::cout << "\tjpeg_master_additional_ranges = " << jpeg_master_additional_ranges << "\n";
  std::cout << "\tjpeg_master_latency = " << jpeg_master_latency << "\n";
  std::cout << "\tio_master_priority = " << io_master_priority << "\n";
  std::cout << "\tio_master_base_address = " << io_master_base_address << "\n";
  std::cout << "\tio_master_size = " << io_master_size << "\n";
  std::cout << "\tio_master_subtract_base_address = " << io_master_subtract_base_address << "\n";
  std::cout << "\tio_master_secure = " << io_master_secure << "\n";
  std::cout << "\tio_master_additional_ranges = " << io_master_additional_ranges << "\n";
  std::cout << "\tio_master_latency = " << io_master_latency << "\n";
  std::cout << "\tjpeg_slave_priority = " << jpeg_slave_priority << "\n";
  std::cout << "\tjpeg_slave_vmap = " << jpeg_slave_vmap << "\n";
  std::cout << "\tio_slave_priority = " << io_slave_priority << "\n";
  std::cout << "\tio_slave_vmap = " << io_slave_vmap << "\n";
  std::cout << "\teth_slave_priority = " << eth_slave_priority << "\n";
  std::cout << "\teth_slave_base_address = " << eth_slave_base_address << "\n";
  std::cout << "\teth_slave_size = " << eth_slave_size << "\n";
  std::cout << "\teth_slave_subtract_base_address = " << eth_slave_subtract_base_address << "\n";
  std::cout << "\teth_slave_secure = " << eth_slave_secure << "\n";
  std::cout << "\teth_slave_additional_ranges = " << eth_slave_additional_ranges << "\n";
  std::cout << "\teth_slave_latency = " << eth_slave_latency << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/


#include <iostream>





axi_bus_base1_pv::axi_bus_base1_pv(sc_module_name module_name) :
  axi_bus_pv_base(module_name) {
  dbg_port.bind(m_dbg_port_fw_process);
  m_dbg_port_fw_process.register_b_transport(this, &axi_bus_base1_pv::dbg_port_callback);
  m_dbg_port_fw_process.register_transport_dbg(this, &axi_bus_base1_pv::dbg_port_callback_dbg);
  m_dbg_port_fw_process.register_get_direct_mem_ptr(this, &axi_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback);

  m_model = dynamic_cast<PapoulisBusBaseModel *>(getSystemCBaseModel());
  if (m_model) {
    decoder = m_model->get_decoder();
 
  } else {
    decoder = new esl::sc_sim::user_model::Decoder(6, 13, write_broadcast);
    decoder->registerSlavePort(4, this->sram_master_base_address, this->sram_master_size, this->sram_master_subtract_base_address);
    decoder->registerSlavePort(5, this->apb_master_base_address, this->apb_master_size, this->apb_master_subtract_base_address);
    decoder->registerSlavePort(6, this->h264_master_base_address, this->h264_master_size, this->h264_master_subtract_base_address);
    decoder->registerSlavePort(7, this->lcd_master_base_address, this->lcd_master_size, this->lcd_master_subtract_base_address);
    decoder->registerSlavePort(8, this->jpeg_master_base_address, this->jpeg_master_size, this->jpeg_master_subtract_base_address);
    decoder->registerSlavePort(9, this->io_master_base_address, this->io_master_size, this->io_master_subtract_base_address);
    decoder->registerSlavePort(12, this->eth_slave_base_address, this->eth_slave_size, this->eth_slave_subtract_base_address);
    decoder->parseVmapString(0, this->bus_slave0_vmap, "bus_slave0_vmap");
    decoder->parseVmapString(1, this->bus_slave1_vmap, "bus_slave1_vmap");
    decoder->parseVmapString(2, this->h264_slave_vmap, "h264_slave_vmap");
    decoder->parseVmapString(3, this->lcd_slave_vmap, "lcd_slave_vmap");
    decoder->parseVmapString(10, this->jpeg_slave_vmap, "jpeg_slave_vmap");
    decoder->parseVmapString(11, this->io_slave_vmap, "io_slave_vmap");
  }
  
  m_port_count = 13;
  m_layers_count = m_model->get_arbiter()->get_layers_count();
  m_is_multi_channel = 1;
  m_bus_scheduler = new esl::sc_sim::BusScheduler(m_port_count, m_layers_count, m_is_multi_channel);
  m_apply_policies = false;
  const char* policy_modeling = "lt_policy_modeling";
  
  mb::sysc::add_parameter_listener(this->name(), policy_modeling, this);
  if (mb::sysc::sdParameterExists(policy_modeling)) {
    if (!strcasecmp(mb::sysc::sdGetParameterAsConstString(policy_modeling), "dynamic")) {
      m_apply_policies = true;
    }
  }
}

axi_bus_base1_pv::~axi_bus_base1_pv()
{
  delete m_bus_scheduler;
}
void axi_bus_base1_pv::parameter_changed(const std::string& old_value,
                                             const std::string& new_value) {
  if (!strcasecmp(new_value.c_str(), "dynamic")) {
    m_apply_policies = true;
  }
  else {
    m_apply_policies = false;
  }
}



void axi_bus_base1_pv::bus_slave0_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 0, false, t);
  
}

unsigned axi_bus_base1_pv::bus_slave0_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 0, true, t);

}

bool axi_bus_base1_pv::bus_slave0_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->apb_master_subtract_base_address) {
      offset = this->apb_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->apb_master_size);
    if (this->h264_master_subtract_base_address) {
      offset = this->h264_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->h264_master_size);
    if (this->lcd_master_subtract_base_address) {
      offset = this->lcd_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->lcd_master_size);
    if (this->jpeg_master_subtract_base_address) {
      offset = this->jpeg_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_master_size);
    if (this->io_master_subtract_base_address) {
      offset = this->io_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->io_master_size);
    if (this->eth_slave_subtract_base_address) {
      offset = this->eth_slave_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->eth_slave_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(0, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), 0, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), 0, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 0)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::bus_slave1_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 1, false, t);
  
}

unsigned axi_bus_base1_pv::bus_slave1_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 1, true, t);

}

bool axi_bus_base1_pv::bus_slave1_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->apb_master_subtract_base_address) {
      offset = this->apb_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->apb_master_size);
    if (this->h264_master_subtract_base_address) {
      offset = this->h264_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->h264_master_size);
    if (this->lcd_master_subtract_base_address) {
      offset = this->lcd_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->lcd_master_size);
    if (this->jpeg_master_subtract_base_address) {
      offset = this->jpeg_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_master_size);
    if (this->io_master_subtract_base_address) {
      offset = this->io_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->io_master_size);
    if (this->eth_slave_subtract_base_address) {
      offset = this->eth_slave_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->eth_slave_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(1, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(1), 1, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(1), 1, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(1), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 1)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::h264_slave_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 2, false, t);
  
}

unsigned axi_bus_base1_pv::h264_slave_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 2, true, t);

}

bool axi_bus_base1_pv::h264_slave_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->apb_master_subtract_base_address) {
      offset = this->apb_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->apb_master_size);
    if (this->h264_master_subtract_base_address) {
      offset = this->h264_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->h264_master_size);
    if (this->lcd_master_subtract_base_address) {
      offset = this->lcd_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->lcd_master_size);
    if (this->jpeg_master_subtract_base_address) {
      offset = this->jpeg_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_master_size);
    if (this->io_master_subtract_base_address) {
      offset = this->io_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->io_master_size);
    if (this->eth_slave_subtract_base_address) {
      offset = this->eth_slave_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->eth_slave_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(2, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), 2, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), 2, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(2), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 2)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::lcd_slave_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 3, false, t);
  
}

unsigned axi_bus_base1_pv::lcd_slave_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 3, true, t);

}

bool axi_bus_base1_pv::lcd_slave_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->apb_master_subtract_base_address) {
      offset = this->apb_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->apb_master_size);
    if (this->h264_master_subtract_base_address) {
      offset = this->h264_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->h264_master_size);
    if (this->lcd_master_subtract_base_address) {
      offset = this->lcd_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->lcd_master_size);
    if (this->jpeg_master_subtract_base_address) {
      offset = this->jpeg_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_master_size);
    if (this->io_master_subtract_base_address) {
      offset = this->io_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->io_master_size);
    if (this->eth_slave_subtract_base_address) {
      offset = this->eth_slave_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->eth_slave_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(3, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), 3, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), 3, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(3), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 3)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::jpeg_slave_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 10, false, t);
  
}

unsigned axi_bus_base1_pv::jpeg_slave_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 10, true, t);

}

bool axi_bus_base1_pv::jpeg_slave_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->apb_master_subtract_base_address) {
      offset = this->apb_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->apb_master_size);
    if (this->h264_master_subtract_base_address) {
      offset = this->h264_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->h264_master_size);
    if (this->lcd_master_subtract_base_address) {
      offset = this->lcd_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->lcd_master_size);
    if (this->jpeg_master_subtract_base_address) {
      offset = this->jpeg_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_master_size);
    if (this->io_master_subtract_base_address) {
      offset = this->io_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->io_master_size);
    if (this->eth_slave_subtract_base_address) {
      offset = this->eth_slave_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->eth_slave_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(10, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(10), 10, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(10), 10, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(10), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 10)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::io_slave_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 11, false, t);
  
}

unsigned axi_bus_base1_pv::io_slave_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 11, true, t);

}

bool axi_bus_base1_pv::io_slave_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->sram_master_subtract_base_address) {
      offset = this->sram_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->sram_master_size);
    if (this->apb_master_subtract_base_address) {
      offset = this->apb_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->apb_master_size);
    if (this->h264_master_subtract_base_address) {
      offset = this->h264_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->h264_master_size);
    if (this->lcd_master_subtract_base_address) {
      offset = this->lcd_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->lcd_master_size);
    if (this->jpeg_master_subtract_base_address) {
      offset = this->jpeg_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->jpeg_master_size);
    if (this->io_master_subtract_base_address) {
      offset = this->io_master_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->io_master_size);
    if (this->eth_slave_subtract_base_address) {
      offset = this->eth_slave_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->eth_slave_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(11, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(11), 11, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(11), 11, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(11), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 11)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void axi_bus_base1_pv::dbg_port_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, (unsigned) (-1), false, t);
}

unsigned axi_bus_base1_pv::dbg_port_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, (unsigned) (-1), true, t);
}

bool axi_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {
  sc_dt::uint64 virtualAddress = trans.get_address();
  std::vector<long> slavePortIndexArray;
  decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, 64, name(), "dbg_port");
  if (slavePortIndexArray.size() == 0) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
  long slavePortIndex = slavePortIndexArray[0];
  

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);
  
  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);
  return returnStatus;
}

void axi_bus_base1_pv::clip_the_range(sc_dt::uint64 address,
                                            sc_dt::uint64 &dmiStartAddress,
                                            sc_dt::uint64 &dmiEndAddress,
                                            unsigned char* &dmiPtr,
                                            long slavePortIndex,
                                            signed long long offset) {
  sc_dt::uint64 slaveStartAddress = 0;
  sc_dt::uint64 slaveEndAddress = 0;
  bool subtractBaseAddress = true;
  decoder->getSlaveRangeByAddress(slavePortIndex, address, slaveStartAddress, slaveEndAddress, subtractBaseAddress);
  if (subtractBaseAddress) {
    sc_dt::uint64 translatedStartAddress = 0;
    sc_dt::uint64 translatedEndAddress = slaveEndAddress - slaveStartAddress;
    if (dmiEndAddress > translatedEndAddress)
      dmiEndAddress = translatedEndAddress;
    
    dmiStartAddress += (slaveStartAddress);
    dmiEndAddress += (slaveStartAddress);
  } else {
    if (slaveStartAddress > dmiStartAddress) {
      if (slaveStartAddress < dmiEndAddress) {
        dmiPtr += slaveStartAddress - dmiStartAddress;
        dmiStartAddress = slaveStartAddress;
      }
    }
    if (dmiEndAddress > slaveEndAddress) {
      if (slaveEndAddress > dmiStartAddress)
        dmiEndAddress = slaveEndAddress;
    }
  }
  // add the offset if from vmap parameter
  
  dmiStartAddress += (offset);
  dmiEndAddress += (offset);
}

void axi_bus_base1_pv::invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  config::uint64 startAddress;
  config::uint64 endAddress;
  bool substractBaseAddress;  
  decoder->getSlaveRange(master_index, startAddress, endAddress, substractBaseAddress);
  sc_dt::uint64 current_start_range = start_range;
  sc_dt::uint64 current_end_range = end_range;
  unsigned char* dmi_ptr = 0;
  clip_the_range(startAddress, current_start_range, current_end_range, dmi_ptr, master_index, 0);
  sc_dt::uint64 original_address = 0;
original_address = decoder->getOriginalAddress(bus_slave0_idx, current_start_range);
  invalidate_direct_mem_ptr(bus_slave0_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(bus_slave1_idx, current_start_range);
  invalidate_direct_mem_ptr(bus_slave1_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(h264_slave_idx, current_start_range);
  invalidate_direct_mem_ptr(h264_slave_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(lcd_slave_idx, current_start_range);
  invalidate_direct_mem_ptr(lcd_slave_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(jpeg_slave_idx, current_start_range);
  invalidate_direct_mem_ptr(jpeg_slave_idx, original_address, original_address + current_end_range - current_start_range);original_address = decoder->getOriginalAddress(io_slave_idx, current_start_range);
  invalidate_direct_mem_ptr(io_slave_idx, original_address, original_address + current_end_range - current_start_range);
}


void axi_bus_base1_pv::sram_master_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(sram_master_idx, start_range, end_range);
  }
void axi_bus_base1_pv::apb_master_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(apb_master_idx, start_range, end_range);
  }
void axi_bus_base1_pv::h264_master_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(h264_master_idx, start_range, end_range);
  }
void axi_bus_base1_pv::lcd_master_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(lcd_master_idx, start_range, end_range);
  }
void axi_bus_base1_pv::jpeg_master_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(jpeg_master_idx, start_range, end_range);
  }
void axi_bus_base1_pv::io_master_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(io_master_idx, start_range, end_range);
  }
void axi_bus_base1_pv::eth_slave_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(eth_slave_idx, start_range, end_range);
  }

void axi_bus_base1_pv::invalidate_direct_mem_ptr(unsigned target_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  switch(target_index) {
  case bus_slave0_idx :
    bus_slave0->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case bus_slave1_idx :
    bus_slave1->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case h264_slave_idx :
    h264_slave->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case lcd_slave_idx :
    lcd_slave->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case jpeg_slave_idx :
    jpeg_slave->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  case io_slave_idx :
    io_slave->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  }
}

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your axi_bus model.
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:46 PM, (user: mbradley)
//*>

#include "axi_bus_model.h"
#include "model_builder.h"

using namespace ::mb::utl::minmax;

axi_bus_machine_arch::axi_bus_machine_arch()
    : MachineArch(13, 0) {
        reset();
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: bus_slave0
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: bus_slave0, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__bus_slave0__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: bus_slave0, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__bus_slave0__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: bus_slave1
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: bus_slave1, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__bus_slave1__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: bus_slave1, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__bus_slave1__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: h264_slave
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: h264_slave, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__h264_slave__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: h264_slave, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__h264_slave__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: lcd_slave
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: lcd_slave, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__lcd_slave__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: lcd_slave, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__lcd_slave__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: sram_master
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: sram_master, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__sram_master__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: sram_master, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__sram_master__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: apb_master
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: apb_master, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__apb_master__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: apb_master, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__apb_master__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: h264_master
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: h264_master, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__h264_master__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: h264_master, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__h264_master__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: lcd_master
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: lcd_master, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__lcd_master__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: lcd_master, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__lcd_master__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: jpeg_master
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: jpeg_master, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_master__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: jpeg_master, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_master__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: io_master
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: io_master, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__io_master__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: io_master, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__io_master__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: jpeg_slave
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: jpeg_slave, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_slave__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: jpeg_slave, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__jpeg_slave__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: io_slave
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: io_slave, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__io_slave__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: io_slave, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__io_slave__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: eth_slave
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: eth_slave, transaction: WRITE
    //////
    
    void axi_bus_machine_arch::transaction_instance__eth_slave__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: eth_slave, transaction: READ
    //////
    
    void axi_bus_machine_arch::transaction_instance__eth_slave__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }

void axi_bus_machine_arch::startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime) {
  switch(portIndex) {
    case(0) : break;
    case(1) : break;
    case(2) : break;
    case(3) : break;
    case(4) : break;
    case(5) : break;
    case(6) : break;
    case(7) : break;
    case(8) : break;
    case(9) : break;
    case(10) : break;
    case(11) : break;
    case(12) : break;
    default: break;
  }
}
VariableBase* axi_bus_machine_arch::getVariableBasePtrByName(const char* name) {
  return NULL;
}
Register* axi_bus_machine_arch::getRegisterByName(const char* name) {
  return 0;
}
void axi_bus_machine_arch::reset() { 
    MachineArch::reset();
}
bool axi_bus_machine_arch::getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end) {
    switch(portIndex) {
        case(0) :   return false;
        case(1) :   return false;
        case(2) :   return false;
        case(3) :   return false;
        case(4) :   return false;
        case(5) :   return false;
        case(6) :   return false;
        case(7) :   return false;
        case(8) :   return false;
        case(9) :   return false;
        case(10) :   return false;
        case(11) :   return false;
        case(12) :   return false;
        default: break;
    }
    return false; 
}
void axi_bus_machine_arch::callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime) {
    switch(portIndex) {
        case(0) : { //port: bus_slave0
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__bus_slave0__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__bus_slave0__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(1) : { //port: bus_slave1
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__bus_slave1__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__bus_slave1__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(2) : { //port: h264_slave
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__h264_slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__h264_slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(3) : { //port: lcd_slave
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__lcd_slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__lcd_slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(4) : { //port: sram_master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__sram_master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__sram_master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(5) : { //port: apb_master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__apb_master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__apb_master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(6) : { //port: h264_master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__h264_master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__h264_master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(7) : { //port: lcd_master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__lcd_master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__lcd_master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(8) : { //port: jpeg_master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__jpeg_master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__jpeg_master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(9) : { //port: io_master
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__io_master__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__io_master__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(10) : { //port: jpeg_slave
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__jpeg_slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__jpeg_slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(11) : { //port: io_slave
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__io_slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__io_slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(12) : { //port: eth_slave
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__eth_slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: READ
                    this->transaction_instance__eth_slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        default: break;
    }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

#include "axi_bus_model.h"

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;

void axi_bus_t_base::createDecoder(void* userRunningModel) {
  long* portLayers = 0;
  long* readAddressLayers = 0;
  long* writeAddressLayers = 0;
  long* readDataLayers = 0;
  long* writeDataLayers = 0;
  long** mastersVmap = 0;
  if (isMultiChannel && layers && *layers == 0)
    Papoulis_ParseLayersFile(userRunningModel,
                             "bus_slave0: sram_master, apb_master, h264_master, lcd_master, jpeg_master, io_master, eth_slave; bus_slave1: sram_master, apb_master, h264_master, lcd_master, jpeg_master, io_master, eth_slave; h264_slave: sram_master, apb_master, h264_master, lcd_master, jpeg_master, io_master, eth_slave; lcd_slave: sram_master, apb_master, h264_master, lcd_master, jpeg_master, io_master, eth_slave; jpeg_slave: sram_master, apb_master, h264_master, lcd_master, jpeg_master, io_master, eth_slave; io_slave: sram_master, apb_master, h264_master, lcd_master, jpeg_master, io_master, eth_slave; ",
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);
    
  else
    Papoulis_ParseLayersFile(userRunningModel,
                             layers,
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);

  m_decoder = new esl::sc_sim::user_model::Decoder(7, mastersVmap, port_count, write_broadcast);
  if (!m_arbiter)
    m_arbiter = new esl::sc_sim::user_model::Arbiter(new esl::sc_sim::ArbiterScheme());
  m_arbiter->updateTables(port_count);
  m_arbiter->setDecoder(m_decoder);

  unsigned masterIndex = 0;
  for (unsigned u = 0; u < get_port_count(); u++)
    if (is_master(u)) {
      masterIndex = u;
      break;
    }

  m_decoder->insertPortName("bus_slave0");
  m_decoder->insertPortName("bus_slave1");
  m_decoder->insertPortName("h264_slave");
  m_decoder->insertPortName("lcd_slave");
  m_decoder->insertPortName("sram_master");
  m_decoder->insertPortName("apb_master");
  m_decoder->insertPortName("h264_master");
  m_decoder->insertPortName("lcd_master");
  m_decoder->insertPortName("jpeg_master");
  m_decoder->insertPortName("io_master");
  m_decoder->insertPortName("jpeg_slave");
  m_decoder->insertPortName("io_slave");
  m_decoder->insertPortName("eth_slave");
  
  std::vector<esl::sc_sim::SystemCChannel*>* channels = getReadAndWriteChannels(masterIndex);
  if (channels->size() == 1) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_IGNORE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  } else if (channels->size() == 2) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_READ_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
    channel = (*channels)[1];
    protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_WRITE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  }

  if(isMultiChannel)
    m_arbiter->setMultiChannel();
  unsigned* pendings = new unsigned[port_count];
  pendings[bus_slave0] = Papoulis_GetPending((void*)getUserRunningModel(), bus_slave0);
  pendings[bus_slave1] = Papoulis_GetPending((void*)getUserRunningModel(), bus_slave1);
  pendings[h264_slave] = Papoulis_GetPending((void*)getUserRunningModel(), h264_slave);
  pendings[lcd_slave] = Papoulis_GetPending((void*)getUserRunningModel(), lcd_slave);
  pendings[sram_master] = Papoulis_GetPending((void*)getUserRunningModel(), sram_master);
  pendings[apb_master] = Papoulis_GetPending((void*)getUserRunningModel(), apb_master);
  pendings[h264_master] = Papoulis_GetPending((void*)getUserRunningModel(), h264_master);
  pendings[lcd_master] = Papoulis_GetPending((void*)getUserRunningModel(), lcd_master);
  pendings[jpeg_master] = Papoulis_GetPending((void*)getUserRunningModel(), jpeg_master);
  pendings[io_master] = Papoulis_GetPending((void*)getUserRunningModel(), io_master);
  pendings[jpeg_slave] = Papoulis_GetPending((void*)getUserRunningModel(), jpeg_slave);
  pendings[io_slave] = Papoulis_GetPending((void*)getUserRunningModel(), io_slave);
  pendings[eth_slave] = Papoulis_GetPending((void*)getUserRunningModel(), eth_slave);
  m_arbiter->setPendings(pendings);
  sc_dt::uint64 base_address = 0;
  if (sram_master_base_address == 0xffffffff && 
      sizeof(sram_master_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = sram_master_base_address;
  m_decoder->registerSlavePort(sram_master,
                               base_address,
                               sram_master_size,
                               sram_master_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(sram_master,
                                            "sram_master",
                                            sram_master_additional_ranges,
                                            sram_master_subtract_base_address);
  m_decoder->setSecure(sram_master, sram_master_secure, config::uint32_max);

  if (apb_master_base_address == 0xffffffff && 
      sizeof(apb_master_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = apb_master_base_address;
  m_decoder->registerSlavePort(apb_master,
                               base_address,
                               apb_master_size,
                               apb_master_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(apb_master,
                                            "apb_master",
                                            apb_master_additional_ranges,
                                            apb_master_subtract_base_address);
  m_decoder->setSecure(apb_master, apb_master_secure, config::uint32_max);

  if (h264_master_base_address == 0xffffffff && 
      sizeof(h264_master_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = h264_master_base_address;
  m_decoder->registerSlavePort(h264_master,
                               base_address,
                               h264_master_size,
                               h264_master_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(h264_master,
                                            "h264_master",
                                            h264_master_additional_ranges,
                                            h264_master_subtract_base_address);
  m_decoder->setSecure(h264_master, h264_master_secure, config::uint32_max);

  if (lcd_master_base_address == 0xffffffff && 
      sizeof(lcd_master_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = lcd_master_base_address;
  m_decoder->registerSlavePort(lcd_master,
                               base_address,
                               lcd_master_size,
                               lcd_master_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(lcd_master,
                                            "lcd_master",
                                            lcd_master_additional_ranges,
                                            lcd_master_subtract_base_address);
  m_decoder->setSecure(lcd_master, lcd_master_secure, config::uint32_max);

  if (jpeg_master_base_address == 0xffffffff && 
      sizeof(jpeg_master_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = jpeg_master_base_address;
  m_decoder->registerSlavePort(jpeg_master,
                               base_address,
                               jpeg_master_size,
                               jpeg_master_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(jpeg_master,
                                            "jpeg_master",
                                            jpeg_master_additional_ranges,
                                            jpeg_master_subtract_base_address);
  m_decoder->setSecure(jpeg_master, jpeg_master_secure, config::uint32_max);

  if (io_master_base_address == 0xffffffff && 
      sizeof(io_master_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = io_master_base_address;
  m_decoder->registerSlavePort(io_master,
                               base_address,
                               io_master_size,
                               io_master_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(io_master,
                                            "io_master",
                                            io_master_additional_ranges,
                                            io_master_subtract_base_address);
  m_decoder->setSecure(io_master, io_master_secure, config::uint32_max);

  if (eth_slave_base_address == 0xffffffff && 
      sizeof(eth_slave_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = eth_slave_base_address;
  m_decoder->registerSlavePort(eth_slave,
                               base_address,
                               eth_slave_size,
                               eth_slave_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(eth_slave,
                                            "eth_slave",
                                            eth_slave_additional_ranges,
                                            eth_slave_subtract_base_address);
  m_decoder->setSecure(eth_slave, eth_slave_secure, config::uint32_max);

  m_decoder->registerPortPriorityAndData(bus_slave0, bus_slave0_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(sram_master, sram_master_priority, (void*)0);
  m_decoder->parseVmapString(bus_slave0, bus_slave0_vmap, "bus_slave0_vmap");
  m_decoder->registerPortPriorityAndData(bus_slave1, bus_slave1_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(apb_master, apb_master_priority, (void*)0);
  m_decoder->parseVmapString(bus_slave1, bus_slave1_vmap, "bus_slave1_vmap");
  m_decoder->registerPortPriorityAndData(h264_slave, h264_slave_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(h264_master, h264_master_priority, (void*)0);
  m_decoder->parseVmapString(h264_slave, h264_slave_vmap, "h264_slave_vmap");
  m_decoder->registerPortPriorityAndData(lcd_slave, lcd_slave_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(lcd_master, lcd_master_priority, (void*)0);
  m_decoder->parseVmapString(lcd_slave, lcd_slave_vmap, "lcd_slave_vmap");
  m_decoder->registerPortPriorityAndData(jpeg_slave, jpeg_slave_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(jpeg_master, jpeg_master_priority, (void*)0);
  m_decoder->parseVmapString(jpeg_slave, jpeg_slave_vmap, "jpeg_slave_vmap");
  m_decoder->registerPortPriorityAndData(io_slave, io_slave_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(io_master, io_master_priority, (void*)0);
  m_decoder->parseVmapString(io_slave, io_slave_vmap, "io_slave_vmap");
  m_decoder->registerPortPriorityAndData(io_slave, io_slave_priority, (void*)0);
  m_decoder->registerPortPriorityAndData(eth_slave, eth_slave_priority, (void*)0);
  m_decoder->parseVmapString(io_slave, io_slave_vmap, "io_slave_vmap");
  m_decoder->checkConsistency(name());
  long portCount = 7 + 6;
  m_arbiter->generateLayerTable(portCount, portLayers, readAddressLayers, writeAddressLayers, readDataLayers, writeDataLayers);
}

void axi_bus_t_base::schedule_axi_READ
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long ARADDR, long* RDATA, long ARSIZE, long block_size, long ARBURST, long ARLEN, long ARLOCK) {
  scheduleGenericTransaction(portIndex,
                             0,
                             ARADDR,
                             (unsigned char*)RDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}
void axi_bus_t_base::schedule_axi_WRITE
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long TR_ID, long AWADDR, long* WDATA, long AWSIZE, long block_size, long AWBURST, long AWLEN, long AWLOCK) {
  scheduleGenericTransaction(portIndex,
                             1,
                             AWADDR,
                             (unsigned char*)WDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

axi_bus_t_base::axi_bus_t_base(sc_module_name& module_name, long simulation,
                                           esl::sc_sim::user_model::Arbiter* arbiter) :
  papoulis::PapoulisBusBaseModel(module_name, arbiter, 1, 0),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(axi_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(layers, ""),
  SD_INITIALIZE_PARAMETER(slave_sets, ""),
  SD_INITIALIZE_PARAMETER(write_broadcast, 0),
  SD_INITIALIZE_PARAMETER(bus_slave0_priority, 0),
  SD_INITIALIZE_PARAMETER(bus_slave0_vmap, ""),
  SD_INITIALIZE_PARAMETER(bus_slave1_priority, 0),
  SD_INITIALIZE_PARAMETER(bus_slave1_vmap, ""),
  SD_INITIALIZE_PARAMETER(h264_slave_priority, 0),
  SD_INITIALIZE_PARAMETER(h264_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER(lcd_slave_priority, 0),
  SD_INITIALIZE_PARAMETER(lcd_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER(sram_master_priority, 0),
  SD_INITIALIZE_PARAMETER(sram_master_base_address, 0),
  SD_INITIALIZE_PARAMETER(sram_master_size, 0x10000000),
  SD_INITIALIZE_PARAMETER(sram_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(sram_master_secure, 0),
  SD_INITIALIZE_PARAMETER(sram_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(sram_master_latency, 0),
  SD_INITIALIZE_PARAMETER(apb_master_priority, 0),
  SD_INITIALIZE_PARAMETER(apb_master_base_address, 0x40000000),
  SD_INITIALIZE_PARAMETER(apb_master_size, 0x10000000),
  SD_INITIALIZE_PARAMETER(apb_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(apb_master_secure, 0),
  SD_INITIALIZE_PARAMETER(apb_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(apb_master_latency, 0),
  SD_INITIALIZE_PARAMETER(h264_master_priority, 0),
  SD_INITIALIZE_PARAMETER(h264_master_base_address, 0x14004000),
  SD_INITIALIZE_PARAMETER(h264_master_size, 0x1000),
  SD_INITIALIZE_PARAMETER(h264_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(h264_master_secure, 0),
  SD_INITIALIZE_PARAMETER(h264_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(h264_master_latency, 0),
  SD_INITIALIZE_PARAMETER(lcd_master_priority, 0),
  SD_INITIALIZE_PARAMETER(lcd_master_base_address, 0x14004000),
  SD_INITIALIZE_PARAMETER(lcd_master_size, 0x1000),
  SD_INITIALIZE_PARAMETER(lcd_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(lcd_master_secure, 0),
  SD_INITIALIZE_PARAMETER(lcd_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(lcd_master_latency, 0),
  SD_INITIALIZE_PARAMETER(jpeg_master_priority, 0),
  SD_INITIALIZE_PARAMETER(jpeg_master_base_address, 0x10000000),
  SD_INITIALIZE_PARAMETER(jpeg_master_size, 0x20),
  SD_INITIALIZE_PARAMETER(jpeg_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(jpeg_master_secure, 0),
  SD_INITIALIZE_PARAMETER(jpeg_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(jpeg_master_latency, 0),
  SD_INITIALIZE_PARAMETER(io_master_priority, 0),
  SD_INITIALIZE_PARAMETER(io_master_base_address, 0x10000020),
  SD_INITIALIZE_PARAMETER(io_master_size, 0x20),
  SD_INITIALIZE_PARAMETER(io_master_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(io_master_secure, 0),
  SD_INITIALIZE_PARAMETER(io_master_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(io_master_latency, 0),
  SD_INITIALIZE_PARAMETER(jpeg_slave_priority, 0),
  SD_INITIALIZE_PARAMETER(jpeg_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER(io_slave_priority, 0),
  SD_INITIALIZE_PARAMETER(io_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER(eth_slave_priority, 0),
  SD_INITIALIZE_PARAMETER(eth_slave_base_address, 0x14005000),
  SD_INITIALIZE_PARAMETER(eth_slave_size, 0x10),
  SD_INITIALIZE_PARAMETER(eth_slave_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(eth_slave_secure, 0),
  SD_INITIALIZE_PARAMETER(eth_slave_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(eth_slave_latency, 0),
        m_simulation(simulation), m_machine_arch(new axi_bus_machine_arch()), m_current_request(0)
{
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  fix_clock_parameter(axi_clock, "axi_clock");
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[bus_slave0].port_name = "bus_slave0";
  separate_read_channel = true;
  port_descriptions[bus_slave0].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[bus_slave0].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[bus_slave0].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[bus_slave0].is_master_port = 0;
  port_descriptions[bus_slave0].is_signal_port = 0;
  port_descriptions[bus_slave0].port_width = ((64 + 7) >> 3);
  port_descriptions[bus_slave0].port_width_in_bits = 64;
  port_descriptions[bus_slave0].protocol_name = "axi";
  port_descriptions[bus_slave0].ipxactBusDef.vendor = "amba.com";
  port_descriptions[bus_slave0].ipxactBusDef.library = "AMBA3";
  port_descriptions[bus_slave0].ipxactBusDef.name = "AXI";
  port_descriptions[bus_slave0].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[bus_slave0].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[bus_slave0].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[bus_slave0].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[bus_slave0].ipxactAbstrDef.version = "1.0";
  port_descriptions[bus_slave0].port_must_bind = 0;
  port_descriptions[bus_slave0].params_count = 8;
  port_descriptions[bus_slave0].pending = 1;
  port_descriptions[bus_slave0].read_data_queue_size = 0;
  port_descriptions[bus_slave0].write_data_queue_size = 0;
  port_descriptions[bus_slave0].clock = axi_clock;
  port_descriptions[bus_slave0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[bus_slave0].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[bus_slave0].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[bus_slave0].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[bus_slave0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[bus_slave0].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[bus_slave0].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[bus_slave0].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[bus_slave1].port_name = "bus_slave1";
  separate_read_channel = true;
  port_descriptions[bus_slave1].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[bus_slave1].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[bus_slave1].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[bus_slave1].is_master_port = 0;
  port_descriptions[bus_slave1].is_signal_port = 0;
  port_descriptions[bus_slave1].port_width = ((64 + 7) >> 3);
  port_descriptions[bus_slave1].port_width_in_bits = 64;
  port_descriptions[bus_slave1].protocol_name = "axi";
  port_descriptions[bus_slave1].ipxactBusDef.vendor = "amba.com";
  port_descriptions[bus_slave1].ipxactBusDef.library = "AMBA3";
  port_descriptions[bus_slave1].ipxactBusDef.name = "AXI";
  port_descriptions[bus_slave1].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[bus_slave1].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[bus_slave1].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[bus_slave1].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[bus_slave1].ipxactAbstrDef.version = "1.0";
  port_descriptions[bus_slave1].port_must_bind = 0;
  port_descriptions[bus_slave1].params_count = 8;
  port_descriptions[bus_slave1].pending = 1;
  port_descriptions[bus_slave1].read_data_queue_size = 0;
  port_descriptions[bus_slave1].write_data_queue_size = 0;
  port_descriptions[bus_slave1].clock = axi_clock;
  port_descriptions[bus_slave1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[bus_slave1].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[bus_slave1].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[bus_slave1].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[bus_slave1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[bus_slave1].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[bus_slave1].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[bus_slave1].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[h264_slave].port_name = "h264_slave";
  separate_read_channel = true;
  port_descriptions[h264_slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[h264_slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[h264_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[h264_slave].is_master_port = 0;
  port_descriptions[h264_slave].is_signal_port = 0;
  port_descriptions[h264_slave].port_width = ((64 + 7) >> 3);
  port_descriptions[h264_slave].port_width_in_bits = 64;
  port_descriptions[h264_slave].protocol_name = "axi";
  port_descriptions[h264_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[h264_slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[h264_slave].ipxactBusDef.name = "AXI";
  port_descriptions[h264_slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[h264_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[h264_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[h264_slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[h264_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[h264_slave].port_must_bind = 0;
  port_descriptions[h264_slave].params_count = 8;
  port_descriptions[h264_slave].pending = 1;
  port_descriptions[h264_slave].read_data_queue_size = 0;
  port_descriptions[h264_slave].write_data_queue_size = 0;
  port_descriptions[h264_slave].clock = axi_clock;
  port_descriptions[h264_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[h264_slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[h264_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[h264_slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[h264_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[h264_slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[h264_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[h264_slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[lcd_slave].port_name = "lcd_slave";
  separate_read_channel = true;
  port_descriptions[lcd_slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[lcd_slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[lcd_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[lcd_slave].is_master_port = 0;
  port_descriptions[lcd_slave].is_signal_port = 0;
  port_descriptions[lcd_slave].port_width = ((32 + 7) >> 3);
  port_descriptions[lcd_slave].port_width_in_bits = 32;
  port_descriptions[lcd_slave].protocol_name = "axi";
  port_descriptions[lcd_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[lcd_slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[lcd_slave].ipxactBusDef.name = "AXI";
  port_descriptions[lcd_slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[lcd_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[lcd_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[lcd_slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[lcd_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[lcd_slave].port_must_bind = 0;
  port_descriptions[lcd_slave].params_count = 8;
  port_descriptions[lcd_slave].pending = 1;
  port_descriptions[lcd_slave].read_data_queue_size = 0;
  port_descriptions[lcd_slave].write_data_queue_size = 0;
  port_descriptions[lcd_slave].clock = axi_clock;
  port_descriptions[lcd_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[lcd_slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[lcd_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[lcd_slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[lcd_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[lcd_slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[lcd_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[lcd_slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[sram_master].port_name = "sram_master";
  separate_read_channel = true;
  port_descriptions[sram_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[sram_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[sram_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[sram_master].is_master_port = 1;
  port_descriptions[sram_master].is_signal_port = 0;
  port_descriptions[sram_master].port_width = ((64 + 7) >> 3);
  port_descriptions[sram_master].port_width_in_bits = 64;
  port_descriptions[sram_master].protocol_name = "axi";
  port_descriptions[sram_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[sram_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[sram_master].ipxactBusDef.name = "AXI";
  port_descriptions[sram_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[sram_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[sram_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[sram_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[sram_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[sram_master].port_must_bind = 0;
  port_descriptions[sram_master].params_count = 8;
  port_descriptions[sram_master].pending = 1;
  port_descriptions[sram_master].read_data_queue_size = 0;
  port_descriptions[sram_master].write_data_queue_size = 0;
  port_descriptions[sram_master].clock = axi_clock;
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[sram_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[sram_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[apb_master].port_name = "apb_master";
  separate_read_channel = true;
  port_descriptions[apb_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[apb_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[apb_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[apb_master].is_master_port = 1;
  port_descriptions[apb_master].is_signal_port = 0;
  port_descriptions[apb_master].port_width = ((64 + 7) >> 3);
  port_descriptions[apb_master].port_width_in_bits = 64;
  port_descriptions[apb_master].protocol_name = "axi";
  port_descriptions[apb_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[apb_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[apb_master].ipxactBusDef.name = "AXI";
  port_descriptions[apb_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[apb_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[apb_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[apb_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[apb_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[apb_master].port_must_bind = 0;
  port_descriptions[apb_master].params_count = 8;
  port_descriptions[apb_master].pending = 1;
  port_descriptions[apb_master].read_data_queue_size = 0;
  port_descriptions[apb_master].write_data_queue_size = 0;
  port_descriptions[apb_master].clock = axi_clock;
  port_descriptions[apb_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[apb_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[apb_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[apb_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[apb_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[apb_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[apb_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[apb_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[h264_master].port_name = "h264_master";
  separate_read_channel = true;
  port_descriptions[h264_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[h264_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[h264_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[h264_master].is_master_port = 1;
  port_descriptions[h264_master].is_signal_port = 0;
  port_descriptions[h264_master].port_width = ((64 + 7) >> 3);
  port_descriptions[h264_master].port_width_in_bits = 64;
  port_descriptions[h264_master].protocol_name = "axi";
  port_descriptions[h264_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[h264_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[h264_master].ipxactBusDef.name = "AXI";
  port_descriptions[h264_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[h264_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[h264_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[h264_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[h264_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[h264_master].port_must_bind = 0;
  port_descriptions[h264_master].params_count = 8;
  port_descriptions[h264_master].pending = 1;
  port_descriptions[h264_master].read_data_queue_size = 0;
  port_descriptions[h264_master].write_data_queue_size = 0;
  port_descriptions[h264_master].clock = axi_clock;
  port_descriptions[h264_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[h264_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[h264_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[h264_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[h264_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[h264_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[h264_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[h264_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[lcd_master].port_name = "lcd_master";
  separate_read_channel = true;
  port_descriptions[lcd_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[lcd_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[lcd_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[lcd_master].is_master_port = 1;
  port_descriptions[lcd_master].is_signal_port = 0;
  port_descriptions[lcd_master].port_width = ((32 + 7) >> 3);
  port_descriptions[lcd_master].port_width_in_bits = 32;
  port_descriptions[lcd_master].protocol_name = "axi";
  port_descriptions[lcd_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[lcd_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[lcd_master].ipxactBusDef.name = "AXI";
  port_descriptions[lcd_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[lcd_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[lcd_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[lcd_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[lcd_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[lcd_master].port_must_bind = 0;
  port_descriptions[lcd_master].params_count = 8;
  port_descriptions[lcd_master].pending = 1;
  port_descriptions[lcd_master].read_data_queue_size = 0;
  port_descriptions[lcd_master].write_data_queue_size = 0;
  port_descriptions[lcd_master].clock = axi_clock;
  port_descriptions[lcd_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[lcd_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[lcd_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[lcd_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[lcd_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[lcd_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[lcd_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[lcd_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[jpeg_master].port_name = "jpeg_master";
  separate_read_channel = true;
  port_descriptions[jpeg_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[jpeg_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[jpeg_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[jpeg_master].is_master_port = 1;
  port_descriptions[jpeg_master].is_signal_port = 0;
  port_descriptions[jpeg_master].port_width = ((32 + 7) >> 3);
  port_descriptions[jpeg_master].port_width_in_bits = 32;
  port_descriptions[jpeg_master].protocol_name = "axi";
  port_descriptions[jpeg_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[jpeg_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[jpeg_master].ipxactBusDef.name = "AXI";
  port_descriptions[jpeg_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[jpeg_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[jpeg_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[jpeg_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[jpeg_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[jpeg_master].port_must_bind = 0;
  port_descriptions[jpeg_master].params_count = 8;
  port_descriptions[jpeg_master].pending = 1;
  port_descriptions[jpeg_master].read_data_queue_size = 0;
  port_descriptions[jpeg_master].write_data_queue_size = 0;
  port_descriptions[jpeg_master].clock = axi_clock;
  port_descriptions[jpeg_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[jpeg_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[jpeg_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[jpeg_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[jpeg_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[jpeg_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[jpeg_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[jpeg_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[io_master].port_name = "io_master";
  separate_read_channel = true;
  port_descriptions[io_master].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[io_master].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[io_master].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[io_master].is_master_port = 1;
  port_descriptions[io_master].is_signal_port = 0;
  port_descriptions[io_master].port_width = ((32 + 7) >> 3);
  port_descriptions[io_master].port_width_in_bits = 32;
  port_descriptions[io_master].protocol_name = "axi";
  port_descriptions[io_master].ipxactBusDef.vendor = "amba.com";
  port_descriptions[io_master].ipxactBusDef.library = "AMBA3";
  port_descriptions[io_master].ipxactBusDef.name = "AXI";
  port_descriptions[io_master].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[io_master].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[io_master].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[io_master].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[io_master].ipxactAbstrDef.version = "1.0";
  port_descriptions[io_master].port_must_bind = 0;
  port_descriptions[io_master].params_count = 8;
  port_descriptions[io_master].pending = 1;
  port_descriptions[io_master].read_data_queue_size = 0;
  port_descriptions[io_master].write_data_queue_size = 0;
  port_descriptions[io_master].clock = axi_clock;
  port_descriptions[io_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[io_master].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[io_master].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[io_master].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[io_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[io_master].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[io_master].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[io_master].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[jpeg_slave].port_name = "jpeg_slave";
  separate_read_channel = true;
  port_descriptions[jpeg_slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[jpeg_slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[jpeg_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[jpeg_slave].is_master_port = 0;
  port_descriptions[jpeg_slave].is_signal_port = 0;
  port_descriptions[jpeg_slave].port_width = ((32 + 7) >> 3);
  port_descriptions[jpeg_slave].port_width_in_bits = 32;
  port_descriptions[jpeg_slave].protocol_name = "axi";
  port_descriptions[jpeg_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[jpeg_slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[jpeg_slave].ipxactBusDef.name = "AXI";
  port_descriptions[jpeg_slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[jpeg_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[jpeg_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[jpeg_slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[jpeg_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[jpeg_slave].port_must_bind = 0;
  port_descriptions[jpeg_slave].params_count = 8;
  port_descriptions[jpeg_slave].pending = 1;
  port_descriptions[jpeg_slave].read_data_queue_size = 0;
  port_descriptions[jpeg_slave].write_data_queue_size = 0;
  port_descriptions[jpeg_slave].clock = axi_clock;
  port_descriptions[jpeg_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[jpeg_slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[jpeg_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[jpeg_slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[jpeg_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[jpeg_slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[jpeg_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[jpeg_slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[io_slave].port_name = "io_slave";
  separate_read_channel = true;
  port_descriptions[io_slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[io_slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[io_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[io_slave].is_master_port = 0;
  port_descriptions[io_slave].is_signal_port = 0;
  port_descriptions[io_slave].port_width = ((32 + 7) >> 3);
  port_descriptions[io_slave].port_width_in_bits = 32;
  port_descriptions[io_slave].protocol_name = "axi";
  port_descriptions[io_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[io_slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[io_slave].ipxactBusDef.name = "AXI";
  port_descriptions[io_slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[io_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[io_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[io_slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[io_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[io_slave].port_must_bind = 0;
  port_descriptions[io_slave].params_count = 8;
  port_descriptions[io_slave].pending = 1;
  port_descriptions[io_slave].read_data_queue_size = 0;
  port_descriptions[io_slave].write_data_queue_size = 0;
  port_descriptions[io_slave].clock = axi_clock;
  port_descriptions[io_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[io_slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[io_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[io_slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  port_descriptions[io_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 0);
  port_descriptions[io_slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !1, 0);
  port_descriptions[io_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  port_descriptions[io_slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[eth_slave].port_name = "eth_slave";
  separate_read_channel = true;
  port_descriptions[eth_slave].port_kind = PortDescription::READ_CHANNEL_PORT;
  separate_write_channel = true;
  port_descriptions[eth_slave].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[eth_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[eth_slave].is_master_port = 1;
  port_descriptions[eth_slave].is_signal_port = 0;
  port_descriptions[eth_slave].port_width = ((32 + 7) >> 3);
  port_descriptions[eth_slave].port_width_in_bits = 32;
  port_descriptions[eth_slave].protocol_name = "axi";
  port_descriptions[eth_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[eth_slave].ipxactBusDef.library = "AMBA3";
  port_descriptions[eth_slave].ipxactBusDef.name = "AXI";
  port_descriptions[eth_slave].ipxactBusDef.version = "r1p0_5"; 
  port_descriptions[eth_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[eth_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[eth_slave].ipxactAbstrDef.name = "AXI_tlm20";
  port_descriptions[eth_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[eth_slave].port_must_bind = 0;
  port_descriptions[eth_slave].params_count = 8;
  port_descriptions[eth_slave].pending = 1;
  port_descriptions[eth_slave].read_data_queue_size = 0;
  port_descriptions[eth_slave].write_data_queue_size = 0;
  port_descriptions[eth_slave].clock = axi_clock;
  port_descriptions[eth_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[eth_slave].add_read_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[eth_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[eth_slave].add_read_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);
  port_descriptions[eth_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 0);
  port_descriptions[eth_slave].add_write_phase(tlm::tlm_phase(tlm::END_REQ), !0, 0);
  port_descriptions[eth_slave].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  port_descriptions[eth_slave].add_write_phase(tlm::tlm_phase(tlm::END_RESP), !1, 1);

  port_descriptions[bus_slave0].default_read_transaction_name = "READ";
  port_descriptions[bus_slave1].default_read_transaction_name = "READ";
  port_descriptions[h264_slave].default_read_transaction_name = "READ";
  port_descriptions[lcd_slave].default_read_transaction_name = "READ";
  port_descriptions[sram_master].default_read_transaction_name = "READ";
  port_descriptions[apb_master].default_read_transaction_name = "READ";
  port_descriptions[h264_master].default_read_transaction_name = "READ";
  port_descriptions[lcd_master].default_read_transaction_name = "READ";
  port_descriptions[jpeg_master].default_read_transaction_name = "READ";
  port_descriptions[io_master].default_read_transaction_name = "READ";
  port_descriptions[jpeg_slave].default_read_transaction_name = "READ";
  port_descriptions[io_slave].default_read_transaction_name = "READ";
  port_descriptions[eth_slave].default_read_transaction_name = "READ";

  port_descriptions[bus_slave0].default_write_transaction_name = "WRITE";
  port_descriptions[bus_slave1].default_write_transaction_name = "WRITE";
  port_descriptions[h264_slave].default_write_transaction_name = "WRITE";
  port_descriptions[lcd_slave].default_write_transaction_name = "WRITE";
  port_descriptions[sram_master].default_write_transaction_name = "WRITE";
  port_descriptions[apb_master].default_write_transaction_name = "WRITE";
  port_descriptions[h264_master].default_write_transaction_name = "WRITE";
  port_descriptions[lcd_master].default_write_transaction_name = "WRITE";
  port_descriptions[jpeg_master].default_write_transaction_name = "WRITE";
  port_descriptions[io_master].default_write_transaction_name = "WRITE";
  port_descriptions[jpeg_slave].default_write_transaction_name = "WRITE";
  port_descriptions[io_slave].default_write_transaction_name = "WRITE";
  port_descriptions[eth_slave].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);
  
  esl::tlm_sim::UserRunningModel* model = Papoulis_CreateUserRunningModel(name(),
                                                                          0,
                                                                          this,
                                                                          simulation,
                                                                          true,
                                                                          false);
  setUserRunningModel(model, false);
  createDecoder(model);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("axi_clock", "sc_core::sc_time", sdGetParameterAsConstString("axi_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("layers", "const char*", sdGetParameterAsConstString("layers"));
  registerParameter("slave_sets", "const char*", sdGetParameterAsConstString("slave_sets"));
  registerParameter("write_broadcast", "unsigned int", sdGetParameterAsConstString("write_broadcast"));
  registerParameter("bus_slave0_priority", "unsigned int", sdGetParameterAsConstString("bus_slave0_priority"));
  registerParameter("bus_slave0_vmap", "const char*", sdGetParameterAsConstString("bus_slave0_vmap"));
  registerParameter("bus_slave1_priority", "unsigned int", sdGetParameterAsConstString("bus_slave1_priority"));
  registerParameter("bus_slave1_vmap", "const char*", sdGetParameterAsConstString("bus_slave1_vmap"));
  registerParameter("h264_slave_priority", "unsigned int", sdGetParameterAsConstString("h264_slave_priority"));
  registerParameter("h264_slave_vmap", "const char*", sdGetParameterAsConstString("h264_slave_vmap"));
  registerParameter("lcd_slave_priority", "unsigned int", sdGetParameterAsConstString("lcd_slave_priority"));
  registerParameter("lcd_slave_vmap", "const char*", sdGetParameterAsConstString("lcd_slave_vmap"));
  registerParameter("sram_master_priority", "unsigned int", sdGetParameterAsConstString("sram_master_priority"));
  registerParameter("sram_master_base_address", "unsigned long long", sdGetParameterAsConstString("sram_master_base_address"));
  registerParameter("sram_master_size", "unsigned long long", sdGetParameterAsConstString("sram_master_size"));
  registerParameter("sram_master_subtract_base_address", "unsigned int", sdGetParameterAsConstString("sram_master_subtract_base_address"));
  registerParameter("sram_master_secure", "unsigned int", sdGetParameterAsConstString("sram_master_secure"));
  registerParameter("sram_master_additional_ranges", "const char*", sdGetParameterAsConstString("sram_master_additional_ranges"));
  registerParameter("sram_master_latency", "unsigned int", sdGetParameterAsConstString("sram_master_latency"));
  registerParameter("apb_master_priority", "unsigned int", sdGetParameterAsConstString("apb_master_priority"));
  registerParameter("apb_master_base_address", "unsigned long long", sdGetParameterAsConstString("apb_master_base_address"));
  registerParameter("apb_master_size", "unsigned long long", sdGetParameterAsConstString("apb_master_size"));
  registerParameter("apb_master_subtract_base_address", "unsigned int", sdGetParameterAsConstString("apb_master_subtract_base_address"));
  registerParameter("apb_master_secure", "unsigned int", sdGetParameterAsConstString("apb_master_secure"));
  registerParameter("apb_master_additional_ranges", "const char*", sdGetParameterAsConstString("apb_master_additional_ranges"));
  registerParameter("apb_master_latency", "unsigned int", sdGetParameterAsConstString("apb_master_latency"));
  registerParameter("h264_master_priority", "unsigned int", sdGetParameterAsConstString("h264_master_priority"));
  registerParameter("h264_master_base_address", "unsigned long long", sdGetParameterAsConstString("h264_master_base_address"));
  registerParameter("h264_master_size", "unsigned long long", sdGetParameterAsConstString("h264_master_size"));
  registerParameter("h264_master_subtract_base_address", "unsigned int", sdGetParameterAsConstString("h264_master_subtract_base_address"));
  registerParameter("h264_master_secure", "unsigned int", sdGetParameterAsConstString("h264_master_secure"));
  registerParameter("h264_master_additional_ranges", "const char*", sdGetParameterAsConstString("h264_master_additional_ranges"));
  registerParameter("h264_master_latency", "unsigned int", sdGetParameterAsConstString("h264_master_latency"));
  registerParameter("lcd_master_priority", "unsigned int", sdGetParameterAsConstString("lcd_master_priority"));
  registerParameter("lcd_master_base_address", "unsigned long long", sdGetParameterAsConstString("lcd_master_base_address"));
  registerParameter("lcd_master_size", "unsigned long long", sdGetParameterAsConstString("lcd_master_size"));
  registerParameter("lcd_master_subtract_base_address", "unsigned int", sdGetParameterAsConstString("lcd_master_subtract_base_address"));
  registerParameter("lcd_master_secure", "unsigned int", sdGetParameterAsConstString("lcd_master_secure"));
  registerParameter("lcd_master_additional_ranges", "const char*", sdGetParameterAsConstString("lcd_master_additional_ranges"));
  registerParameter("lcd_master_latency", "unsigned int", sdGetParameterAsConstString("lcd_master_latency"));
  registerParameter("jpeg_master_priority", "unsigned int", sdGetParameterAsConstString("jpeg_master_priority"));
  registerParameter("jpeg_master_base_address", "unsigned long long", sdGetParameterAsConstString("jpeg_master_base_address"));
  registerParameter("jpeg_master_size", "unsigned long long", sdGetParameterAsConstString("jpeg_master_size"));
  registerParameter("jpeg_master_subtract_base_address", "unsigned int", sdGetParameterAsConstString("jpeg_master_subtract_base_address"));
  registerParameter("jpeg_master_secure", "unsigned int", sdGetParameterAsConstString("jpeg_master_secure"));
  registerParameter("jpeg_master_additional_ranges", "const char*", sdGetParameterAsConstString("jpeg_master_additional_ranges"));
  registerParameter("jpeg_master_latency", "unsigned int", sdGetParameterAsConstString("jpeg_master_latency"));
  registerParameter("io_master_priority", "unsigned int", sdGetParameterAsConstString("io_master_priority"));
  registerParameter("io_master_base_address", "unsigned long long", sdGetParameterAsConstString("io_master_base_address"));
  registerParameter("io_master_size", "unsigned long long", sdGetParameterAsConstString("io_master_size"));
  registerParameter("io_master_subtract_base_address", "unsigned int", sdGetParameterAsConstString("io_master_subtract_base_address"));
  registerParameter("io_master_secure", "unsigned int", sdGetParameterAsConstString("io_master_secure"));
  registerParameter("io_master_additional_ranges", "const char*", sdGetParameterAsConstString("io_master_additional_ranges"));
  registerParameter("io_master_latency", "unsigned int", sdGetParameterAsConstString("io_master_latency"));
  registerParameter("jpeg_slave_priority", "unsigned int", sdGetParameterAsConstString("jpeg_slave_priority"));
  registerParameter("jpeg_slave_vmap", "const char*", sdGetParameterAsConstString("jpeg_slave_vmap"));
  registerParameter("io_slave_priority", "unsigned int", sdGetParameterAsConstString("io_slave_priority"));
  registerParameter("io_slave_vmap", "const char*", sdGetParameterAsConstString("io_slave_vmap"));
  registerParameter("eth_slave_priority", "unsigned int", sdGetParameterAsConstString("eth_slave_priority"));
  registerParameter("eth_slave_base_address", "unsigned long long", sdGetParameterAsConstString("eth_slave_base_address"));
  registerParameter("eth_slave_size", "unsigned long long", sdGetParameterAsConstString("eth_slave_size"));
  registerParameter("eth_slave_subtract_base_address", "unsigned int", sdGetParameterAsConstString("eth_slave_subtract_base_address"));
  registerParameter("eth_slave_secure", "unsigned int", sdGetParameterAsConstString("eth_slave_secure"));
  registerParameter("eth_slave_additional_ranges", "const char*", sdGetParameterAsConstString("eth_slave_additional_ranges"));
  registerParameter("eth_slave_latency", "unsigned int", sdGetParameterAsConstString("eth_slave_latency"));
  

  delay_policy* delay_policy_handle = 0;

  delay_policy_handle = new delay_policy(model,
                                         "bus_slave0",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "bus_slave1",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "h264_slave",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "lcd_slave",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "jpeg_slave",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(model,
                                         "io_slave",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  unsigned pipeline_policy_index = 0;
  pipeline_policy* pipeline_policy_handle = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "apb_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(apb_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "h264_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(h264_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "lcd_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(lcd_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "io_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(io_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave0";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "eth_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(eth_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "apb_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(apb_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "h264_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(h264_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "lcd_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(lcd_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "io_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(io_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave1";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "eth_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(eth_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "h264_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "h264_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "apb_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(apb_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "h264_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "h264_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(h264_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "h264_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "lcd_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(lcd_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "h264_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "h264_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "io_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(io_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "h264_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "eth_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(eth_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "lcd_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "lcd_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "apb_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(apb_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "lcd_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "h264_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(h264_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "lcd_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "lcd_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(lcd_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "lcd_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "lcd_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "io_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(io_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "lcd_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "eth_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(eth_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "apb_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(apb_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "h264_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(h264_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "lcd_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(lcd_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "io_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(io_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "jpeg_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "eth_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(eth_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "io_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "sram_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(sram_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "io_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "apb_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(apb_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "io_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "h264_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(h264_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "io_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "lcd_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(lcd_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "io_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "jpeg_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(jpeg_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "io_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "io_master";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(io_master_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "io_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "eth_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(eth_slave_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  set_user_pipeline_policies(user_pipeline_policy_count, user_pipeline_policy_descriptions);
  
  constant_global_power_policy* p = new constant_global_power_policy(model);
  
  
  
  set_global_power_policy(p);
}

void axi_bus_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;

  if (handle == m_pipeline_vector[0]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[1]) {
    handle->setLatency(apb_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[2]) {
    handle->setLatency(h264_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[3]) {
    handle->setLatency(lcd_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[4]) {
    handle->setLatency(jpeg_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[5]) {
    handle->setLatency(io_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[6]) {
    handle->setLatency(eth_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[7]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[8]) {
    handle->setLatency(apb_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[9]) {
    handle->setLatency(h264_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[10]) {
    handle->setLatency(lcd_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[11]) {
    handle->setLatency(jpeg_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[12]) {
    handle->setLatency(io_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[13]) {
    handle->setLatency(eth_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[14]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[15]) {
    handle->setLatency(apb_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[16]) {
    handle->setLatency(h264_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[17]) {
    handle->setLatency(lcd_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[18]) {
    handle->setLatency(jpeg_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[19]) {
    handle->setLatency(io_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[20]) {
    handle->setLatency(eth_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[21]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[22]) {
    handle->setLatency(apb_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[23]) {
    handle->setLatency(h264_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[24]) {
    handle->setLatency(lcd_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[25]) {
    handle->setLatency(jpeg_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[26]) {
    handle->setLatency(io_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[27]) {
    handle->setLatency(eth_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[28]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[29]) {
    handle->setLatency(apb_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[30]) {
    handle->setLatency(h264_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[31]) {
    handle->setLatency(lcd_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[32]) {
    handle->setLatency(jpeg_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[33]) {
    handle->setLatency(io_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[34]) {
    handle->setLatency(eth_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[35]) {
    handle->setLatency(sram_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[36]) {
    handle->setLatency(apb_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[37]) {
    handle->setLatency(h264_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[38]) {
    handle->setLatency(lcd_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[39]) {
    handle->setLatency(jpeg_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[40]) {
    handle->setLatency(io_master_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[41]) {
    handle->setLatency(eth_slave_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }

}

void axi_bus_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[1]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[2]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[3]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[4]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_delay_vector[5]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
}

void axi_bus_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}


void axi_bus_t_base::vista_trace(bool isStart, request_type* request, long portIndex, sc_dt::uint64 startTime) {
  
  sc_dt::uint64 local_params[8];
  for (unsigned u = 0; u < 8; u++)
    local_params[u] = 0;
  
  sc_dt::uint64 address = request->get_address();
  
  local_params[1] = address;
  
  local_params[4] = get_port_width(portIndex);
  sc_dt::uint64* parameters = local_params;
  long size = request->get_data_length();
  
  bool isWrite = request->is_write();
  m_current_request = request;
  if(isStart) {
    this->print_transaction(portIndex, isWrite, true, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->accept_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->accept_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    } else {
      if (is_master(portIndex)) {
        this->accept_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->accept_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    }
  } else {
    this->print_transaction(portIndex, isWrite, false, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->end_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->end_axi_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    } else {
      if (is_master(portIndex)) {
        this->end_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      } else {
        this->end_axi_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2],
           parameters[3],
           parameters[4],
           parameters[5],
           parameters[6],
           parameters[7]);
      }
    }
  }
  m_current_request = 0;
}

request_type* axi_bus_t_base::get_current_request() {
  return m_current_request;
}

unsigned axi_bus_t_base::get_layer(unsigned port_index) {
  if (is_slave(port_index))
    return m_arbiter->get_slave_layer(port_index);
  return m_arbiter->get_master_layer(port_index);
}

unsigned axi_bus_t_base::get_slave_port_index() {
  if (!m_current_request) {
    printf("ERROR: when calling get_slave_port_index in %s\n", name());
    return (unsigned)(-1);
  }
  return  m_arbiter->getMasterIndexByRequestId(m_current_request);
}

void axi_bus_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for axi_bus.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:46 PM, (user: mbradley)
//*>

#include "axi_bus_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "axi_bus_pv.h"




// Constructor
axi_bus_pvt::axi_bus_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    axi_bus_pvt_param_defaults(this->name()),
    sram_master("sram_master"),
    apb_master("apb_master"),
    h264_master("h264_master"),
    lcd_master("lcd_master"),
    jpeg_master("jpeg_master"),
    io_master("io_master"),
    eth_slave("eth_slave"),
    bus_slave0("bus_slave0"),
    bus_slave1("bus_slave1"),
    h264_slave("h264_slave"),
    lcd_slave("lcd_slave"),
    jpeg_slave("jpeg_slave"),
    io_slave("io_slave"), 
    sram_master_entry("unvisible_sram_master_entry"), 
    apb_master_entry("unvisible_apb_master_entry"), 
    h264_master_entry("unvisible_h264_master_entry"), 
    lcd_master_entry("unvisible_lcd_master_entry"), 
    jpeg_master_entry("unvisible_jpeg_master_entry"), 
    io_master_entry("unvisible_io_master_entry"), 
    eth_slave_entry("unvisible_eth_slave_entry"),
    bus_slave0_entry("unvisible_bus_slave0_entry"),
    bus_slave1_entry("unvisible_bus_slave1_entry"),
    h264_slave_entry("unvisible_h264_slave_entry"),
    lcd_slave_entry("unvisible_lcd_slave_entry"),
    jpeg_slave_entry("unvisible_jpeg_slave_entry"),
    io_slave_entry("unvisible_io_slave_entry"),
    m_sram_master_nb_connector(*this),
    m_apb_master_nb_connector(*this),
    m_h264_master_nb_connector(*this),
    m_lcd_master_nb_connector(*this),
    m_jpeg_master_nb_connector(*this),
    m_io_master_nb_connector(*this),
    m_eth_slave_nb_connector(*this),
    m_bus_slave0_nb_connector(*this),
    m_bus_slave1_nb_connector(*this),
    m_h264_slave_nb_connector(*this),
    m_lcd_slave_nb_connector(*this),
    m_jpeg_slave_nb_connector(*this),
    m_io_slave_nb_connector(*this)

{


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
}  


axi_bus_pvt::axi_bus_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time axi_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, const char* layers_init, const char* slave_sets_init, unsigned int write_broadcast_init, unsigned int bus_slave0_priority_init, const char* bus_slave0_vmap_init, unsigned int bus_slave1_priority_init, const char* bus_slave1_vmap_init, unsigned int h264_slave_priority_init, const char* h264_slave_vmap_init, unsigned int lcd_slave_priority_init, const char* lcd_slave_vmap_init, unsigned int sram_master_priority_init, unsigned long long sram_master_base_address_init, unsigned long long sram_master_size_init, unsigned int sram_master_subtract_base_address_init, unsigned int sram_master_secure_init, const char* sram_master_additional_ranges_init, unsigned int sram_master_latency_init, unsigned int apb_master_priority_init, unsigned long long apb_master_base_address_init, unsigned long long apb_master_size_init, unsigned int apb_master_subtract_base_address_init, unsigned int apb_master_secure_init, const char* apb_master_additional_ranges_init, unsigned int apb_master_latency_init, unsigned int h264_master_priority_init, unsigned long long h264_master_base_address_init, unsigned long long h264_master_size_init, unsigned int h264_master_subtract_base_address_init, unsigned int h264_master_secure_init, const char* h264_master_additional_ranges_init, unsigned int h264_master_latency_init, unsigned int lcd_master_priority_init, unsigned long long lcd_master_base_address_init, unsigned long long lcd_master_size_init, unsigned int lcd_master_subtract_base_address_init, unsigned int lcd_master_secure_init, const char* lcd_master_additional_ranges_init, unsigned int lcd_master_latency_init, unsigned int jpeg_master_priority_init, unsigned long long jpeg_master_base_address_init, unsigned long long jpeg_master_size_init, unsigned int jpeg_master_subtract_base_address_init, unsigned int jpeg_master_secure_init, const char* jpeg_master_additional_ranges_init, unsigned int jpeg_master_latency_init, unsigned int io_master_priority_init, unsigned long long io_master_base_address_init, unsigned long long io_master_size_init, unsigned int io_master_subtract_base_address_init, unsigned int io_master_secure_init, const char* io_master_additional_ranges_init, unsigned int io_master_latency_init, unsigned int jpeg_slave_priority_init, const char* jpeg_slave_vmap_init, unsigned int io_slave_priority_init, const char* io_slave_vmap_init, unsigned int eth_slave_priority_init, unsigned long long eth_slave_base_address_init, unsigned long long eth_slave_size_init, unsigned int eth_slave_subtract_base_address_init, unsigned int eth_slave_secure_init, const char* eth_slave_additional_ranges_init, unsigned int eth_slave_latency_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  axi_bus_pvt_param_defaults(this->name(), clock_init, axi_clock_init, nominal_voltage_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, layers_init, slave_sets_init, write_broadcast_init, bus_slave0_priority_init, bus_slave0_vmap_init, bus_slave1_priority_init, bus_slave1_vmap_init, h264_slave_priority_init, h264_slave_vmap_init, lcd_slave_priority_init, lcd_slave_vmap_init, sram_master_priority_init, sram_master_base_address_init, sram_master_size_init, sram_master_subtract_base_address_init, sram_master_secure_init, sram_master_additional_ranges_init, sram_master_latency_init, apb_master_priority_init, apb_master_base_address_init, apb_master_size_init, apb_master_subtract_base_address_init, apb_master_secure_init, apb_master_additional_ranges_init, apb_master_latency_init, h264_master_priority_init, h264_master_base_address_init, h264_master_size_init, h264_master_subtract_base_address_init, h264_master_secure_init, h264_master_additional_ranges_init, h264_master_latency_init, lcd_master_priority_init, lcd_master_base_address_init, lcd_master_size_init, lcd_master_subtract_base_address_init, lcd_master_secure_init, lcd_master_additional_ranges_init, lcd_master_latency_init, jpeg_master_priority_init, jpeg_master_base_address_init, jpeg_master_size_init, jpeg_master_subtract_base_address_init, jpeg_master_secure_init, jpeg_master_additional_ranges_init, jpeg_master_latency_init, io_master_priority_init, io_master_base_address_init, io_master_size_init, io_master_subtract_base_address_init, io_master_secure_init, io_master_additional_ranges_init, io_master_latency_init, jpeg_slave_priority_init, jpeg_slave_vmap_init, io_slave_priority_init, io_slave_vmap_init, eth_slave_priority_init, eth_slave_base_address_init, eth_slave_size_init, eth_slave_subtract_base_address_init, eth_slave_secure_init, eth_slave_additional_ranges_init, eth_slave_latency_init),
    sram_master("sram_master"),
    apb_master("apb_master"),
    h264_master("h264_master"),
    lcd_master("lcd_master"),
    jpeg_master("jpeg_master"),
    io_master("io_master"),
    eth_slave("eth_slave"),
    bus_slave0("bus_slave0"),
    bus_slave1("bus_slave1"),
    h264_slave("h264_slave"),
    lcd_slave("lcd_slave"),
    jpeg_slave("jpeg_slave"),
    io_slave("io_slave"), 
    sram_master_entry("unvisible_sram_master_entry"), 
    apb_master_entry("unvisible_apb_master_entry"), 
    h264_master_entry("unvisible_h264_master_entry"), 
    lcd_master_entry("unvisible_lcd_master_entry"), 
    jpeg_master_entry("unvisible_jpeg_master_entry"), 
    io_master_entry("unvisible_io_master_entry"), 
    eth_slave_entry("unvisible_eth_slave_entry"),
    bus_slave0_entry("unvisible_bus_slave0_entry"),
    bus_slave1_entry("unvisible_bus_slave1_entry"),
    h264_slave_entry("unvisible_h264_slave_entry"),
    lcd_slave_entry("unvisible_lcd_slave_entry"),
    jpeg_slave_entry("unvisible_jpeg_slave_entry"),
    io_slave_entry("unvisible_io_slave_entry"),
    m_sram_master_nb_connector(*this),
    m_apb_master_nb_connector(*this),
    m_h264_master_nb_connector(*this),
    m_lcd_master_nb_connector(*this),
    m_jpeg_master_nb_connector(*this),
    m_io_master_nb_connector(*this),
    m_eth_slave_nb_connector(*this),
    m_bus_slave0_nb_connector(*this),
    m_bus_slave1_nb_connector(*this),
    m_h264_slave_nb_connector(*this),
    m_lcd_slave_nb_connector(*this),
    m_jpeg_slave_nb_connector(*this),
    m_io_slave_nb_connector(*this)
{


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
} 

axi_bus_pvt::axi_bus_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  axi_bus_pvt_param_defaults(this->name(), change_parameters),
    sram_master("sram_master"),
    apb_master("apb_master"),
    h264_master("h264_master"),
    lcd_master("lcd_master"),
    jpeg_master("jpeg_master"),
    io_master("io_master"),
    eth_slave("eth_slave"),
    bus_slave0("bus_slave0"),
    bus_slave1("bus_slave1"),
    h264_slave("h264_slave"),
    lcd_slave("lcd_slave"),
    jpeg_slave("jpeg_slave"),
    io_slave("io_slave"), 
    sram_master_entry("unvisible_sram_master_entry"), 
    apb_master_entry("unvisible_apb_master_entry"), 
    h264_master_entry("unvisible_h264_master_entry"), 
    lcd_master_entry("unvisible_lcd_master_entry"), 
    jpeg_master_entry("unvisible_jpeg_master_entry"), 
    io_master_entry("unvisible_io_master_entry"), 
    eth_slave_entry("unvisible_eth_slave_entry"),
    bus_slave0_entry("unvisible_bus_slave0_entry"),
    bus_slave1_entry("unvisible_bus_slave1_entry"),
    h264_slave_entry("unvisible_h264_slave_entry"),
    lcd_slave_entry("unvisible_lcd_slave_entry"),
    jpeg_slave_entry("unvisible_jpeg_slave_entry"),
    io_slave_entry("unvisible_io_slave_entry"),
    m_sram_master_nb_connector(*this),
    m_apb_master_nb_connector(*this),
    m_h264_master_nb_connector(*this),
    m_lcd_master_nb_connector(*this),
    m_jpeg_master_nb_connector(*this),
    m_io_master_nb_connector(*this),
    m_eth_slave_nb_connector(*this),
    m_bus_slave0_nb_connector(*this),
    m_bus_slave1_nb_connector(*this),
    m_h264_slave_nb_connector(*this),
    m_lcd_slave_nb_connector(*this),
    m_jpeg_slave_nb_connector(*this),
    m_io_slave_nb_connector(*this)
{


  m_axi_bus_t = axi_bus_t_base::create_t("T", 1);
  m_axi_bus_pv = new axi_bus_pv("PV");
  bind();
} 

axi_bus_pvt::~axi_bus_pvt() {
  remove_pending_scenes();
  delete m_axi_bus_t; delete m_axi_bus_pv;
}




void axi_bus_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->sram_master.bind(sram_master_entry);
  getPV()->apb_master.bind(apb_master_entry);
  getPV()->h264_master.bind(h264_master_entry);
  getPV()->lcd_master.bind(lcd_master_entry);
  getPV()->jpeg_master.bind(jpeg_master_entry);
  getPV()->io_master.bind(io_master_entry);
  getPV()->eth_slave.bind(eth_slave_entry);
  bus_slave0_entry.bind(getPV()->bus_slave0);
  bus_slave1_entry.bind(getPV()->bus_slave1);
  h264_slave_entry.bind(getPV()->h264_slave);
  lcd_slave_entry.bind(getPV()->lcd_slave);
  jpeg_slave_entry.bind(getPV()->jpeg_slave);
  io_slave_entry.bind(getPV()->io_slave);   

  /* set callbacks on external and entry ports */ 

  bus_slave0.b_transport_cb.set(&bus_slave0_entry, &bus_slave0_entry_type::b_transport);
  bus_slave0.transport_dbg_cb.set(&bus_slave0_entry, &bus_slave0_entry_type::transport_dbg);
  bus_slave0.get_direct_mem_ptr_cb.set(&bus_slave0_entry, &bus_slave0_entry_type::get_direct_mem_ptr);

  bus_slave1.b_transport_cb.set(&bus_slave1_entry, &bus_slave1_entry_type::b_transport);
  bus_slave1.transport_dbg_cb.set(&bus_slave1_entry, &bus_slave1_entry_type::transport_dbg);
  bus_slave1.get_direct_mem_ptr_cb.set(&bus_slave1_entry, &bus_slave1_entry_type::get_direct_mem_ptr);

  h264_slave.b_transport_cb.set(&h264_slave_entry, &h264_slave_entry_type::b_transport);
  h264_slave.transport_dbg_cb.set(&h264_slave_entry, &h264_slave_entry_type::transport_dbg);
  h264_slave.get_direct_mem_ptr_cb.set(&h264_slave_entry, &h264_slave_entry_type::get_direct_mem_ptr);

  lcd_slave.b_transport_cb.set(&lcd_slave_entry, &lcd_slave_entry_type::b_transport);
  lcd_slave.transport_dbg_cb.set(&lcd_slave_entry, &lcd_slave_entry_type::transport_dbg);
  lcd_slave.get_direct_mem_ptr_cb.set(&lcd_slave_entry, &lcd_slave_entry_type::get_direct_mem_ptr);

  jpeg_slave.b_transport_cb.set(&jpeg_slave_entry, &jpeg_slave_entry_type::b_transport);
  jpeg_slave.transport_dbg_cb.set(&jpeg_slave_entry, &jpeg_slave_entry_type::transport_dbg);
  jpeg_slave.get_direct_mem_ptr_cb.set(&jpeg_slave_entry, &jpeg_slave_entry_type::get_direct_mem_ptr);

  io_slave.b_transport_cb.set(&io_slave_entry, &io_slave_entry_type::b_transport);
  io_slave.transport_dbg_cb.set(&io_slave_entry, &io_slave_entry_type::transport_dbg);
  io_slave.get_direct_mem_ptr_cb.set(&io_slave_entry, &io_slave_entry_type::get_direct_mem_ptr);

  sram_master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_sram_master);
  sram_master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_sram_master);
  sram_master_entry.get_direct_mem_ptr_cb.set(&sram_master, &sram_master_type::get_direct_mem_ptr);

  apb_master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_apb_master);
  apb_master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_apb_master);
  apb_master_entry.get_direct_mem_ptr_cb.set(&apb_master, &apb_master_type::get_direct_mem_ptr);

  h264_master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_h264_master);
  h264_master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_h264_master);
  h264_master_entry.get_direct_mem_ptr_cb.set(&h264_master, &h264_master_type::get_direct_mem_ptr);

  lcd_master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_lcd_master);
  lcd_master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_lcd_master);
  lcd_master_entry.get_direct_mem_ptr_cb.set(&lcd_master, &lcd_master_type::get_direct_mem_ptr);

  jpeg_master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_jpeg_master);
  jpeg_master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_jpeg_master);
  jpeg_master_entry.get_direct_mem_ptr_cb.set(&jpeg_master, &jpeg_master_type::get_direct_mem_ptr);

  io_master_entry.b_transport_cb.set(this, &self_type::b_transport_outside_io_master);
  io_master_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_io_master);
  io_master_entry.get_direct_mem_ptr_cb.set(&io_master, &io_master_type::get_direct_mem_ptr);

  eth_slave_entry.b_transport_cb.set(this, &self_type::b_transport_outside_eth_slave);
  eth_slave_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_eth_slave);
  eth_slave_entry.get_direct_mem_ptr_cb.set(&eth_slave, &eth_slave_type::get_direct_mem_ptr);

  
  /* connect t non blocking callbacks */

  sram_master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_sram_master);
  getT()->set_port_cb(4, &m_sram_master_nb_connector);

  apb_master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_apb_master);
  getT()->set_port_cb(5, &m_apb_master_nb_connector);

  h264_master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_h264_master);
  getT()->set_port_cb(6, &m_h264_master_nb_connector);

  lcd_master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_lcd_master);
  getT()->set_port_cb(7, &m_lcd_master_nb_connector);

  jpeg_master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_jpeg_master);
  getT()->set_port_cb(8, &m_jpeg_master_nb_connector);

  io_master.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_io_master);
  getT()->set_port_cb(9, &m_io_master_nb_connector);

  eth_slave.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_eth_slave);
  getT()->set_port_cb(12, &m_eth_slave_nb_connector);

  bus_slave0.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_bus_slave0);
  getT()->set_port_cb(0, &m_bus_slave0_nb_connector);

  bus_slave1.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_bus_slave1);
  getT()->set_port_cb(1, &m_bus_slave1_nb_connector);

  h264_slave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_h264_slave);
  getT()->set_port_cb(2, &m_h264_slave_nb_connector);

  lcd_slave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_lcd_slave);
  getT()->set_port_cb(3, &m_lcd_slave_nb_connector);

  jpeg_slave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_jpeg_slave);
  getT()->set_port_cb(10, &m_jpeg_slave_nb_connector);

  io_slave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_io_slave);
  getT()->set_port_cb(11, &m_io_slave_nb_connector);

  bus_slave0_entry.invalidate_direct_mem_ptr_cb.set(&bus_slave0, &bus_slave0_type::invalidate_direct_mem_ptr);

  bus_slave1_entry.invalidate_direct_mem_ptr_cb.set(&bus_slave1, &bus_slave1_type::invalidate_direct_mem_ptr);

  h264_slave_entry.invalidate_direct_mem_ptr_cb.set(&h264_slave, &h264_slave_type::invalidate_direct_mem_ptr);

  lcd_slave_entry.invalidate_direct_mem_ptr_cb.set(&lcd_slave, &lcd_slave_type::invalidate_direct_mem_ptr);

  jpeg_slave_entry.invalidate_direct_mem_ptr_cb.set(&jpeg_slave, &jpeg_slave_type::invalidate_direct_mem_ptr);

  io_slave_entry.invalidate_direct_mem_ptr_cb.set(&io_slave, &io_slave_type::invalidate_direct_mem_ptr);

  sram_master.invalidate_direct_mem_ptr_cb.set(&sram_master_entry, &sram_master_entry_type::invalidate_direct_mem_ptr);

  apb_master.invalidate_direct_mem_ptr_cb.set(&apb_master_entry, &apb_master_entry_type::invalidate_direct_mem_ptr);

  h264_master.invalidate_direct_mem_ptr_cb.set(&h264_master_entry, &h264_master_entry_type::invalidate_direct_mem_ptr);

  lcd_master.invalidate_direct_mem_ptr_cb.set(&lcd_master_entry, &lcd_master_entry_type::invalidate_direct_mem_ptr);

  jpeg_master.invalidate_direct_mem_ptr_cb.set(&jpeg_master_entry, &jpeg_master_entry_type::invalidate_direct_mem_ptr);

  io_master.invalidate_direct_mem_ptr_cb.set(&io_master_entry, &io_master_entry_type::invalidate_direct_mem_ptr);

  eth_slave.invalidate_direct_mem_ptr_cb.set(&eth_slave_entry, &eth_slave_entry_type::invalidate_direct_mem_ptr);

  /* check mb_event policies */
  m_axi_bus_t->check_mb_events();
}



void axi_bus_pvt::b_transport_outside_sram_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!sram_master.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << sram_master.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), sram_master.name());
    return;
  }
  sram_master.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_sram_master(tlm::tlm_generic_payload& p)
{
  if (!sram_master.get_interface()) {
     return 0;
  }
  return sram_master.transport_dbg(p);
  
}

void axi_bus_pvt::b_transport_outside_apb_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!apb_master.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << apb_master.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), apb_master.name());
    return;
  }
  apb_master.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_apb_master(tlm::tlm_generic_payload& p)
{
  if (!apb_master.get_interface()) {
     return 0;
  }
  return apb_master.transport_dbg(p);
  
}

void axi_bus_pvt::b_transport_outside_h264_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!h264_master.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << h264_master.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), h264_master.name());
    return;
  }
  h264_master.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_h264_master(tlm::tlm_generic_payload& p)
{
  if (!h264_master.get_interface()) {
     return 0;
  }
  return h264_master.transport_dbg(p);
  
}

void axi_bus_pvt::b_transport_outside_lcd_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!lcd_master.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << lcd_master.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), lcd_master.name());
    return;
  }
  lcd_master.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_lcd_master(tlm::tlm_generic_payload& p)
{
  if (!lcd_master.get_interface()) {
     return 0;
  }
  return lcd_master.transport_dbg(p);
  
}

void axi_bus_pvt::b_transport_outside_jpeg_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!jpeg_master.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << jpeg_master.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), jpeg_master.name());
    return;
  }
  jpeg_master.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_jpeg_master(tlm::tlm_generic_payload& p)
{
  if (!jpeg_master.get_interface()) {
     return 0;
  }
  return jpeg_master.transport_dbg(p);
  
}

void axi_bus_pvt::b_transport_outside_io_master(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!io_master.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << io_master.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), io_master.name());
    return;
  }
  io_master.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_io_master(tlm::tlm_generic_payload& p)
{
  if (!io_master.get_interface()) {
     return 0;
  }
  return io_master.transport_dbg(p);
  
}

void axi_bus_pvt::b_transport_outside_eth_slave(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!eth_slave.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << eth_slave.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), eth_slave.name());
    return;
  }
  eth_slave.b_transport(p, t);
  
} 

unsigned int axi_bus_pvt::transport_dbg_outside_eth_slave(tlm::tlm_generic_payload& p)
{
  if (!eth_slave.get_interface()) {
     return 0;
  }
  return eth_slave.transport_dbg(p);
  
}

