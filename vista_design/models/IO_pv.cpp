
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for IO.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.1.0
//* Generated on: Mar. 02, 2011 05:47:43 PM, (user: dvolinsk)
//* Automatically merged on: Feb. 22, 2012 07:00:34 PM, (user: zamir)
//* Automatically merged on: Aug. 16, 2012 12:58:05 PM, (user: araskin)
//*>



#include "IO_pv.h"
#include <iostream>

// Constructor
IO_pv::IO_pv(sc_module_name module_name) : IO_pv_base(module_name) {
  //cout << this->name () << " Constructor" << endl;
}

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a
// write event on one of the registers as defined in the Model Builder form.
// These functions are called before the write callbacks on the port.
/////////////////////////////////////////////////////////////////////////////////

// Write callback for upload register.
// The newValue has been already assigned to the upload register.
void IO_pv::cb_write_upload(unsigned int newValue) {

  if (newValue) {

    cout <<name()<<" @ "<<sc_time_stamp()<<" Reading host BMP file and putting into design memory " << bmpfilename << endl;

    bmp * bitmap = new bmp (bmpfilename);
    sc_assert (bitmap != NULL);

    // rows and columns must be divisible by 8, so make bigger if necessary
    if (bitmap->rows () % 8) {
      cout << "  ERROR: number of rows (image width) must be divisible by 8. please resize original bitmap image" << endl;
      exit (-1);
    }
    if (bitmap->columns () % 8) {
      cout << "  ERROR: number of columns (image height) must be divisible by 8. please resize original bitmap image" << endl;
      exit (-1);
    }

    unsigned int img_rows = bitmap->rows ();
    unsigned int img_columns = bitmap->columns ();

    // extract RGB arrays from BMP and re-order from bottom left to top left
    for (unsigned i = 0; i < img_rows; i++) {
      for (unsigned j = 0; j < img_columns; j++) {
        rgb [i*img_columns+j].r = bitmap->red (i, j);
        rgb [i*img_columns+j].g = bitmap->green (i, j);
        rgb [i*img_columns+j].b = bitmap->blue (i, j);
      }
    }

    unsigned int incr = 0;
    for (int row = 0; row < MAX_ROWS; row += 8)     {
      for (int column = 0; column < MAX_COLUMNS; column += 8) {
        for (uint2 block = 0; block <= 2; block++) {
          for (int i = 0; i < 8; i++)     {
            for (int j = 0; j < 8; j++) {
              int full_rgb_idx = (row+i) * MAX_COLUMNS + (column+j);
              rgb_stream [incr].r = rgb [full_rgb_idx].r;
              rgb_stream [incr].g = rgb [full_rgb_idx].g;
              rgb_stream [incr].b = rgb [full_rgb_idx].b;
              incr++;
            }
          }
        }
      }
    }

    // start_jpeg.write (true);
    for (int i = 0; i < 4 * 3 * MAX_ROWS * MAX_COLUMNS; i += 4) {
      mem1 [i] =   (unsigned char) rgb_stream [i/4].r;
      mem1 [i+1] = (unsigned char) rgb_stream [i/4].g;
      mem1 [i+2] = (unsigned char) rgb_stream [i/4].b;
    }

    //cout << name () << " Input Address=" << showbase << hex << inputaddr << ", Input Length=" << showbase << hex << inputlength << endl;
    master_write_dbg (inputaddr, mem1, 4 * 3 * MAX_ROWS * MAX_COLUMNS);

    #if 0
        // optionally test if data made it to memory correctly
        unsigned memError=0;
        master_read_dbg (inputaddr, memTest, 4 * 3 * MAX_ROWS * MAX_COLUMNS);
        cout <<name()<<" @ "<<sc_time_stamp()<<" Test BMP file in memory contents start addr="<< inputaddr <<endl;
        for (int i = 0; i < 4 * 3 * MAX_ROWS * MAX_COLUMNS; i++) {
            if (i < 4*3*256*64) {
                cout <<" "<< (unsigned)memTest[i];
                if (i%32 == 0 && i!=0)
                    cout <<endl<<"i= "<< i <<" ";
            }
            if (mem1[i] != memTest[i])
                memError++;
        }
        cout <<endl;
        if (memError)
            cout <<name()<<" @ "<<sc_time_stamp()<<" BMP mem test FAILED :-(\n";
        else
            cout <<name()<<" @ "<<sc_time_stamp()<<" BMP mem test PASSED !!\n";
    #endif

    delete bitmap;
  }
}

// Write callback for download register.
// The newValue has been already assigned to the download register.
void IO_pv::cb_write_download(unsigned int newValue) {

  if (newValue) {

    cout <<name()<<" @ "<<sc_time_stamp()<<" Writing JPG file to host "<< jpgfilename << endl;

    FILE * fp;
    // Instantiate JPEG_ENCODER Remote Registers
    JPEG_ENCODER_RemoteRegisters<> jpeg (master, 0x10000000);

    unsigned int outputlength = jpeg.m_outputlength;
    jpeg_data_len_t = (uint21) outputlength;
    //master_read_dbg( outputaddr, jpeg_data, outputlength);
    master_read( outputaddr, jpeg_data, outputlength);
    
    cout <<name()<<" @ "<<sc_time_stamp()<<" JPG data read from addr= "<< outputaddr <<endl;

    fp = fopen (jpgfilename, "wb");
    for (int k = 0; k < jpeg_data_len_t; k++) {
      fwrite (&jpeg_data[k], 1, 1, fp);
      if (k < 610) {
        printf ("0x%02X, ", jpeg_data[k]);
        if ((k+1) % 12 == 0) printf("\n");
      }
    }
    printf ("\n");
    fclose (fp);

  }

}

// Read callback for slave port.
// Returns true when successful.
bool IO_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
}

// Write callback for slave port.
// Returns true when successful.
bool IO_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
} 



unsigned IO_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

unsigned IO_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
} 

bool IO_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

