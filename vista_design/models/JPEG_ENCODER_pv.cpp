
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file contains the PV class for JPEG_ENCODER.
//* This is a template file: You may modify this file to implement the
//* behavior of your component.
//*
//* Model Builder version: 3.1.0
//* Generated on: Mar. 23, 2011 03:35:18 PM, (user: dvolinsk)
//* Automatically merged on: Feb. 22, 2012 07:00:35 PM, (user: zamir)
//*>


#include "address_map.h"

#include "JPEG_ENCODER_pv.h"
#include <iostream>

// Constructor
JPEG_ENCODER_pv::JPEG_ENCODER_pv(sc_module_name module_name) : JPEG_ENCODER_pv_base(module_name) {
  cout << this->name () << " Constructor" << endl;
  status = 0;
  irq.initialize (false);
  state_var = 0;
  jpeg_delay=1001000;
}

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a
// read event on one of the registers as defined in the Model Builder form.
// These functions are called before the read callbacks on the port.
/////////////////////////////////////////////////////////////////////////////////

// Read callback for status register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int JPEG_ENCODER_pv::cb_read_status() {
  return status;
}

// Read callback for start register.
// The value that this function returns, will be returned to the initiator port that requested its value.
unsigned int JPEG_ENCODER_pv::cb_read_start() {
  return start;
}

/////////////////////////////////////////////////////////////////////////////////
// Use these functions to define the behavior of your model when there is a
// write event on one of the registers as defined in the Model Builder form.
// These functions are called before the write callbacks on the port.
/////////////////////////////////////////////////////////////////////////////////

// Write callback for status register.
// The newValue has been already assigned to the status register.
void JPEG_ENCODER_pv::cb_write_status(unsigned int newValue) {
  if (newValue == 0) {
    irq.write (false);
  }
}


static void host_write_jpeg(unsigned char *data, unsigned int data_len, unsigned int rows)
{
  const char* jfile = "data.jpg";
  std::cout << "Writing JPEG image to host file '"<< jfile <<"'  output data length " << std::dec << data_len
            << " input rows " << rows << std::endl;
  FILE *f = fopen(jfile, "wb");
  if (f) {
    fwrite(data, sizeof(unsigned char), data_len, f);
    fclose(f);
  }
}

// Write callback for start register.
// The newValue has been already assigned to the start register.
void JPEG_ENCODER_pv::cb_write_start(unsigned int newValue) {
  cout << name () << " Function " << __FUNCTION__  << " newValue=" << newValue << endl;

  switch (newValue) {
    case 1 :
      // clock and voltage effects power calculations
      cout << name () << " FAST: Clock=1 ns, Voltage=1.0" << endl;
        set_internal_clock (1000);
        set_voltage (1.0);
      break;
    case 2 :
      cout << name () << " SLOW: Clock=10 NS, Voltage=" << voltage << endl;
        set_internal_clock (10000);
        set_voltage (voltage);
      break;
    default :
      break;
  }

  if (start == 0) {
    start_jpeg_temp.write(false); // ac_channel
    status = 0;
    irq.write(false);
  }
  else 
  {
    unsigned num_rows = inputlength / (4 * 3 *MAX_COLUMNS);
    if (num_rows > MAX_ROWS)
        num_rows = MAX_ROWS;

    memset(full_rgb_temp, '\0', sizeof(full_rgb_temp));
    unsigned char * data_temp = new unsigned char [4 * 3 * num_rows * MAX_COLUMNS];

    // get input rgb image
    master_read (inputaddr, data_temp, 4 * 3 * num_rows * MAX_COLUMNS);

    for (int i = 0; i < inputlength; i = i + 4) {
        rgb_t rgb_temp;
        rgb_temp.r = (uint8) data_temp [i];
        rgb_temp.g = (uint8) data_temp [i+1];
        rgb_temp.b = (uint8) data_temp [i+2];
        full_rgb_temp[i/4] = rgb_temp;
    }
    delete [] data_temp;
    start_jpeg_temp.write(true);
    state_var = 1;

    // the jpeg encoder algorithm
    jpeg_encoder (start_jpeg_temp, full_rgb_temp, done_jpeg_temp, jpeg_data_temp, jpeg_data_len_temp);

    // Here we hard code to show measured delay with fast clock (first time)
    // followed by measured delay with slow clock (2nd time).
    if( jpeg_delay == 2196900 )
        jpeg_delay=3198000;
    else
        jpeg_delay=2196900;

    state_var = 0;
    outputlength = (unsigned int) jpeg_data_len_temp;
 
    // write jpeg image
    master_write (outputaddr, jpeg_data_temp, (unsigned int) jpeg_data_len_temp);

    static bool done_temp;
    if (done_jpeg_temp.available (2))
        done_temp = done_jpeg_temp.read ();

    done_temp = done_jpeg_temp.read ();
    status = (unsigned int) done_temp;
    irq.write(true);

    // optionally write image to host
     // host_write_jpeg(jpeg_data_temp, jpeg_data_len_temp, num_rows);
  }

}

// Read callback for slave port.
// Returns true when successful.
bool JPEG_ENCODER_pv::slave_callback_read(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
}

// Write callback for slave port.
// Returns true when successful.
bool JPEG_ENCODER_pv::slave_callback_write(mb_address_type address, unsigned char* data, unsigned size) {
  return true;
}

unsigned JPEG_ENCODER_pv::slave_callback_read_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
}

unsigned JPEG_ENCODER_pv::slave_callback_write_dbg(mb_address_type address, unsigned char* data, unsigned size) {
  return 0;
}

bool JPEG_ENCODER_pv::slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
  return false;
}

