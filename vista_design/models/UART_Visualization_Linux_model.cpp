
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The UART_Visualization_Linux_pv will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:46 PM, (user: mbradley)
//*>


#include "UART_Visualization_Linux_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


UART_Visualization_Linux_pv_base::UART_Visualization_Linux_pv_base(sc_module_name& module_name) : 
  UART_Visualization_Linux_pv_base_mb_compatibility(module_name),
  UART_Visualization_Linux_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(UARTTXD),
  VISTA_MB_PV_INIT_MEMBER(UARTRXD),
  VISTA_MB_PV_INIT_MEMBER(nUARTRTS),
  VISTA_MB_PV_INIT_MEMBER(nUARTCTS),
  VISTA_MB_PV_INIT_MEMBER(UARTEN) {


  payload_on_stack = 0;
  payload_for_token = 0;

  nUARTCTS.register_cb(this, &self::cb_signal_nUARTCTS);
  UARTEN.register_cb(this, &self::cb_signal_UARTEN);
  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(UARTRXD);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(UARTTXD);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(UARTRXD);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(UARTTXD);

}

void UART_Visualization_Linux_pv_base::reset_model() {
  // reset all registers


  
  // reset value for output signals

  // reset value for input signals

}

UART_Visualization_Linux_pv_base_parameters::UART_Visualization_Linux_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(1, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, generic_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, signal_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, mb_debug, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, call_to_default_if, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, UARTRXD_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nUARTCTS_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, UARTEN_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, read_from_console_buffer_size, 256),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, read_from_console_latency, 1000),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, read_from_console_latency_time_unit, "NS"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, echo_mode, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, line_mode, false),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, xon_mode, false)
{
  if(verbose_parameters) print_parameters();
}

void UART_Visualization_Linux_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\tgeneric_clock = " << generic_clock << "\n";
  std::cout << "\tsignal_clock = " << signal_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tmb_debug = " << mb_debug << "\n";
  std::cout << "\tcall_to_default_if = " << call_to_default_if << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tUARTRXD_pipeline_length = " << UARTRXD_pipeline_length << "\n";
  std::cout << "\tnUARTCTS_pipeline_length = " << nUARTCTS_pipeline_length << "\n";
  std::cout << "\tUARTEN_pipeline_length = " << UARTEN_pipeline_length << "\n";
  std::cout << "\tread_from_console_buffer_size = " << read_from_console_buffer_size << "\n";
  std::cout << "\tread_from_console_latency = " << read_from_console_latency << "\n";
  std::cout << "\tread_from_console_latency_time_unit = " << read_from_console_latency_time_unit << "\n";
  std::cout << "\techo_mode = " << echo_mode << "\n";
  std::cout << "\tline_mode = " << line_mode << "\n";
  std::cout << "\txon_mode = " << xon_mode << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your UART_Visualization_Linux model.
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:46 PM, (user: mbradley)
//*>

#include "UART_Visualization_Linux_model.h"
#include "model_builder.h"

using namespace ::mb::utl::minmax;

UART_Visualization_Linux_machine_arch::UART_Visualization_Linux_machine_arch()
    : MachineArch(5, 0) {
        reset();
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: UARTTXD
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: UARTTXD, transaction: READ
    //////
    
    void UART_Visualization_Linux_machine_arch::transaction_instance__UARTTXD__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: UARTTXD, transaction: WRITE
    //////
    
    void UART_Visualization_Linux_machine_arch::transaction_instance__UARTTXD__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: UARTRXD
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: UARTRXD, transaction: READ
    //////
    
    void UART_Visualization_Linux_machine_arch::transaction_instance__UARTRXD__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: UARTRXD, transaction: WRITE
    //////
    
    void UART_Visualization_Linux_machine_arch::transaction_instance__UARTRXD__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: nUARTRTS
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: nUARTRTS, transaction: WRITE
    //////
    
    void UART_Visualization_Linux_machine_arch::transaction_instance__nUARTRTS__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: nUARTCTS
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: nUARTCTS, transaction: WRITE
    //////
    
    void UART_Visualization_Linux_machine_arch::transaction_instance__nUARTCTS__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: UARTEN
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: UARTEN, transaction: WRITE
    //////
    
    void UART_Visualization_Linux_machine_arch::transaction_instance__UARTEN__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }

void UART_Visualization_Linux_machine_arch::startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime) {
  switch(portIndex) {
    case(0) : break;
    case(1) : break;
    case(2) : break;
    case(3) : break;
    case(4) : break;
    default: break;
  }
}
VariableBase* UART_Visualization_Linux_machine_arch::getVariableBasePtrByName(const char* name) {
  return NULL;
}
Register* UART_Visualization_Linux_machine_arch::getRegisterByName(const char* name) {
  return 0;
}
void UART_Visualization_Linux_machine_arch::reset() { 
    MachineArch::reset();
}
bool UART_Visualization_Linux_machine_arch::getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end) {
    switch(portIndex) {
        case(0) :   return false;
        case(1) :   return false;
        case(2) :   return false;
        case(3) :   return false;
        case(4) :   return false;
        default: break;
    }
    return false; 
}
void UART_Visualization_Linux_machine_arch::callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime) {
    switch(portIndex) {
        case(0) : { //port: UARTTXD
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__UARTTXD__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__UARTTXD__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(1) : { //port: UARTRXD
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__UARTRXD__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__UARTRXD__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(2) : { //port: nUARTRTS
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__nUARTRTS__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(3) : { //port: nUARTCTS
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__nUARTCTS__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(4) : { //port: UARTEN
            switch(transactionIndex) {
                case(0) : { //transaction: WRITE
                    this->transaction_instance__UARTEN__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        default: break;
    }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The UART_Visualization_Linux_t will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:46 PM, (user: mbradley)
//*>




#include "UART_Visualization_Linux_model.h"
#include <math.h>
#include <stdlib.h>

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;


void UART_Visualization_Linux_t_base::schedule_generic_READ
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long ADDR, long* rDATA, long PRIORITY, long BURST, long SIZE, long STATUS) {
  sc_dt::uint64 local_address = 0;
  local_address = ADDR,
  scheduleGenericTransaction(port_index,
                             0,
                             local_address,
                             (unsigned char*)rDATA,
                             transactionSize,
                             SIZE,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

void UART_Visualization_Linux_t_base::schedule_generic_WRITE
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long ADDR, long* wDATA, long PRIORITY, long BURST, long SIZE, long STATUS) {
  sc_dt::uint64 local_address = 0;
  local_address = ADDR,
  scheduleGenericTransaction(port_index,
                             1,
                             local_address,
                             (unsigned char*)wDATA,
                             transactionSize,
                             SIZE,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

void UART_Visualization_Linux_t_base::schedule_signal_WRITE
(long port_index,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long address, long* value_p, long block_size) {
  sc_dt::uint64 local_address = 0;
  local_address = address,
  scheduleGenericTransaction(port_index,
                             1,
                             local_address,
                             (unsigned char*)value_p,
                             transactionSize,
                             block_size,
                             0, papoulis::getSimulationTime() + delay,
                             0,
                             0);
}



void UART_Visualization_Linux_t_base::start_transaction_generic_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           0,
                                           startTime);
  
  this->accept_generic_READ
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5]);
}

void UART_Visualization_Linux_t_base::end_transaction_generic_READ
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          0, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_generic_READ
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5]);
}
void UART_Visualization_Linux_t_base::start_transaction_generic_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           1,
                                           startTime);
  
  this->accept_generic_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3], 
     parameters[4], 
     parameters[5]);
}

void UART_Visualization_Linux_t_base::end_transaction_generic_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[4] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          1, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_generic_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3],
     parameters[4],
     parameters[5]);
}
void UART_Visualization_Linux_t_base::start_transaction_signal_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           0,
                                           startTime);
  
  this->accept_signal_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2]);
}

void UART_Visualization_Linux_t_base::end_transaction_signal_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 sc_dt::uint64 startTime,
 sc_dt::uint64 endTime,
 sc_dt::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          0, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_signal_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2]);
}

UART_Visualization_Linux_t_base::TransactionCallbackFunctionPointer UART_Visualization_Linux_t_base::getTransactionCallback(unsigned callbackIndex) {
  static TransactionCallbackFunctionPointer funcArray[] = {
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::start_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::start_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::start_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::start_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::start_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::end_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::end_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::end_transaction_generic_READ),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::end_transaction_generic_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::end_transaction_signal_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::null_transaction_callback),
    static_cast<TransactionCallbackFunctionPointer>(&UART_Visualization_Linux_t_base::end_transaction_signal_WRITE),
    0
  };
  if(callbackIndex >= sizeof(funcArray) / sizeof(*funcArray) - 1)
    return 0;
  return funcArray[callbackIndex];
}

config::real80 UART_Visualization_Linux_t_base::get_state_power() { 
  config::real80 power_value = 0;

  

  return power_value;
}

UART_Visualization_Linux_t_base::UART_Visualization_Linux_t_base(sc_module_name& module_name, long simulation) :
  papoulis::SystemCBaseModel(module_name),
  m_machineArch(new UART_Visualization_Linux_machine_arch()),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(1, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(generic_clock, clock),
  SD_INITIALIZE_PARAMETER(signal_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(mb_debug, false),
  SD_INITIALIZE_PARAMETER(call_to_default_if, false),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(UARTRXD_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(nUARTCTS_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(UARTEN_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER(read_from_console_buffer_size, 256),
  SD_INITIALIZE_PARAMETER(read_from_console_latency, 1000),
  SD_INITIALIZE_PARAMETER(read_from_console_latency_time_unit, "NS"),
  SD_INITIALIZE_PARAMETER(echo_mode, false),
  SD_INITIALIZE_PARAMETER(line_mode, false),
  SD_INITIALIZE_PARAMETER(xon_mode, false),
  m_simulation(simulation)
{
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  fix_clock_parameter(generic_clock, "generic_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[UARTTXD].port_name = "UARTTXD";
  port_descriptions[UARTTXD].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[UARTTXD].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[UARTTXD].is_read_write_address_channel = 0;
  
  port_descriptions[UARTTXD].is_read_write_address_channel = 1;
  port_descriptions[UARTTXD].is_master_port = 1;
  port_descriptions[UARTTXD].is_signal_port = 0;
  port_descriptions[UARTTXD].port_width = ((8 + 7) >> 3);
  port_descriptions[UARTTXD].port_width_in_bits = 8;
  port_descriptions[UARTTXD].protocol_name = "generic";
  port_descriptions[UARTTXD].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[UARTTXD].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[UARTTXD].ipxactBusDef.name = "generic";
  port_descriptions[UARTTXD].ipxactBusDef.version = "1.0"; 
  port_descriptions[UARTTXD].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[UARTTXD].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[UARTTXD].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[UARTTXD].ipxactAbstrDef.version = "1.0";
  port_descriptions[UARTTXD].port_must_bind = 1;
  port_descriptions[UARTTXD].params_count = 6;
  port_descriptions[UARTTXD].clock = generic_clock;
  m_machineArch->configureClock(UARTTXD, mb::sysc::sc_time_to_ps(generic_clock));
  port_descriptions[UARTTXD].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[UARTTXD].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);

  fix_clock_parameter(generic_clock, "generic_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[UARTRXD].port_name = "UARTRXD";
  port_descriptions[UARTRXD].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[UARTRXD].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[UARTRXD].is_read_write_address_channel = 0;
  
  port_descriptions[UARTRXD].is_read_write_address_channel = 1;
  port_descriptions[UARTRXD].is_master_port = 0;
  port_descriptions[UARTRXD].is_signal_port = 0;
  port_descriptions[UARTRXD].port_width = ((8 + 7) >> 3);
  port_descriptions[UARTRXD].port_width_in_bits = 8;
  port_descriptions[UARTRXD].protocol_name = "generic";
  port_descriptions[UARTRXD].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[UARTRXD].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[UARTRXD].ipxactBusDef.name = "generic";
  port_descriptions[UARTRXD].ipxactBusDef.version = "1.0"; 
  port_descriptions[UARTRXD].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[UARTRXD].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[UARTRXD].ipxactAbstrDef.name = "generic_tlm20";
  port_descriptions[UARTRXD].ipxactAbstrDef.version = "1.0";
  port_descriptions[UARTRXD].port_must_bind = 1;
  port_descriptions[UARTRXD].params_count = 6;
  port_descriptions[UARTRXD].clock = generic_clock;
  m_machineArch->configureClock(UARTRXD, mb::sysc::sc_time_to_ps(generic_clock));
  port_descriptions[UARTRXD].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[UARTRXD].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[nUARTRTS].port_name = "nUARTRTS";
  separate_write_channel = true;
  port_descriptions[nUARTRTS].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[nUARTRTS].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[nUARTRTS].is_read_write_address_channel = 0;
  
  port_descriptions[nUARTRTS].is_master_port = 1;
  port_descriptions[nUARTRTS].is_signal_port = 1;
  port_descriptions[nUARTRTS].port_width = ((1 + 7) >> 3);
  port_descriptions[nUARTRTS].port_width_in_bits = 1;
  port_descriptions[nUARTRTS].protocol_name = "signal";
  port_descriptions[nUARTRTS].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[nUARTRTS].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[nUARTRTS].ipxactBusDef.name = "signal";
  port_descriptions[nUARTRTS].ipxactBusDef.version = "1.0"; 
  port_descriptions[nUARTRTS].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[nUARTRTS].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[nUARTRTS].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[nUARTRTS].ipxactAbstrDef.version = "1.0";
  port_descriptions[nUARTRTS].port_must_bind = 1;
  port_descriptions[nUARTRTS].params_count = 3;
  port_descriptions[nUARTRTS].clock = signal_clock;
  m_machineArch->configureClock(nUARTRTS, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[nUARTRTS].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[nUARTRTS].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[nUARTCTS].port_name = "nUARTCTS";
  separate_write_channel = true;
  port_descriptions[nUARTCTS].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[nUARTCTS].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[nUARTCTS].is_read_write_address_channel = 0;
  
  port_descriptions[nUARTCTS].is_master_port = 0;
  port_descriptions[nUARTCTS].is_signal_port = 1;
  port_descriptions[nUARTCTS].port_width = ((1 + 7) >> 3);
  port_descriptions[nUARTCTS].port_width_in_bits = 1;
  port_descriptions[nUARTCTS].protocol_name = "signal";
  port_descriptions[nUARTCTS].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[nUARTCTS].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[nUARTCTS].ipxactBusDef.name = "signal";
  port_descriptions[nUARTCTS].ipxactBusDef.version = "1.0"; 
  port_descriptions[nUARTCTS].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[nUARTCTS].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[nUARTCTS].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[nUARTCTS].ipxactAbstrDef.version = "1.0";
  port_descriptions[nUARTCTS].port_must_bind = 1;
  port_descriptions[nUARTCTS].params_count = 3;
  port_descriptions[nUARTCTS].clock = signal_clock;
  m_machineArch->configureClock(nUARTCTS, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[nUARTCTS].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[nUARTCTS].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);

  fix_clock_parameter(signal_clock, "signal_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[UARTEN].port_name = "UARTEN";
  separate_write_channel = true;
  port_descriptions[UARTEN].port_kind = PortDescription::WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[UARTEN].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[UARTEN].is_read_write_address_channel = 0;
  
  port_descriptions[UARTEN].is_master_port = 0;
  port_descriptions[UARTEN].is_signal_port = 1;
  port_descriptions[UARTEN].port_width = ((1 + 7) >> 3);
  port_descriptions[UARTEN].port_width_in_bits = 1;
  port_descriptions[UARTEN].protocol_name = "signal";
  port_descriptions[UARTEN].ipxactBusDef.vendor = "Mentor.com";
  port_descriptions[UARTEN].ipxactBusDef.library = "Lib_ipxact";
  port_descriptions[UARTEN].ipxactBusDef.name = "signal";
  port_descriptions[UARTEN].ipxactBusDef.version = "1.0"; 
  port_descriptions[UARTEN].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[UARTEN].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[UARTEN].ipxactAbstrDef.name = "signal_tlm20";
  port_descriptions[UARTEN].ipxactAbstrDef.version = "1.0";
  port_descriptions[UARTEN].port_must_bind = 0;
  port_descriptions[UARTEN].params_count = 3;
  port_descriptions[UARTEN].clock = signal_clock;
  m_machineArch->configureClock(UARTEN, mb::sysc::sc_time_to_ps(signal_clock));
  port_descriptions[UARTEN].add_write_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[UARTEN].add_write_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);


  port_descriptions[UARTTXD].default_read_transaction_name = "READ";
  port_descriptions[UARTRXD].default_read_transaction_name = "READ";
  port_descriptions[UARTTXD].default_write_transaction_name = "WRITE";
  port_descriptions[UARTRXD].default_write_transaction_name = "WRITE";
  port_descriptions[nUARTRTS].default_write_transaction_name = "WRITE";
  port_descriptions[nUARTCTS].default_write_transaction_name = "WRITE";
  port_descriptions[UARTEN].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);

  bool isCpu = false;
  
  esl::tlm_sim::UserRunningModel* userRunningModel = Papoulis_CreateUserRunningModel(name(),
                                                                                     0,
                                                                                     this,
                                                                                     simulation,
                                                                                     false,
                                                                                     isCpu);
  setUserRunningModel(userRunningModel, isCpu);
  set_nominal_voltage(nominal_voltage);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("generic_clock", "sc_core::sc_time", sdGetParameterAsConstString("generic_clock"));
  registerParameter("signal_clock", "sc_core::sc_time", sdGetParameterAsConstString("signal_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("mb_debug", "bool", sdGetParameterAsConstString("mb_debug"));
  registerParameter("call_to_default_if", "bool", sdGetParameterAsConstString("call_to_default_if"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("UARTRXD_pipeline_length", "unsigned int", sdGetParameterAsConstString("UARTRXD_pipeline_length"));
  registerParameter("nUARTCTS_pipeline_length", "unsigned int", sdGetParameterAsConstString("nUARTCTS_pipeline_length"));
  registerParameter("UARTEN_pipeline_length", "unsigned int", sdGetParameterAsConstString("UARTEN_pipeline_length"));
  registerParameter("read_from_console_buffer_size", "unsigned int", sdGetParameterAsConstString("read_from_console_buffer_size"));
  registerParameter("read_from_console_latency", "unsigned int", sdGetParameterAsConstString("read_from_console_latency"));
  registerParameter("read_from_console_latency_time_unit", "const char*", sdGetParameterAsConstString("read_from_console_latency_time_unit"));
  registerParameter("echo_mode", "bool", sdGetParameterAsConstString("echo_mode"));
  registerParameter("line_mode", "bool", sdGetParameterAsConstString("line_mode"));
  registerParameter("xon_mode", "bool", sdGetParameterAsConstString("xon_mode"));
  set_sync_all(0); 
  
  
  
  
  

  
  

  


  

  constant_global_power_policy* p = new constant_global_power_policy(userRunningModel);
  
  
  set_nominal_clock(1000000/100); /* in ps */ 
  update_coefficients();
  set_global_power_policy(p);
}

void UART_Visualization_Linux_t_base::update_sync_all() {
  set_sync_all(0);
  
}

void UART_Visualization_Linux_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;


}

void UART_Visualization_Linux_t_base::update_sequential_parameters(esl::sc_sim::sequential_policy* handle) {
  if (m_sequential_vector.size() == 0)
    return;

}

void UART_Visualization_Linux_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

}

void UART_Visualization_Linux_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}

void UART_Visualization_Linux_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}

void UART_Visualization_Linux_t_base::update_state_power_parameters(esl::sc_sim::state_power_policy* handle) {
  if (m_state_power_vector.size() == 0)
    return;

}

void UART_Visualization_Linux_t_base::update_global_power_parameters(esl::sc_sim::constant_global_power_policy* handle) {
  
  
  return;  
}

bool UART_Visualization_Linux_t_base::triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans) {
  mb::utl::Segment<uint64_t> transactionRange(trans.get_address(), trans.get_address() + trans.get_data_length());

  return false;
}

bool UART_Visualization_Linux_t_base::portHasRegisters(unsigned portIndex) {
  switch (portIndex) {

  }
  return false;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for UART_Visualization_Linux.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:46 PM, (user: mbradley)
//*>

#include "UART_Visualization_Linux_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "UART_Visualization_Linux_pv.h"




// Constructor
UART_Visualization_Linux_pvt::UART_Visualization_Linux_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    UART_Visualization_Linux_pvt_param_defaults(this->name()),
    UARTTXD("UARTTXD"),
    UARTRXD("UARTRXD"),
    nUARTRTS("nUARTRTS"),
    nUARTCTS("nUARTCTS"),
    UARTEN("UARTEN"), 
    UARTTXD_entry("unvisible_UARTTXD_entry"),
    UARTRXD_entry("unvisible_UARTRXD_entry"),
    nUARTCTS_entry("unvisible_nUARTCTS_entry"),
    UARTEN_entry("unvisible_UARTEN_entry"),
    m_UARTTXD_nb_connector(*this),
    m_nUARTRTS_nb_connector(*this),
    m_UARTRXD_nb_connector(*this),
    m_nUARTCTS_nb_connector(*this),
    m_UARTEN_nb_connector(*this)

{


  m_UART_Visualization_Linux_t = UART_Visualization_Linux_t_base::create_t("T", 1);
  m_UART_Visualization_Linux_pv = new UART_Visualization_Linux_pv("PV");
  bind();
}  


UART_Visualization_Linux_pvt::UART_Visualization_Linux_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time generic_clock_init, sc_core::sc_time signal_clock_init, double nominal_voltage_init, bool mb_debug_init, bool call_to_default_if_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, unsigned int UARTRXD_pipeline_length_init, unsigned int nUARTCTS_pipeline_length_init, unsigned int UARTEN_pipeline_length_init, unsigned int read_from_console_buffer_size_init, unsigned int read_from_console_latency_init, const char* read_from_console_latency_time_unit_init, bool echo_mode_init, bool line_mode_init, bool xon_mode_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  UART_Visualization_Linux_pvt_param_defaults(this->name(), clock_init, generic_clock_init, signal_clock_init, nominal_voltage_init, mb_debug_init, call_to_default_if_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, UARTRXD_pipeline_length_init, nUARTCTS_pipeline_length_init, UARTEN_pipeline_length_init, read_from_console_buffer_size_init, read_from_console_latency_init, read_from_console_latency_time_unit_init, echo_mode_init, line_mode_init, xon_mode_init),
    UARTTXD("UARTTXD"),
    UARTRXD("UARTRXD"),
    nUARTRTS("nUARTRTS"),
    nUARTCTS("nUARTCTS"),
    UARTEN("UARTEN"), 
    UARTTXD_entry("unvisible_UARTTXD_entry"),
    UARTRXD_entry("unvisible_UARTRXD_entry"),
    nUARTCTS_entry("unvisible_nUARTCTS_entry"),
    UARTEN_entry("unvisible_UARTEN_entry"),
    m_UARTTXD_nb_connector(*this),
    m_nUARTRTS_nb_connector(*this),
    m_UARTRXD_nb_connector(*this),
    m_nUARTCTS_nb_connector(*this),
    m_UARTEN_nb_connector(*this)
{


  m_UART_Visualization_Linux_t = UART_Visualization_Linux_t_base::create_t("T", 1);
  m_UART_Visualization_Linux_pv = new UART_Visualization_Linux_pv("PV");
  bind();
} 

UART_Visualization_Linux_pvt::UART_Visualization_Linux_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  UART_Visualization_Linux_pvt_param_defaults(this->name(), change_parameters),
    UARTTXD("UARTTXD"),
    UARTRXD("UARTRXD"),
    nUARTRTS("nUARTRTS"),
    nUARTCTS("nUARTCTS"),
    UARTEN("UARTEN"), 
    UARTTXD_entry("unvisible_UARTTXD_entry"),
    UARTRXD_entry("unvisible_UARTRXD_entry"),
    nUARTCTS_entry("unvisible_nUARTCTS_entry"),
    UARTEN_entry("unvisible_UARTEN_entry"),
    m_UARTTXD_nb_connector(*this),
    m_nUARTRTS_nb_connector(*this),
    m_UARTRXD_nb_connector(*this),
    m_nUARTCTS_nb_connector(*this),
    m_UARTEN_nb_connector(*this)
{


  m_UART_Visualization_Linux_t = UART_Visualization_Linux_t_base::create_t("T", 1);
  m_UART_Visualization_Linux_pv = new UART_Visualization_Linux_pv("PV");
  bind();
} 

UART_Visualization_Linux_pvt::~UART_Visualization_Linux_pvt() {
  remove_pending_scenes();
  delete m_UART_Visualization_Linux_t; delete m_UART_Visualization_Linux_pv;
}




void UART_Visualization_Linux_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->UARTTXD.bind(UARTTXD_entry);
  UARTRXD_entry.bind(getPV()->UARTRXD);
  getPV()->nUARTRTS.bind(nUARTRTS_entry); 
  nUARTCTS_entry(getPV()->nUARTCTS);
  UARTEN_entry(getPV()->UARTEN);  

  /* set callbacks on external and entry ports */ 

  UARTRXD.b_transport_cb.set(&UARTRXD_entry, &UARTRXD_entry_type::b_transport);
  UARTRXD.transport_dbg_cb.set(&UARTRXD_entry, &UARTRXD_entry_type::transport_dbg);
  UARTRXD.get_direct_mem_ptr_cb.set(&UARTRXD_entry, &UARTRXD_entry_type::get_direct_mem_ptr);

  nUARTCTS.b_transport_cb.set(this, &self_type::b_transport_inside_nUARTCTS);

  UARTEN.b_transport_cb.set(this, &self_type::b_transport_inside_UARTEN);

  UARTTXD_entry.b_transport_cb.set(this, &self_type::b_transport_outside_UARTTXD);
  UARTTXD_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_UARTTXD);
  UARTTXD_entry.get_direct_mem_ptr_cb.set(&UARTTXD, &UARTTXD_type::get_direct_mem_ptr);

  nUARTRTS_entry.write_cb.set(this, &self_type::b_transport_outside_nUARTRTS);

  
  /* connect t non blocking callbacks */

  UARTTXD.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_UARTTXD);
  getT()->set_port_cb(0, &m_UARTTXD_nb_connector);

  nUARTRTS.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_nUARTRTS);
  getT()->set_port_cb(2, &m_nUARTRTS_nb_connector);

  UARTRXD.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_UARTRXD);
  getT()->set_port_cb(1, &m_UARTRXD_nb_connector);

  nUARTCTS.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_nUARTCTS);
  getT()->set_port_cb(3, &m_nUARTCTS_nb_connector);

  UARTEN.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_UARTEN);
  getT()->set_port_cb(4, &m_UARTEN_nb_connector);

  UARTRXD_entry.invalidate_direct_mem_ptr_cb.set(&UARTRXD, &UARTRXD_type::invalidate_direct_mem_ptr);

  UARTTXD.invalidate_direct_mem_ptr_cb.set(&UARTTXD_entry, &UARTTXD_entry_type::invalidate_direct_mem_ptr);

  /* check mb_event policies */
  m_UART_Visualization_Linux_t->check_mb_events();
}


void UART_Visualization_Linux_pvt::b_transport_inside_nUARTCTS(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_UART_Visualization_Linux_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  nUARTCTS_entry.write(*(bool*)p.get_data_ptr());
}
void UART_Visualization_Linux_pvt::b_transport_inside_UARTEN(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  mb::tlm20::pvt_ext* extension = mb::tlm20::setup_pvt_ext(p);
  if (extension) {
    mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_UART_Visualization_Linux_pv);
    if (current_model)
      current_model->set_current_token(extension->getToken());
  }
  UARTEN_entry.write(*(bool*)p.get_data_ptr());
}

void UART_Visualization_Linux_pvt::b_transport_outside_UARTTXD(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  
  UARTTXD.b_transport(p, t);
  
} 

unsigned int UART_Visualization_Linux_pvt::transport_dbg_outside_UARTTXD(tlm::tlm_generic_payload& p)
{
  
  return UARTTXD.transport_dbg(p);
  
}

void UART_Visualization_Linux_pvt::b_transport_outside_nUARTRTS(bool data)
{
  static tlm::tlm_generic_payload payload;

  payload.reset();
  payload.set_command(tlm::TLM_WRITE_COMMAND);
  payload.set_data_ptr((unsigned char*)&data);
  payload.set_data_length(sizeof(bool));
  payload.set_streaming_width(sizeof(bool));

  mb::tlm20::clear_pvt_ext(payload);
  mb::tlm20::setup_pvt_ext(payload)->set_signal(true);

  

  mb::mb_module* current_model = dynamic_cast<mb::mb_module*>(m_UART_Visualization_Linux_pv);
  if (current_model)
    mb::tlm20::setup_pvt_ext(payload)->setToken(current_model->get_current_token());
  sc_time t;
  nUARTRTS.b_transport(payload, t);
}

