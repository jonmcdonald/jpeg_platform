
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The apb_bus_pv will be derived from this class.
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:44 PM, (user: mbradley)
//*>


#include "apb_bus_model.h"

#ifdef MODEL_BUILDER_VERSION_NUMBER
#if 4100 != MODEL_BUILDER_VERSION_NUMBER
#error "This model was generated using Model Builder version: 4.1.0. Please regenerate model."
#endif
#else
#error "Please regenerate model."
#endif

using namespace sc_core;
using namespace sc_dt;
using namespace std;


apb_bus_pv_base::apb_bus_pv_base(sc_module_name& module_name) : 
  apb_bus_pv_base_mb_compatibility(module_name),
  apb_bus_pv_base_parameters(this),
  VISTA_MB_PV_INIT_MEMBER(uart),
  VISTA_MB_PV_INIT_MEMBER(uart_rst_ctrl),
  VISTA_MB_PV_INIT_MEMBER(bus_masterX),
  VISTA_MB_PV_INIT_MEMBER(bus_masterY),
  VISTA_MB_PV_INIT_MEMBER(bus_slave) {


  payload_on_stack = 0;
  payload_for_token = 0;

  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(bus_slave);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(uart);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(uart_rst_ctrl);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(bus_masterX);
  VISTA_MB_PV_BIND_BW_PROCESS_TO_MASTER(bus_masterY);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(bus_slave);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(uart);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(uart_rst_ctrl);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(bus_masterX);
  VISTA_MB_PV_REGISTER_SELF_BW_PROCESS_CALLBACKS(bus_masterY);

}

void apb_bus_pv_base::reset_model() {
  // reset all registers


  
  // reset value for output signals

  // reset value for input signals

}

apb_bus_pv_base_parameters::apb_bus_pv_base_parameters(sc_object* object) :
  m_object(object),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, apb_clock, clock),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, dmi_enabled, true),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, layers, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, slave_sets, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, write_broadcast, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_slave_priority, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_rst_ctrl_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_rst_ctrl_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_rst_ctrl_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_rst_ctrl_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_rst_ctrl_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, uart_rst_ctrl_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterX_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterX_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterX_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterX_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterX_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterX_latency, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterY_base_address, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterY_size, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterY_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterY_secure, 0),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterY_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER_EXTERNALLY(object, bus_masterY_latency, 0)
{
  if(verbose_parameters) print_parameters();
}

void apb_bus_pv_base_parameters::print_parameters()
{
  const char* name;
  if (!strcmp(m_object->basename(), "PV"))
    name = m_object->get_parent()->name();
  else
    name = m_object->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\tapb_clock = " << apb_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tdmi_enabled = " << dmi_enabled << "\n";
  std::cout << "\twarning_level = " << warning_level << "\n";
  std::cout << "\tlayers = " << layers << "\n";
  std::cout << "\tslave_sets = " << slave_sets << "\n";
  std::cout << "\twrite_broadcast = " << write_broadcast << "\n";
  std::cout << "\tbus_slave_priority = " << bus_slave_priority << "\n";
  std::cout << "\tbus_slave_vmap = " << bus_slave_vmap << "\n";
  std::cout << "\tuart_base_address = " << uart_base_address << "\n";
  std::cout << "\tuart_size = " << uart_size << "\n";
  std::cout << "\tuart_subtract_base_address = " << uart_subtract_base_address << "\n";
  std::cout << "\tuart_secure = " << uart_secure << "\n";
  std::cout << "\tuart_additional_ranges = " << uart_additional_ranges << "\n";
  std::cout << "\tuart_latency = " << uart_latency << "\n";
  std::cout << "\tuart_rst_ctrl_base_address = " << uart_rst_ctrl_base_address << "\n";
  std::cout << "\tuart_rst_ctrl_size = " << uart_rst_ctrl_size << "\n";
  std::cout << "\tuart_rst_ctrl_subtract_base_address = " << uart_rst_ctrl_subtract_base_address << "\n";
  std::cout << "\tuart_rst_ctrl_secure = " << uart_rst_ctrl_secure << "\n";
  std::cout << "\tuart_rst_ctrl_additional_ranges = " << uart_rst_ctrl_additional_ranges << "\n";
  std::cout << "\tuart_rst_ctrl_latency = " << uart_rst_ctrl_latency << "\n";
  std::cout << "\tbus_masterX_base_address = " << bus_masterX_base_address << "\n";
  std::cout << "\tbus_masterX_size = " << bus_masterX_size << "\n";
  std::cout << "\tbus_masterX_subtract_base_address = " << bus_masterX_subtract_base_address << "\n";
  std::cout << "\tbus_masterX_secure = " << bus_masterX_secure << "\n";
  std::cout << "\tbus_masterX_additional_ranges = " << bus_masterX_additional_ranges << "\n";
  std::cout << "\tbus_masterX_latency = " << bus_masterX_latency << "\n";
  std::cout << "\tbus_masterY_base_address = " << bus_masterY_base_address << "\n";
  std::cout << "\tbus_masterY_size = " << bus_masterY_size << "\n";
  std::cout << "\tbus_masterY_subtract_base_address = " << bus_masterY_subtract_base_address << "\n";
  std::cout << "\tbus_masterY_secure = " << bus_masterY_secure << "\n";
  std::cout << "\tbus_masterY_additional_ranges = " << bus_masterY_additional_ranges << "\n";
  std::cout << "\tbus_masterY_latency = " << bus_masterY_latency << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/


#include <iostream>





apb_bus_base1_pv::apb_bus_base1_pv(sc_module_name module_name) :
  apb_bus_pv_base(module_name) {
  dbg_port.bind(m_dbg_port_fw_process);
  m_dbg_port_fw_process.register_b_transport(this, &apb_bus_base1_pv::dbg_port_callback);
  m_dbg_port_fw_process.register_transport_dbg(this, &apb_bus_base1_pv::dbg_port_callback_dbg);
  m_dbg_port_fw_process.register_get_direct_mem_ptr(this, &apb_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback);

  m_model = dynamic_cast<PapoulisBusBaseModel *>(getSystemCBaseModel());
  if (m_model) {
    decoder = m_model->get_decoder();
 
  } else {
    decoder = new esl::sc_sim::user_model::Decoder(1, 5, write_broadcast);
    decoder->registerSlavePort(1, this->uart_base_address, this->uart_size, this->uart_subtract_base_address);
    decoder->registerSlavePort(2, this->uart_rst_ctrl_base_address, this->uart_rst_ctrl_size, this->uart_rst_ctrl_subtract_base_address);
    decoder->registerSlavePort(3, this->bus_masterX_base_address, this->bus_masterX_size, this->bus_masterX_subtract_base_address);
    decoder->registerSlavePort(4, this->bus_masterY_base_address, this->bus_masterY_size, this->bus_masterY_subtract_base_address);
    decoder->parseVmapString(0, this->bus_slave_vmap, "bus_slave_vmap");
  }
  
  m_port_count = 5;
  m_layers_count = m_model->get_arbiter()->get_layers_count();
  m_is_multi_channel = 0;
  m_bus_scheduler = new esl::sc_sim::BusScheduler(m_port_count, m_layers_count, m_is_multi_channel);
  m_apply_policies = false;
  const char* policy_modeling = "lt_policy_modeling";
  
  mb::sysc::add_parameter_listener(this->name(), policy_modeling, this);
  if (mb::sysc::sdParameterExists(policy_modeling)) {
    if (!strcasecmp(mb::sysc::sdGetParameterAsConstString(policy_modeling), "dynamic")) {
      m_apply_policies = true;
    }
  }
}

apb_bus_base1_pv::~apb_bus_base1_pv()
{
  delete m_bus_scheduler;
}
void apb_bus_base1_pv::parameter_changed(const std::string& old_value,
                                             const std::string& new_value) {
  if (!strcasecmp(new_value.c_str(), "dynamic")) {
    m_apply_policies = true;
  }
  else {
    m_apply_policies = false;
  }
}



void apb_bus_base1_pv::bus_slave_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, 0, false, t);
  
}

unsigned apb_bus_base1_pv::bus_slave_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {

  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, 0, true, t);

}

bool apb_bus_base1_pv::bus_slave_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {

  mb::tlm20::MemoryMap::DiscoveryExt* discovery_ext =
    trans.get_extension<mb::tlm20::MemoryMap::DiscoveryExt>();
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 offset;
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    if (this->uart_subtract_base_address) {
      offset = this->uart_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->uart_size);
    if (this->uart_rst_ctrl_subtract_base_address) {
      offset = this->uart_rst_ctrl_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->uart_rst_ctrl_size);
    if (this->bus_masterX_subtract_base_address) {
      offset = this->bus_masterX_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->bus_masterX_size);
    if (this->bus_masterY_subtract_base_address) {
      offset = this->bus_masterY_base_address;
    } else {
      offset = 0;
    }
    discovery_ext->add_address(base + offset);
    discovery_ext->add_address(base + offset + this->bus_masterY_size);
  }

   sc_dt::uint64 virtualAddress = decoder->getVirtualAddress(0, trans.get_address());
   std::vector<long> slavePortIndexArray;
   esl::sc_sim::secure_payload* secure_inst = decoder->getSecurePayload();
   if (secure_inst) {
     if (secure_inst->get_security_value(trans) ==
         esl::sc_sim::secure_payload::NON_SECURE)
       decoder->getNonSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), 0, true);
     else
       decoder->getSecuredSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), 0, true);
    } else
     decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, trans.get_data_length() == 0 ? 1 : trans.get_data_length(), name(), get_port_name(0), true);
   if (slavePortIndexArray.size() == 0 || 
       (write_broadcast && trans.is_write())) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
   long slavePortIndex = slavePortIndexArray[0];
  if (mb_unlikely(discovery_ext != 0)) {
    sc_dt::uint64 base = discovery_ext->get_base_address(trans);
    config::uint64 startAddress, endAddress; bool subtractBaseAddress;
    decoder->getSlaveRange(slavePortIndex, startAddress, endAddress, subtractBaseAddress);
    discovery_ext->set_current_range(base + startAddress, base + endAddress);
  }

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);

  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);

  if (returnStatus) {
    if (secure_inst) {
      if (secure_inst->get_security_value(trans) ==
          esl::sc_sim::secure_payload::NON_SECURE &&
          decoder->getSecure(slavePortIndex, 0)) {
        trans.set_response_status(tlm::TLM_ADDRESS_ERROR_RESPONSE);
        returnStatus = false;
        dmiData.set_dmi_ptr(0);
        mb::tlm20::iss_core_ext *ext;
        trans.get_extension(ext);
        if(ext)
          ext->set_data_ptr(0);
        mb::tlm20::direct_call_ext *p_direct_call_ext = NULL;
        trans.get_extension(p_direct_call_ext);
        if (p_direct_call_ext)
          p_direct_call_ext->set_direct_call_if(0);
      }
    }
  }
  return returnStatus;
}


void apb_bus_base1_pv::dbg_port_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
  routePayload(trans, (unsigned) (-1), false, t);
}

unsigned apb_bus_base1_pv::dbg_port_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
  sc_core::sc_time t = sc_core::SC_ZERO_TIME;
  return routePayload(trans, (unsigned) (-1), true, t);
}

bool apb_bus_base1_pv::dbg_port_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, tlm::tlm_dmi& dmiData) {
  sc_dt::uint64 virtualAddress = trans.get_address();
  std::vector<long> slavePortIndexArray;
  decoder->getSlavePortIndexArray(slavePortIndexArray, virtualAddress, 32, name(), "dbg_port");
  if (slavePortIndexArray.size() == 0) {
    dmiData.set_start_address(trans.get_address());
    dmiData.set_end_address(trans.get_address());
    return false;
  }
   
  long slavePortIndex = slavePortIndexArray[0];
  

  sc_dt::uint64 baseAddress = decoder->getBaseAddress(slavePortIndex, virtualAddress);
  sc_dt::uint64 address = trans.get_address();
  trans.set_address(baseAddress);
  bool returnStatus = get_fw_transport_if(slavePortIndex)->get_direct_mem_ptr(trans, dmiData);
  trans.set_address(address);

  // clip the range
  sc_dt::uint64 dmiStartAddress = dmiData.get_start_address();
  sc_dt::uint64 dmiEndAddress = dmiData.get_end_address();
  unsigned char* dmiPtr = dmiData.get_dmi_ptr();
  signed long long offset = address - virtualAddress;
  clip_the_range(address, dmiStartAddress, dmiEndAddress, dmiPtr, slavePortIndex, offset);
  
  dmiData.set_start_address(dmiStartAddress);
  dmiData.set_end_address(dmiEndAddress);
  dmiData.set_dmi_ptr(dmiPtr);
  return returnStatus;
}

void apb_bus_base1_pv::clip_the_range(sc_dt::uint64 address,
                                            sc_dt::uint64 &dmiStartAddress,
                                            sc_dt::uint64 &dmiEndAddress,
                                            unsigned char* &dmiPtr,
                                            long slavePortIndex,
                                            signed long long offset) {
  sc_dt::uint64 slaveStartAddress = 0;
  sc_dt::uint64 slaveEndAddress = 0;
  bool subtractBaseAddress = true;
  decoder->getSlaveRangeByAddress(slavePortIndex, address, slaveStartAddress, slaveEndAddress, subtractBaseAddress);
  if (subtractBaseAddress) {
    sc_dt::uint64 translatedStartAddress = 0;
    sc_dt::uint64 translatedEndAddress = slaveEndAddress - slaveStartAddress;
    if (dmiEndAddress > translatedEndAddress)
      dmiEndAddress = translatedEndAddress;
    
    dmiStartAddress += (slaveStartAddress);
    dmiEndAddress += (slaveStartAddress);
  } else {
    if (slaveStartAddress > dmiStartAddress) {
      if (slaveStartAddress < dmiEndAddress) {
        dmiPtr += slaveStartAddress - dmiStartAddress;
        dmiStartAddress = slaveStartAddress;
      }
    }
    if (dmiEndAddress > slaveEndAddress) {
      if (slaveEndAddress > dmiStartAddress)
        dmiEndAddress = slaveEndAddress;
    }
  }
  // add the offset if from vmap parameter
  
  dmiStartAddress += (offset);
  dmiEndAddress += (offset);
}

void apb_bus_base1_pv::invalidate_direct_mem_ptr_callback(unsigned master_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  config::uint64 startAddress;
  config::uint64 endAddress;
  bool substractBaseAddress;  
  decoder->getSlaveRange(master_index, startAddress, endAddress, substractBaseAddress);
  sc_dt::uint64 current_start_range = start_range;
  sc_dt::uint64 current_end_range = end_range;
  unsigned char* dmi_ptr = 0;
  clip_the_range(startAddress, current_start_range, current_end_range, dmi_ptr, master_index, 0);
  sc_dt::uint64 original_address = 0;
original_address = decoder->getOriginalAddress(bus_slave_idx, current_start_range);
  invalidate_direct_mem_ptr(bus_slave_idx, original_address, original_address + current_end_range - current_start_range);
}


void apb_bus_base1_pv::uart_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(uart_idx, start_range, end_range);
  }
void apb_bus_base1_pv::uart_rst_ctrl_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(uart_rst_ctrl_idx, start_range, end_range);
  }
void apb_bus_base1_pv::bus_masterX_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(bus_masterX_idx, start_range, end_range);
  }
void apb_bus_base1_pv::bus_masterY_invalidate_direct_mem_ptr_callback(sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
    invalidate_direct_mem_ptr_callback(bus_masterY_idx, start_range, end_range);
  }

void apb_bus_base1_pv::invalidate_direct_mem_ptr(unsigned target_index, sc_dt::uint64 start_range, sc_dt::uint64 end_range) {
  switch(target_index) {
  case bus_slave_idx :
    bus_slave->invalidate_direct_mem_ptr(start_range, end_range);
    break;
  }
}

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your apb_bus model.
//* 
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>

#include "apb_bus_model.h"
#include "model_builder.h"

using namespace ::mb::utl::minmax;

apb_bus_machine_arch::apb_bus_machine_arch()
    : MachineArch(5, 0) {
        reset();
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: bus_slave
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: bus_slave, transaction: READ
    //////
    
    void apb_bus_machine_arch::transaction_instance__bus_slave__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: bus_slave, transaction: WRITE
    //////
    
    void apb_bus_machine_arch::transaction_instance__bus_slave__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: uart
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: uart, transaction: READ
    //////
    
    void apb_bus_machine_arch::transaction_instance__uart__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: uart, transaction: WRITE
    //////
    
    void apb_bus_machine_arch::transaction_instance__uart__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: uart_rst_ctrl
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: uart_rst_ctrl, transaction: READ
    //////
    
    void apb_bus_machine_arch::transaction_instance__uart_rst_ctrl__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: uart_rst_ctrl, transaction: WRITE
    //////
    
    void apb_bus_machine_arch::transaction_instance__uart_rst_ctrl__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: bus_masterX
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: bus_masterX, transaction: READ
    //////
    
    void apb_bus_machine_arch::transaction_instance__bus_masterX__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: bus_masterX, transaction: WRITE
    //////
    
    void apb_bus_machine_arch::transaction_instance__bus_masterX__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: bus_masterY
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: bus_masterY, transaction: READ
    //////
    
    void apb_bus_machine_arch::transaction_instance__bus_masterY__READ
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: bus_masterY, transaction: WRITE
    //////
    
    void apb_bus_machine_arch::transaction_instance__bus_masterY__WRITE
      (
        sc_dt::uint64 _address,
        sc_dt::uint64 _size,
        sc_dt::uint64 _data, 
        bool has_been_error, 
        sc_dt::uint64 currentTime
      )
    {
      
    }

void apb_bus_machine_arch::startTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 currentTime) {
  switch(portIndex) {
    case(0) : break;
    case(1) : break;
    case(2) : break;
    case(3) : break;
    case(4) : break;
    default: break;
  }
}
VariableBase* apb_bus_machine_arch::getVariableBasePtrByName(const char* name) {
  return NULL;
}
Register* apb_bus_machine_arch::getRegisterByName(const char* name) {
  return 0;
}
void apb_bus_machine_arch::reset() { 
    MachineArch::reset();
}
bool apb_bus_machine_arch::getAddressRange(unsigned portIndex, sc_dt::uint64& begin, sc_dt::uint64& end) {
    switch(portIndex) {
        case(0) :   return false;
        case(1) :   return false;
        case(2) :   return false;
        case(3) :   return false;
        case(4) :   return false;
        default: break;
    }
    return false; 
}
void apb_bus_machine_arch::callTransaction(unsigned portIndex, unsigned transactionIndex, sc_dt::uint64 address, sc_dt::uint64 size, sc_dt::uint64 data, bool has_been_error, sc_dt::uint64 currentTime) {
    switch(portIndex) {
        case(0) : { //port: bus_slave
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__bus_slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__bus_slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(1) : { //port: uart
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__uart__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__uart__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(2) : { //port: uart_rst_ctrl
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__uart_rst_ctrl__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__uart_rst_ctrl__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(3) : { //port: bus_masterX
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__bus_masterX__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__bus_masterX__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        case(4) : { //port: bus_masterY
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__bus_masterY__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__bus_masterY__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
        default: break;
    }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

#include "apb_bus_model.h"

using namespace esl::tlm_sim;
using namespace esl::sc_sim;
using namespace std;
using namespace sc_dt;
using namespace sc_core;

void apb_bus_t_base::createDecoder(void* userRunningModel) {
  long* portLayers = 0;
  long* readAddressLayers = 0;
  long* writeAddressLayers = 0;
  long* readDataLayers = 0;
  long* writeDataLayers = 0;
  long** mastersVmap = 0;
  if (isMultiChannel && layers && *layers == 0)
    Papoulis_ParseLayersFile(userRunningModel,
                             "bus_slave: uart, uart_rst_ctrl, bus_masterX, bus_masterY; ",
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);
    
  else
    Papoulis_ParseLayersFile(userRunningModel,
                             layers,
                             slave_sets,
                             "",
                             portLayers,
                             readAddressLayers,
                             writeAddressLayers,
                             readDataLayers,
                             writeDataLayers,
                             mastersVmap);

  m_decoder = new esl::sc_sim::user_model::Decoder(4, mastersVmap, port_count, write_broadcast);
  if (!m_arbiter)
    m_arbiter = new esl::sc_sim::user_model::Arbiter(new esl::sc_sim::ArbiterScheme());
  m_arbiter->updateTables(port_count);
  m_arbiter->setDecoder(m_decoder);

  unsigned masterIndex = 0;
  for (unsigned u = 0; u < get_port_count(); u++)
    if (is_master(u)) {
      masterIndex = u;
      break;
    }

  m_decoder->insertPortName("bus_slave");
  m_decoder->insertPortName("uart");
  m_decoder->insertPortName("uart_rst_ctrl");
  m_decoder->insertPortName("bus_masterX");
  m_decoder->insertPortName("bus_masterY");
  
  std::vector<esl::sc_sim::SystemCChannel*>* channels = getReadAndWriteChannels(masterIndex);
  if (channels->size() == 1) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_IGNORE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  } else if (channels->size() == 2) {
    esl::sc_sim::SystemCChannel* channel = (*channels)[0];
    std::vector<esl::sc_sim::protocol_phase> protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_READ_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
    channel = (*channels)[1];
    protocol_phases = channel->getProtocolPhases();
    for(unsigned u = 0; u < protocol_phases.size(); u += 2) {
      m_arbiter->addChannel(tlm::TLM_WRITE_COMMAND, protocol_phases[u].get_phase(), protocol_phases[u].is_input());
    }
  }

  if(isMultiChannel)
    m_arbiter->setMultiChannel();
  unsigned* pendings = new unsigned[port_count];
  pendings[bus_slave] = Papoulis_GetPending((void*)getUserRunningModel(), bus_slave);
  pendings[uart] = Papoulis_GetPending((void*)getUserRunningModel(), uart);
  pendings[uart_rst_ctrl] = Papoulis_GetPending((void*)getUserRunningModel(), uart_rst_ctrl);
  pendings[bus_masterX] = Papoulis_GetPending((void*)getUserRunningModel(), bus_masterX);
  pendings[bus_masterY] = Papoulis_GetPending((void*)getUserRunningModel(), bus_masterY);
  m_arbiter->setPendings(pendings);
  sc_dt::uint64 base_address = 0;
  if (uart_base_address == 0xffffffff && 
      sizeof(uart_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = uart_base_address;
  m_decoder->registerSlavePort(uart,
                               base_address,
                               uart_size,
                               uart_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(uart,
                                            "uart",
                                            uart_additional_ranges,
                                            uart_subtract_base_address);
  m_decoder->setSecure(uart, uart_secure, config::uint32_max);

  if (uart_rst_ctrl_base_address == 0xffffffff && 
      sizeof(uart_rst_ctrl_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = uart_rst_ctrl_base_address;
  m_decoder->registerSlavePort(uart_rst_ctrl,
                               base_address,
                               uart_rst_ctrl_size,
                               uart_rst_ctrl_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(uart_rst_ctrl,
                                            "uart_rst_ctrl",
                                            uart_rst_ctrl_additional_ranges,
                                            uart_rst_ctrl_subtract_base_address);
  m_decoder->setSecure(uart_rst_ctrl, uart_rst_ctrl_secure, config::uint32_max);

  if (bus_masterX_base_address == 0xffffffff && 
      sizeof(bus_masterX_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = bus_masterX_base_address;
  m_decoder->registerSlavePort(bus_masterX,
                               base_address,
                               bus_masterX_size,
                               bus_masterX_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(bus_masterX,
                                            "bus_masterX",
                                            bus_masterX_additional_ranges,
                                            bus_masterX_subtract_base_address);
  m_decoder->setSecure(bus_masterX, bus_masterX_secure, config::uint32_max);

  if (bus_masterY_base_address == 0xffffffff && 
      sizeof(bus_masterY_base_address) == 4)
    base_address = 0xffffffffffffffffULL;
  else
    base_address = bus_masterY_base_address;
  m_decoder->registerSlavePort(bus_masterY,
                               base_address,
                               bus_masterY_size,
                               bus_masterY_subtract_base_address);
  m_decoder->parseSlavePortAdditionalRanges(bus_masterY,
                                            "bus_masterY",
                                            bus_masterY_additional_ranges,
                                            bus_masterY_subtract_base_address);
  m_decoder->setSecure(bus_masterY, bus_masterY_secure, config::uint32_max);

  m_decoder->registerPortPriorityAndData(bus_slave, bus_slave_priority, (void*)0);
  m_decoder->parseVmapString(bus_slave, bus_slave_vmap, "bus_slave_vmap");
  m_decoder->checkConsistency(name());
  long portCount = 4 + 1;
  m_arbiter->generateLayerTable(portCount, portLayers, readAddressLayers, writeAddressLayers, readDataLayers, writeDataLayers);
}

void apb_bus_t_base::schedule_apb_READ
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long PADDR, long* PRDATA, long block_size) {
  scheduleGenericTransaction(portIndex,
                             0,
                             PADDR,
                             (unsigned char*)PRDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}
void apb_bus_t_base::schedule_apb_WRITE
(long portIndex,
 sc_dt::uint64 delay,
 long& transactionSize,
 esl::include::transaction_power& power , long PADDR, long* PWDATA, long block_size) {
  scheduleGenericTransaction(portIndex,
                             1,
                             PADDR,
                             (unsigned char*)PWDATA,
                             transactionSize,
                             block_size,
                             0,
                             papoulis::getSimulationTime() + delay,
                             0,
                             0);
}

apb_bus_t_base::apb_bus_t_base(sc_module_name& module_name, long simulation,
                                           esl::sc_sim::user_model::Arbiter* arbiter) :
  papoulis::PapoulisBusBaseModel(module_name, arbiter, 0, 1),
  SD_INITIALIZE_PARAMETER(clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER(apb_clock, clock),
  SD_INITIALIZE_PARAMETER(nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER(verbose_parameters, true),
  SD_INITIALIZE_PARAMETER(dmi_enabled, true),
  SD_INITIALIZE_PARAMETER(warning_level, "WARNING"),
  SD_INITIALIZE_PARAMETER(layers, ""),
  SD_INITIALIZE_PARAMETER(slave_sets, ""),
  SD_INITIALIZE_PARAMETER(write_broadcast, 0),
  SD_INITIALIZE_PARAMETER(bus_slave_priority, 0),
  SD_INITIALIZE_PARAMETER(bus_slave_vmap, ""),
  SD_INITIALIZE_PARAMETER(uart_base_address, 0),
  SD_INITIALIZE_PARAMETER(uart_size, 0),
  SD_INITIALIZE_PARAMETER(uart_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(uart_secure, 0),
  SD_INITIALIZE_PARAMETER(uart_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(uart_latency, 0),
  SD_INITIALIZE_PARAMETER(uart_rst_ctrl_base_address, 0),
  SD_INITIALIZE_PARAMETER(uart_rst_ctrl_size, 0),
  SD_INITIALIZE_PARAMETER(uart_rst_ctrl_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(uart_rst_ctrl_secure, 0),
  SD_INITIALIZE_PARAMETER(uart_rst_ctrl_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(uart_rst_ctrl_latency, 0),
  SD_INITIALIZE_PARAMETER(bus_masterX_base_address, 0),
  SD_INITIALIZE_PARAMETER(bus_masterX_size, 0),
  SD_INITIALIZE_PARAMETER(bus_masterX_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(bus_masterX_secure, 0),
  SD_INITIALIZE_PARAMETER(bus_masterX_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(bus_masterX_latency, 0),
  SD_INITIALIZE_PARAMETER(bus_masterY_base_address, 0),
  SD_INITIALIZE_PARAMETER(bus_masterY_size, 0),
  SD_INITIALIZE_PARAMETER(bus_masterY_subtract_base_address, 1),
  SD_INITIALIZE_PARAMETER(bus_masterY_secure, 0),
  SD_INITIALIZE_PARAMETER(bus_masterY_additional_ranges, ""),
  SD_INITIALIZE_PARAMETER(bus_masterY_latency, 0),
        m_simulation(simulation), m_machine_arch(new apb_bus_machine_arch()), m_current_request(0)
{
  fix_clock_parameter(apb_clock, "apb_clock");
  fix_clock_parameter(apb_clock, "apb_clock");
  fix_clock_parameter(apb_clock, "apb_clock");
  fix_clock_parameter(apb_clock, "apb_clock");
  fix_clock_parameter(apb_clock, "apb_clock");
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[bus_slave].port_name = "bus_slave";
  port_descriptions[bus_slave].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[bus_slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[bus_slave].is_master_port = 0;
  port_descriptions[bus_slave].is_signal_port = 0;
  port_descriptions[bus_slave].port_width = ((32 + 7) >> 3);
  port_descriptions[bus_slave].port_width_in_bits = 32;
  port_descriptions[bus_slave].protocol_name = "apb";
  port_descriptions[bus_slave].ipxactBusDef.vendor = "amba.com";
  port_descriptions[bus_slave].ipxactBusDef.library = "AMBA2";
  port_descriptions[bus_slave].ipxactBusDef.name = "APB";
  port_descriptions[bus_slave].ipxactBusDef.version = "r2p0_4"; 
  port_descriptions[bus_slave].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[bus_slave].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[bus_slave].ipxactAbstrDef.name = "APB_tlm20";
  port_descriptions[bus_slave].ipxactAbstrDef.version = "1.0";
  port_descriptions[bus_slave].port_must_bind = 1;
  port_descriptions[bus_slave].params_count = 3;
  port_descriptions[bus_slave].clock = apb_clock;
  port_descriptions[bus_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[bus_slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[uart].port_name = "uart";
  port_descriptions[uart].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[uart].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[uart].is_master_port = 1;
  port_descriptions[uart].is_signal_port = 0;
  port_descriptions[uart].port_width = ((16 + 7) >> 3);
  port_descriptions[uart].port_width_in_bits = 16;
  port_descriptions[uart].protocol_name = "apb";
  port_descriptions[uart].ipxactBusDef.vendor = "amba.com";
  port_descriptions[uart].ipxactBusDef.library = "AMBA2";
  port_descriptions[uart].ipxactBusDef.name = "APB";
  port_descriptions[uart].ipxactBusDef.version = "r2p0_4"; 
  port_descriptions[uart].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[uart].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[uart].ipxactAbstrDef.name = "APB_tlm20";
  port_descriptions[uart].ipxactAbstrDef.version = "1.0";
  port_descriptions[uart].port_must_bind = 0;
  port_descriptions[uart].params_count = 3;
  port_descriptions[uart].clock = apb_clock;
  port_descriptions[uart].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[uart].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[uart_rst_ctrl].port_name = "uart_rst_ctrl";
  port_descriptions[uart_rst_ctrl].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[uart_rst_ctrl].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[uart_rst_ctrl].is_master_port = 1;
  port_descriptions[uart_rst_ctrl].is_signal_port = 0;
  port_descriptions[uart_rst_ctrl].port_width = ((32 + 7) >> 3);
  port_descriptions[uart_rst_ctrl].port_width_in_bits = 32;
  port_descriptions[uart_rst_ctrl].protocol_name = "apb";
  port_descriptions[uart_rst_ctrl].ipxactBusDef.vendor = "amba.com";
  port_descriptions[uart_rst_ctrl].ipxactBusDef.library = "AMBA2";
  port_descriptions[uart_rst_ctrl].ipxactBusDef.name = "APB";
  port_descriptions[uart_rst_ctrl].ipxactBusDef.version = "r2p0_4"; 
  port_descriptions[uart_rst_ctrl].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[uart_rst_ctrl].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[uart_rst_ctrl].ipxactAbstrDef.name = "APB_tlm20";
  port_descriptions[uart_rst_ctrl].ipxactAbstrDef.version = "1.0";
  port_descriptions[uart_rst_ctrl].port_must_bind = 0;
  port_descriptions[uart_rst_ctrl].params_count = 3;
  port_descriptions[uart_rst_ctrl].clock = apb_clock;
  port_descriptions[uart_rst_ctrl].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[uart_rst_ctrl].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[bus_masterX].port_name = "bus_masterX";
  port_descriptions[bus_masterX].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[bus_masterX].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[bus_masterX].is_master_port = 1;
  port_descriptions[bus_masterX].is_signal_port = 0;
  port_descriptions[bus_masterX].port_width = ((32 + 7) >> 3);
  port_descriptions[bus_masterX].port_width_in_bits = 32;
  port_descriptions[bus_masterX].protocol_name = "apb";
  port_descriptions[bus_masterX].ipxactBusDef.vendor = "amba.com";
  port_descriptions[bus_masterX].ipxactBusDef.library = "AMBA2";
  port_descriptions[bus_masterX].ipxactBusDef.name = "APB";
  port_descriptions[bus_masterX].ipxactBusDef.version = "r2p0_4"; 
  port_descriptions[bus_masterX].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[bus_masterX].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[bus_masterX].ipxactAbstrDef.name = "APB_tlm20";
  port_descriptions[bus_masterX].ipxactAbstrDef.version = "1.0";
  port_descriptions[bus_masterX].port_must_bind = 0;
  port_descriptions[bus_masterX].params_count = 3;
  port_descriptions[bus_masterX].clock = apb_clock;
  port_descriptions[bus_masterX].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[bus_masterX].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[bus_masterY].port_name = "bus_masterY";
  port_descriptions[bus_masterY].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[bus_masterY].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[bus_masterY].is_master_port = 1;
  port_descriptions[bus_masterY].is_signal_port = 0;
  port_descriptions[bus_masterY].port_width = ((32 + 7) >> 3);
  port_descriptions[bus_masterY].port_width_in_bits = 32;
  port_descriptions[bus_masterY].protocol_name = "apb";
  port_descriptions[bus_masterY].ipxactBusDef.vendor = "amba.com";
  port_descriptions[bus_masterY].ipxactBusDef.library = "AMBA2";
  port_descriptions[bus_masterY].ipxactBusDef.name = "APB";
  port_descriptions[bus_masterY].ipxactBusDef.version = "r2p0_4"; 
  port_descriptions[bus_masterY].ipxactAbstrDef.vendor = "Mentor.com";
  port_descriptions[bus_masterY].ipxactAbstrDef.library = "Lib_ipxact";
  port_descriptions[bus_masterY].ipxactAbstrDef.name = "APB_tlm20";
  port_descriptions[bus_masterY].ipxactAbstrDef.version = "1.0";
  port_descriptions[bus_masterY].port_must_bind = 0;
  port_descriptions[bus_masterY].params_count = 3;
  port_descriptions[bus_masterY].clock = apb_clock;
  port_descriptions[bus_masterY].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !1, 1);
  port_descriptions[bus_masterY].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !0, 1);

  port_descriptions[bus_slave].default_read_transaction_name = "READ";
  port_descriptions[uart].default_read_transaction_name = "READ";
  port_descriptions[uart_rst_ctrl].default_read_transaction_name = "READ";
  port_descriptions[bus_masterX].default_read_transaction_name = "READ";
  port_descriptions[bus_masterY].default_read_transaction_name = "READ";

  port_descriptions[bus_slave].default_write_transaction_name = "WRITE";
  port_descriptions[uart].default_write_transaction_name = "WRITE";
  port_descriptions[uart_rst_ctrl].default_write_transaction_name = "WRITE";
  port_descriptions[bus_masterX].default_write_transaction_name = "WRITE";
  port_descriptions[bus_masterY].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);
  
  esl::tlm_sim::UserRunningModel* model = Papoulis_CreateUserRunningModel(name(),
                                                                          0,
                                                                          this,
                                                                          simulation,
                                                                          true,
                                                                          false);
  setUserRunningModel(model, false);
  createDecoder(model);
  registerParameter("clock", "sc_core::sc_time", sdGetParameterAsConstString("clock"));
  registerParameter("apb_clock", "sc_core::sc_time", sdGetParameterAsConstString("apb_clock"));
  registerParameter("nominal_voltage", "double", sdGetParameterAsConstString("nominal_voltage"));
  registerParameter("verbose_parameters", "bool", sdGetParameterAsConstString("verbose_parameters"));
  registerParameter("dmi_enabled", "bool", sdGetParameterAsConstString("dmi_enabled"));
  registerParameter("warning_level", "const char*", sdGetParameterAsConstString("warning_level"));
  registerParameter("layers", "const char*", sdGetParameterAsConstString("layers"));
  registerParameter("slave_sets", "const char*", sdGetParameterAsConstString("slave_sets"));
  registerParameter("write_broadcast", "unsigned int", sdGetParameterAsConstString("write_broadcast"));
  registerParameter("bus_slave_priority", "unsigned int", sdGetParameterAsConstString("bus_slave_priority"));
  registerParameter("bus_slave_vmap", "const char*", sdGetParameterAsConstString("bus_slave_vmap"));
  registerParameter("uart_base_address", "unsigned long long", sdGetParameterAsConstString("uart_base_address"));
  registerParameter("uart_size", "unsigned long long", sdGetParameterAsConstString("uart_size"));
  registerParameter("uart_subtract_base_address", "unsigned int", sdGetParameterAsConstString("uart_subtract_base_address"));
  registerParameter("uart_secure", "unsigned int", sdGetParameterAsConstString("uart_secure"));
  registerParameter("uart_additional_ranges", "const char*", sdGetParameterAsConstString("uart_additional_ranges"));
  registerParameter("uart_latency", "unsigned int", sdGetParameterAsConstString("uart_latency"));
  registerParameter("uart_rst_ctrl_base_address", "unsigned long long", sdGetParameterAsConstString("uart_rst_ctrl_base_address"));
  registerParameter("uart_rst_ctrl_size", "unsigned long long", sdGetParameterAsConstString("uart_rst_ctrl_size"));
  registerParameter("uart_rst_ctrl_subtract_base_address", "unsigned int", sdGetParameterAsConstString("uart_rst_ctrl_subtract_base_address"));
  registerParameter("uart_rst_ctrl_secure", "unsigned int", sdGetParameterAsConstString("uart_rst_ctrl_secure"));
  registerParameter("uart_rst_ctrl_additional_ranges", "const char*", sdGetParameterAsConstString("uart_rst_ctrl_additional_ranges"));
  registerParameter("uart_rst_ctrl_latency", "unsigned int", sdGetParameterAsConstString("uart_rst_ctrl_latency"));
  registerParameter("bus_masterX_base_address", "unsigned long long", sdGetParameterAsConstString("bus_masterX_base_address"));
  registerParameter("bus_masterX_size", "unsigned long long", sdGetParameterAsConstString("bus_masterX_size"));
  registerParameter("bus_masterX_subtract_base_address", "unsigned int", sdGetParameterAsConstString("bus_masterX_subtract_base_address"));
  registerParameter("bus_masterX_secure", "unsigned int", sdGetParameterAsConstString("bus_masterX_secure"));
  registerParameter("bus_masterX_additional_ranges", "const char*", sdGetParameterAsConstString("bus_masterX_additional_ranges"));
  registerParameter("bus_masterX_latency", "unsigned int", sdGetParameterAsConstString("bus_masterX_latency"));
  registerParameter("bus_masterY_base_address", "unsigned long long", sdGetParameterAsConstString("bus_masterY_base_address"));
  registerParameter("bus_masterY_size", "unsigned long long", sdGetParameterAsConstString("bus_masterY_size"));
  registerParameter("bus_masterY_subtract_base_address", "unsigned int", sdGetParameterAsConstString("bus_masterY_subtract_base_address"));
  registerParameter("bus_masterY_secure", "unsigned int", sdGetParameterAsConstString("bus_masterY_secure"));
  registerParameter("bus_masterY_additional_ranges", "const char*", sdGetParameterAsConstString("bus_masterY_additional_ranges"));
  registerParameter("bus_masterY_latency", "unsigned int", sdGetParameterAsConstString("bus_masterY_latency"));
  

  delay_policy* delay_policy_handle = 0;

  delay_policy_handle = new delay_policy(model,
                                         "bus_slave",
                                         0,
                                         0,
                                         mb::tlm20::SYNC_BEGIN);
  delay_policy_handle->set_power(0);
  m_delay_vector.push_back(delay_policy_handle);
  unsigned pipeline_policy_index = 0;
  pipeline_policy* pipeline_policy_handle = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "uart";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(uart_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "uart_rst_ctrl";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(uart_rst_ctrl_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "bus_masterX";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(bus_masterX_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  user_pipeline_policy_descriptions[pipeline_policy_index].firstTransaction = "bus_slave";
  user_pipeline_policy_descriptions[pipeline_policy_index].secondTransaction = "bus_masterY";
  user_pipeline_policy_descriptions[pipeline_policy_index].setLatency(bus_masterY_latency);
  user_pipeline_policy_descriptions[pipeline_policy_index].bytesToPass = 0;
  user_pipeline_policy_descriptions[pipeline_policy_index].syncMode = mb::tlm20::SYNC_BEGIN;
  pipeline_policy_handle = new pipeline_policy(model, user_pipeline_policy_descriptions[pipeline_policy_index]);
  m_pipeline_vector.push_back(pipeline_policy_handle);
  pipeline_policy_handle->set_power(0);
  pipeline_policy_index++;
  set_user_pipeline_policies(user_pipeline_policy_count, user_pipeline_policy_descriptions);
  
  constant_global_power_policy* p = new constant_global_power_policy(model);
  
  
  
  set_global_power_policy(p);
}

void apb_bus_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;

  if (handle == m_pipeline_vector[0]) {
    handle->setLatency(uart_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[1]) {
    handle->setLatency(uart_rst_ctrl_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[2]) {
    handle->setLatency(bus_masterX_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
  if (handle == m_pipeline_vector[3]) {
    handle->setLatency(bus_masterY_latency);
    //if (0 == 0) {
    //printf("WARNING: in \"%s\" the buffer size parameter of the pipeline is 0, a default value of 1 is used\n", name());
    //handle->setBytesToPass(1);
    //}
    //else
    handle->setBytesToPass(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }

}

void apb_bus_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(0);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::SYNC_BEGIN);
    handle->set_power(0);
    return;
  }
}

void apb_bus_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}


void apb_bus_t_base::vista_trace(bool isStart, request_type* request, long portIndex, sc_dt::uint64 startTime) {
  
  sc_dt::uint64 local_params[3];
  for (unsigned u = 0; u < 3; u++)
    local_params[u] = 0;
  
  sc_dt::uint64 address = request->get_address();
  
  local_params[0] = address;
  
  local_params[2] = get_port_width(portIndex);
  sc_dt::uint64* parameters = local_params;
  long size = request->get_data_length();
  
  bool isWrite = request->is_write();
  m_current_request = request;
  if(isStart) {
    this->print_transaction(portIndex, isWrite, true, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->accept_apb_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      } else {
        this->accept_apb_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      }
    } else {
      if (is_master(portIndex)) {
        this->accept_apb_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      } else {
        this->accept_apb_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      }
    }
  } else {
    this->print_transaction(portIndex, isWrite, false, address, size);
    if (isWrite) {
      if (is_master(portIndex)) {
        this->end_apb_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      } else {
        this->end_apb_WRITE
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      }
    } else {
      if (is_master(portIndex)) {
        this->end_apb_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      } else {
        this->end_apb_READ
          (portIndex, 
           startTime, 
           size,
           parameters[0],
           parameters[1],
           parameters[2]);
      }
    }
  }
  m_current_request = 0;
}

request_type* apb_bus_t_base::get_current_request() {
  return m_current_request;
}

unsigned apb_bus_t_base::get_layer(unsigned port_index) {
  if (is_slave(port_index))
    return m_arbiter->get_slave_layer(port_index);
  return m_arbiter->get_master_layer(port_index);
}

unsigned apb_bus_t_base::get_slave_port_index() {
  if (!m_current_request) {
    printf("ERROR: when calling get_slave_port_index in %s\n", name());
    return (unsigned)(-1);
  }
  return  m_arbiter->getMasterIndexByRequestId(m_current_request);
}

void apb_bus_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2012     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for apb_bus.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 4.1.0
//* Generated on: Jan. 18, 2016 04:09:45 PM, (user: mbradley)
//*>

#include "apb_bus_model.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


#include "apb_bus_pv.h"




// Constructor
apb_bus_pvt::apb_bus_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    apb_bus_pvt_param_defaults(this->name()),
    uart("uart"),
    uart_rst_ctrl("uart_rst_ctrl"),
    bus_masterX("bus_masterX"),
    bus_masterY("bus_masterY"),
    bus_slave("bus_slave"), 
    uart_entry("unvisible_uart_entry"), 
    uart_rst_ctrl_entry("unvisible_uart_rst_ctrl_entry"), 
    bus_masterX_entry("unvisible_bus_masterX_entry"), 
    bus_masterY_entry("unvisible_bus_masterY_entry"),
    bus_slave_entry("unvisible_bus_slave_entry"),
    m_uart_nb_connector(*this),
    m_uart_rst_ctrl_nb_connector(*this),
    m_bus_masterX_nb_connector(*this),
    m_bus_masterY_nb_connector(*this),
    m_bus_slave_nb_connector(*this)

{


  m_apb_bus_t = apb_bus_t_base::create_t("T", 1);
  m_apb_bus_pv = new apb_bus_pv("PV");
  bind();
}  


apb_bus_pvt::apb_bus_pvt(sc_module_name module_name, sc_core::sc_time clock_init, sc_core::sc_time apb_clock_init, double nominal_voltage_init, bool verbose_parameters_init, bool dmi_enabled_init, const char* warning_level_init, const char* layers_init, const char* slave_sets_init, unsigned int write_broadcast_init, unsigned int bus_slave_priority_init, const char* bus_slave_vmap_init, unsigned long long uart_base_address_init, unsigned long long uart_size_init, unsigned int uart_subtract_base_address_init, unsigned int uart_secure_init, const char* uart_additional_ranges_init, unsigned int uart_latency_init, unsigned long long uart_rst_ctrl_base_address_init, unsigned long long uart_rst_ctrl_size_init, unsigned int uart_rst_ctrl_subtract_base_address_init, unsigned int uart_rst_ctrl_secure_init, const char* uart_rst_ctrl_additional_ranges_init, unsigned int uart_rst_ctrl_latency_init, unsigned long long bus_masterX_base_address_init, unsigned long long bus_masterX_size_init, unsigned int bus_masterX_subtract_base_address_init, unsigned int bus_masterX_secure_init, const char* bus_masterX_additional_ranges_init, unsigned int bus_masterX_latency_init, unsigned long long bus_masterY_base_address_init, unsigned long long bus_masterY_size_init, unsigned int bus_masterY_subtract_base_address_init, unsigned int bus_masterY_secure_init, const char* bus_masterY_additional_ranges_init, unsigned int bus_masterY_latency_init)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  apb_bus_pvt_param_defaults(this->name(), clock_init, apb_clock_init, nominal_voltage_init, verbose_parameters_init, dmi_enabled_init, warning_level_init, layers_init, slave_sets_init, write_broadcast_init, bus_slave_priority_init, bus_slave_vmap_init, uart_base_address_init, uart_size_init, uart_subtract_base_address_init, uart_secure_init, uart_additional_ranges_init, uart_latency_init, uart_rst_ctrl_base_address_init, uart_rst_ctrl_size_init, uart_rst_ctrl_subtract_base_address_init, uart_rst_ctrl_secure_init, uart_rst_ctrl_additional_ranges_init, uart_rst_ctrl_latency_init, bus_masterX_base_address_init, bus_masterX_size_init, bus_masterX_subtract_base_address_init, bus_masterX_secure_init, bus_masterX_additional_ranges_init, bus_masterX_latency_init, bus_masterY_base_address_init, bus_masterY_size_init, bus_masterY_subtract_base_address_init, bus_masterY_secure_init, bus_masterY_additional_ranges_init, bus_masterY_latency_init),
    uart("uart"),
    uart_rst_ctrl("uart_rst_ctrl"),
    bus_masterX("bus_masterX"),
    bus_masterY("bus_masterY"),
    bus_slave("bus_slave"), 
    uart_entry("unvisible_uart_entry"), 
    uart_rst_ctrl_entry("unvisible_uart_rst_ctrl_entry"), 
    bus_masterX_entry("unvisible_bus_masterX_entry"), 
    bus_masterY_entry("unvisible_bus_masterY_entry"),
    bus_slave_entry("unvisible_bus_slave_entry"),
    m_uart_nb_connector(*this),
    m_uart_rst_ctrl_nb_connector(*this),
    m_bus_masterX_nb_connector(*this),
    m_bus_masterY_nb_connector(*this),
    m_bus_slave_nb_connector(*this)
{


  m_apb_bus_t = apb_bus_t_base::create_t("T", 1);
  m_apb_bus_pv = new apb_bus_pv("PV");
  bind();
} 

apb_bus_pvt::apb_bus_pvt(sc_module_name module_name,  std::vector<std::pair<char*, unsigned int> > &change_parameters)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
  apb_bus_pvt_param_defaults(this->name(), change_parameters),
    uart("uart"),
    uart_rst_ctrl("uart_rst_ctrl"),
    bus_masterX("bus_masterX"),
    bus_masterY("bus_masterY"),
    bus_slave("bus_slave"), 
    uart_entry("unvisible_uart_entry"), 
    uart_rst_ctrl_entry("unvisible_uart_rst_ctrl_entry"), 
    bus_masterX_entry("unvisible_bus_masterX_entry"), 
    bus_masterY_entry("unvisible_bus_masterY_entry"),
    bus_slave_entry("unvisible_bus_slave_entry"),
    m_uart_nb_connector(*this),
    m_uart_rst_ctrl_nb_connector(*this),
    m_bus_masterX_nb_connector(*this),
    m_bus_masterY_nb_connector(*this),
    m_bus_slave_nb_connector(*this)
{


  m_apb_bus_t = apb_bus_t_base::create_t("T", 1);
  m_apb_bus_pv = new apb_bus_pv("PV");
  bind();
} 

apb_bus_pvt::~apb_bus_pvt() {
  remove_pending_scenes();
  delete m_apb_bus_t; delete m_apb_bus_pv;
}




void apb_bus_pvt::bind()
{
  /* connect pv to entry ports */
  
  
  getPV()->uart.bind(uart_entry);
  getPV()->uart_rst_ctrl.bind(uart_rst_ctrl_entry);
  getPV()->bus_masterX.bind(bus_masterX_entry);
  getPV()->bus_masterY.bind(bus_masterY_entry);
  bus_slave_entry.bind(getPV()->bus_slave);   

  /* set callbacks on external and entry ports */ 

  bus_slave.b_transport_cb.set(&bus_slave_entry, &bus_slave_entry_type::b_transport);
  bus_slave.transport_dbg_cb.set(&bus_slave_entry, &bus_slave_entry_type::transport_dbg);
  bus_slave.get_direct_mem_ptr_cb.set(&bus_slave_entry, &bus_slave_entry_type::get_direct_mem_ptr);

  uart_entry.b_transport_cb.set(this, &self_type::b_transport_outside_uart);
  uart_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_uart);
  uart_entry.get_direct_mem_ptr_cb.set(&uart, &uart_type::get_direct_mem_ptr);

  uart_rst_ctrl_entry.b_transport_cb.set(this, &self_type::b_transport_outside_uart_rst_ctrl);
  uart_rst_ctrl_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_uart_rst_ctrl);
  uart_rst_ctrl_entry.get_direct_mem_ptr_cb.set(&uart_rst_ctrl, &uart_rst_ctrl_type::get_direct_mem_ptr);

  bus_masterX_entry.b_transport_cb.set(this, &self_type::b_transport_outside_bus_masterX);
  bus_masterX_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_bus_masterX);
  bus_masterX_entry.get_direct_mem_ptr_cb.set(&bus_masterX, &bus_masterX_type::get_direct_mem_ptr);

  bus_masterY_entry.b_transport_cb.set(this, &self_type::b_transport_outside_bus_masterY);
  bus_masterY_entry.transport_dbg_cb.set(this, &self_type::transport_dbg_outside_bus_masterY);
  bus_masterY_entry.get_direct_mem_ptr_cb.set(&bus_masterY, &bus_masterY_type::get_direct_mem_ptr);

  
  /* connect t non blocking callbacks */

  uart.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_uart);
  getT()->set_port_cb(1, &m_uart_nb_connector);

  uart_rst_ctrl.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_uart_rst_ctrl);
  getT()->set_port_cb(2, &m_uart_rst_ctrl_nb_connector);

  bus_masterX.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_bus_masterX);
  getT()->set_port_cb(3, &m_bus_masterX_nb_connector);

  bus_masterY.nb_transport_bw_cb.set(this, &self_type::receive_nb_transport_bus_masterY);
  getT()->set_port_cb(4, &m_bus_masterY_nb_connector);

  bus_slave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_bus_slave);
  getT()->set_port_cb(0, &m_bus_slave_nb_connector);

  bus_slave_entry.invalidate_direct_mem_ptr_cb.set(&bus_slave, &bus_slave_type::invalidate_direct_mem_ptr);

  uart.invalidate_direct_mem_ptr_cb.set(&uart_entry, &uart_entry_type::invalidate_direct_mem_ptr);

  uart_rst_ctrl.invalidate_direct_mem_ptr_cb.set(&uart_rst_ctrl_entry, &uart_rst_ctrl_entry_type::invalidate_direct_mem_ptr);

  bus_masterX.invalidate_direct_mem_ptr_cb.set(&bus_masterX_entry, &bus_masterX_entry_type::invalidate_direct_mem_ptr);

  bus_masterY.invalidate_direct_mem_ptr_cb.set(&bus_masterY_entry, &bus_masterY_entry_type::invalidate_direct_mem_ptr);

  /* check mb_event policies */
  m_apb_bus_t->check_mb_events();
}



void apb_bus_pvt::b_transport_outside_uart(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!uart.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << uart.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), uart.name());
    return;
  }
  uart.b_transport(p, t);
  
} 

unsigned int apb_bus_pvt::transport_dbg_outside_uart(tlm::tlm_generic_payload& p)
{
  if (!uart.get_interface()) {
     return 0;
  }
  return uart.transport_dbg(p);
  
}

void apb_bus_pvt::b_transport_outside_uart_rst_ctrl(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!uart_rst_ctrl.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << uart_rst_ctrl.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), uart_rst_ctrl.name());
    return;
  }
  uart_rst_ctrl.b_transport(p, t);
  
} 

unsigned int apb_bus_pvt::transport_dbg_outside_uart_rst_ctrl(tlm::tlm_generic_payload& p)
{
  if (!uart_rst_ctrl.get_interface()) {
     return 0;
  }
  return uart_rst_ctrl.transport_dbg(p);
  
}

void apb_bus_pvt::b_transport_outside_bus_masterX(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!bus_masterX.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << bus_masterX.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), bus_masterX.name());
    return;
  }
  bus_masterX.b_transport(p, t);
  
} 

unsigned int apb_bus_pvt::transport_dbg_outside_bus_masterX(tlm::tlm_generic_payload& p)
{
  if (!bus_masterX.get_interface()) {
     return 0;
  }
  return bus_masterX.transport_dbg(p);
  
}

void apb_bus_pvt::b_transport_outside_bus_masterY(tlm::tlm_generic_payload& p, sc_core::sc_time& t)
{
  if (!bus_masterY.get_interface()) {
    p.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
    std::stringstream buf;
    buf << "The port " << bus_masterY.name() << " is unbound";
    mb::sysc::complain(buf.str().c_str(), bus_masterY.name());
    return;
  }
  bus_masterY.b_transport(p, t);
  
} 

unsigned int apb_bus_pvt::transport_dbg_outside_bus_masterY(tlm::tlm_generic_payload& p)
{
  if (!bus_masterY.get_interface()) {
     return 0;
  }
  return bus_masterY.transport_dbg(p);
  
}

